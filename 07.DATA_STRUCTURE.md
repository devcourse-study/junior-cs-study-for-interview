## 자료구조

<details>
    <summary><b>Array</b></summary>

## 정리
### Array
- 자료들을 연속적인 메모리 주소에 저장하는 저장소
- 인덱스를 통해 자료들을 접근한다.
### 시간 복잡도
- 자료 삽입 및 삭제: O(1)
- 자료 접근: O(1)
- 자료 탐색: O(N)
### 장단점
- 장점
  - 자료 접근이 빠르다.
  - 메모리 주소가 연속되기 때문에 지역성이 높아 성능이 뛰어날 확률이 높다.
- 단점
  - 배열의 크기를 바꾸지 못한다.
  - 빈공간이 존재하여 메모리의 낭비가 존재할 수 있다.
  - 중간에 요소를 삭제하거나 추가하는데 코스트가 많이 든다.
### 활용
- 동일한 타입의 데이터를 저장할 수 있다.
- 데이터베이스의 레코드
- CPU 스케쥴링
- 스택, 큐, 힙, 해시 테이블의 구현
## 참조
- https://www.geeksforgeeks.org/what-is-array/
</details>

---

<details>
    <summary><b>List</b></summary>

## 정리
### List
- 선형 자료구조로 연속적인 메모리에 저장되지 않고, 비연속적으로 저장되는 저장소이다.
- 빈 공간을 허용하지 않는다.
- 크기가 가변적이다.
### 시간 복잡도
- 자료 삽입 및 삭제: O(N)
- 자료 접근: O(N)
- 자료 탐색: O(N)
### 장단점
- 장점
  - 빈 공간을 허용하지 않아 메모리를 효율적으로 사용할 수 있다.
  - 크기가 가변적이다.
  - 중간에 요소를 추가하거나 삭제하는게 편하다.
- 단점
  - 접근이 느리다.
  - 지역성이 떨어져 성능이 떨어질 수 있다.
### 활용
- 그래프 구현
## 참조
- https://www.geeksforgeeks.org/what-is-linked-list/
- https://ongveloper.tistory.com/403
</details>

---

<details>
    <summary><b>HashTable</b></summary>

## 정리
### HashTable
- 해싱을 이용한 key-value 형태의 자료구조이다.
- hash function 을 통해 키를 특정한다.
### 충돌 방지
- Open Addressing
  - 충돌 시 테이블의 빈 공간에 저장하는 방식
- Separate Chaining
  - 각 해시 값에 대해 링크드 리스트를 유지하는 방식
### 시간 복잡도
- 자료 삽입 및 삭제: O(1)
- 자료 접근: O(1)
### 장단점
- 장점
  - 탐색이 빠르다.
  - 삽입 삭제가 간편하다.
- 단점
  - 구현이 어렵다.
  - 충돌시 비효율적이다.
### 활용
- 캐싱 시스템 구현
- 데이터베이스 구현
## 참조
- https://www.geeksforgeeks.org/hash-table-data-structure/
</details>

---

<details>
    <summary><b>Queue</b></summary>

## 정리
### Queue
- 선형 자료구조로, FIFO 의 순서로 요소가 연산되는 저장소이다.
- FIFO: First In First Out
### 종류
- Circular Queue
  - 끝 요소와 시작 요소가 이어져있는 큐
  - 삽입, 삭제에 O(1) 이 소모된다.
  - 메모리 관리, CPU 스케쥴링에 사용될 수 있다.
- Dequeue
  - 삽입과 삭제가 양쪽 에서 일어나는 큐
  - 스택과 큐로 동시에 사용될 수 있다.
- Priority Queue
  - 우선순위에 따라 요소들을 정렬하는 하는 큐
#### Priority Queue
- 구현하는 자료구조에 따른 시간복잡도

|        자료구조        | 삽입      | 삭제      | 접근      |
|:------------------:|---------|---------|---------|
|       Array        | O(1)    | O(N)    | O(N)    |
|     LinkedList     | O(N)    | O(1)    | O(1)    |
|    Binary Heap     | O(LogN) | O(LogN) | O(1)    |
| Binary Search Tree | O(1)    | O(LogN) | O(LogN) |
### 장단점
- 장점
  - 삽입, 삭제가 간편하다.
  - 다중 프로세스, 스레드 처리에 유용할 수 있다.
- 단점
  - 중간 요소의 삽입, 삭제가 힘들다.
  - 검색이 비효율적이다.
### 활용
- 멀티 프로그래밍
- 네트워크의 라우터나 스위치
- 공유 자원
## 참조
- https://www.geeksforgeeks.org/introduction-to-queue-data-structure-and-algorithm-tutorials/
- https://www.geeksforgeeks.org/introduction-to-circular-queue/
- https://www.geeksforgeeks.org/deque-set-1-introduction-applications/
- https://www.geeksforgeeks.org/priority-queue-set-1-introduction/
- https://www.geeksforgeeks.org/applications-advantages-and-disadvantages-of-queue/
</details>

---

<details>
    <summary><b>Stack</b></summary>

## 정리
### Stack
- 선형 자료구조로, LIFO 의 순서로 요소가 연산되는 저장소이다.
- LIFO: Last In First Out
### 시간 복잡도
- 자료 삽입 및 삭제: O(1)
- 자료 접근: O(N)
- 자료 탐색: O(N)
### 장단점
- 장점
  - 구현이 간편하다.
  - 메모리를 효율적으로 사용한다.
- 단점
  - 요소 접근이 어렵다.
  - 메모리 단편화가 일어날 수 있다.
### 활용
- 함수 호출 연산 및 recursion 연산
- undo/redo 연산
## 참조
- https://www.geeksforgeeks.org/applications-advantages-and-disadvantages-of-stack/
</details>

---

<details>
    <summary><b>Graph</b></summary>
</details>

<details>
    <summary><b>DFS, BFS</b></summary>
</details>

---

<details>
    <summary><b>Heap</b></summary>
</details>

---

<details>
    <summary><b>Tree</b></summary>
</details>

<details>
    <summary><b>Binary Tree</b></summary>
</details>

<details>
    <summary><b>Full Binary Tree</b></summary>
</details>

<details>
    <summary><b>Complete Binary Tree</b></summary>
</details>

<details>
    <summary><b>Binary Search Tree</b></summary>
</details>

<details>
    <summary><b>AVL Tree</b></summary>
</details>

<details>
    <summary><b>Red-Black Tree</b></summary>
</details>

---
