## JPA

<details>
    <summary><b>JDBC, Spring JDBC</b></summary>

## 정리
### JDBC 란?
- 자바의 데이터 액세스 기술의 기본이 되는 로우 레벨 API 이다.
- 표준 인터페이스를 제공하고 여러 DB 벤더가 해당 인터페이스를 구현한 드라이버를 제공한다.
- 문제점
  - 쿼리를 실행하기 위해 많은 코드를 작성해야 한다.
  - DB 에 따라 정보가 달라져, 일관성이 없는 체크 예외가 발생한다.
- 장점
  - 표준화된 방식으로 데이터 액세스를 할 수 있다.
  - 러닝 커브가 크지 않다.
#### 실행 과정
1. Connection 을 가져온다.
2. SQL 을 담은 Statement(또는 PreparedStatement) 를 만든다.
3. Statement 를 실행한다.
4. Result 를 받아 객체로 옮긴다.
5. Connection, Statement, ResultSet 등 사용하지 않는 리소스를 해제한다.
6. JDBC API 가 만드는 예외를 처리한다.
### Spring JDBC 란?
- JDBC 의 장점과 단순성은 유지하고 문제를 해결하여 편리하게 사용할 수 있게 만든 API
#### DB 접근 방법
- JdbcTemplate
  - 가장 클래식하고 기본인 접근 방식
- NamedParameterJdbcTemplate
  - `?` 로 파라미터를 매핑하는 것 대신 이름으로 매핑
  - 파라미터가 여러 개 있을 때 유리하다.
- SimpleJdbcInsert, SimpleJdbcCall
  - DB 가 제공해주는 메타 데이터를 이용하여 코드 작성을 최소화해준다.
  - 메타 데이터에서 컬럼 정보와 파라미터 정보를 가져와서 삽입용 SQL 과 프로시저를 호출하기 때문에 편리하다.
  - 메타데이터를 제공하지 않는 DB 에서는 사용할 수 없다.
#### 제공하는 편의 기능
- Connection 열기와 닫기: 트랜잭션과 연계되어 커넥션 관리를 해준다.
- Statement 준비와 닫기
- Statement 실행
- ResultSet Loop 처리
- Exception 처리와 반환: CheckedException 인 SQLException 을 DataAccessException 으로 변환한다.
- Transaction 처리
## 참조
- https://docs.spring.io/spring-framework/reference/data-access/jdbc/choose-style.html
</details>

<details>
    <summary><b>Connection Pool</b></summary>

## 정리
### Connection 이란?
- DB 를 사용하기 위해 DB 와 애플리케이션 간 통신을 할 수 있는 수단
### Connection Pool 이란?
- Connection 객체들을 모아둔 공간
- 사용자의 요청이 올 때마다 Connection 을 생성하고 끊는 작업은 매우 비효율적이므로 Connection Pool 을 사용한다.
## 참조

</details>

<details>
    <summary><b>DataSource</b></summary>

## 정리
### 
### DBCP
- WAS 가 실행되면서 일정량의 Connection 객체를 미리 만들어서 Pool 에 저장했다가, 클라이언트 요청이 오면 Connection 객체를 빌려주고 해당 객체의 임무가 완료되면 다시 Connection 객체를 반납받아서 Pool 에 저장하는 프로그래밍 기법
### 장점
- DB 접속 설정 객체를 미리 만들어 메모리에 등록하기 때문에 생성, 삭제 작업이 사라지므로 효율적이다.
- DB Connection 수를 제한할 수 있어 과도한 접속으로 인한 서버 자원 고갈 방지가 가능하다.
- DB 접속 모듈을 공통화하여 DB 서버 환경이 바뀔경우 대처가 쉽다.
### 고려할 점
- 동시 접속자가 많을 경우
  - Connection 은 한정되어 있으므로 사용할 수 있는 Connection 객체가 반납될 때까지 대기해야 한다.
  - 이를 위해 Connection 의 제한을 크게 잡으면 사용자의 대기 시간은 줄어들지만, 메모리 소모가 크고,
  - 작게 잡으면 대기 시간이 길어진다.
- Connection Pool 이 커지게 되면?
  - 하나의 Connection 은 하나의 Thread 가 담당한다. 따라서 Thread Pool 과 Connection Pool 의 크기를 적절히 조절해야 한다.
  - Thread Pool <<< Connection Pool 인 경우 (Connection Pool 만 크기 증가)
    - 놀게 되는 Connection 이 많아지므로 효율적인 메모리 사용이 아니다.
  - Thread Pool, Connection Pool 둘 다 크기 증가인 경우
    - 노는 Connection 이 많아져 Thread 를 추가하게 되면 다음의 문제가 발생할 수 있다.
    - Thread 증가로 인해 Context Switching 이 발생한다.
    - Disk 경합 측면에서 성능 한계가 발생한다.
      - DB 는 하드디스크 하나 당 하나의 I/O 를 처리하기 때문에 병목이 발생할 수 있다.
- 적당한 Connection Pool 의 크기는? (Hikari CP)
  - Hikari CP 위키를 보면 다음 공식을 제안한다.
  - `Pool Size = Tn * (Cm - 1) + 1`
  - Tn: 전체 Thread 갯수
  - Cm: 하나의 Task 에서 동시에 필요한 Connection 수
### Hikari CP 란?
- 스프링 부터 2.0 버전부터 기본으로 사용하는 DBCP 이다.
- 장점
  - 적은 메모리 사용량
  - 높은 처리량
  - 작은 코드 베이스
  - 풍부한 구성 옵션
  - 스레드 안정성
- 설정 옵션
  - minimum-idle: Connection Pool 에 유지 가능한 최소 커넥션 개수
  - maximum-pool-size: Connection Pool 에 유지 가능한 최대 커넥션 개수
  - idle-timeout: Connection 이 Pool 에서 유휴상태(사용하지 않는 상태)로 남을 수 있는 최대 시간
  - pool-name: Connection Pool 이름
  - max-lifetime: Connection 의 최대 유지 가능 시간
  - connection-timeout: Pool 에서 Connection 을 구할 때 대기시간, 대기시간안에 구하지 못하면 Exception
  - connection-test-query: Connection 이 잘 되었는지 확인하는 TEST SQL
## 참조
- https://techblog.woowahan.com/2663/
- https://steady-coding.tistory.com/564
- https://dkswnkk.tistory.com/685
</details>

---

<details>
    <summary><b>Sql Mapper(MyBatis)</b></summary>

## 정리
### SQL Mapper 란?
- 객체와 관계형 데이터베이스의 데이터를 개발자가 작성한 SQL 로 매핑시켜주는 프레임워크
### 장단점
- 장점
  - JDBC 를 사용하는 것에 비해 코드 작성이 간편하다.
  - XML 을 통해 관리하기 때문에 변경에 용이하고 유지보수가 편하다.
- 단점
  - DBMS 에 따라 SQL 문법이 다르기 때문에 이에 종속적이다.
  - SQL 을 직접 작성해야 한다.
  - 객체 모델과 관계 모델을 따로 관리해야 한다. 
## 참조

</details>

---

<details>
    <summary><b>JPA, Hibernate</b></summary>

## 정리
### JPA 이란?
- Java 진영의 ORM 기술 표준이다.
### 장단점
- 장점
  - 객체지향적으로 데이터를 관리할 수 있다.
  - 데이터베이스에 종속적이지 않다.
  - 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩 등으로 성능 상으로 이점이 존재한다.
  - 생산성과 유지보수가 뛰어나다.
- 단점
  - 복잡한 쿼리를 작성하기 힘들다.
  - 러닝커브가 존재한다.
  - 제대로 사용하지 못하면 성능이 오히려 떨어진다.
### Hibernate 란?
- JPA 의 구현체이다.
## 참조
- https://incheol-jung.gitbook.io/docs/study/jpa/2020-04-07-jpa-chap1
</details>

<details>
    <summary><b>ORM</b></summary>

## 정리
### ORM 이란?
- 객체와 관계형 데이터베이스를 매핑한다는 의미이다.
- 객체와 테이블을 매핑하여 패러다임 불일치를 개선한다.
## 참조
</details>

---

<details>
    <summary><b>영속성 컨텍스트</b></summary>

## 정리
### 영속성 컨텍스트란?
- 서버와 데이터베이스 사이에 엔티티를 저장하는 논리적인 영역
- 엔티티 매니저는 영속성 컨텍스트에 엔티티를 저장하고 관리한다.
### 엔티티 생명 주기
- 비영속
  - 영속성 컨텍스트와 관계가 없는 상태
  - 단순 생성만한 상태
- 영속
  - 영속성 컨텍스트에 저장된 상태
  - 영속성 컨텍스트에 관리되는 상태
- 준영속
  - 영속성 컨텍스트에 저장되었다가 분리된 상태
  - 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않은 상태
  - em.detach(), em.close(), em.clear()
- 삭제
  - 삭제된 상태
  - em.remove()
### 특징
- 식별자
  - 엔티티를 식별자 값을 이용하여 구분한다.
  - 영속 상태에서는 반드시 식별자 값이 존재해야 한다.
- 저장
  - 영속성 컨텍스트에 저장된 엔티티는 트랜잭션이 끝날 때 보통 저장된다.
  - 플러시라고 한다.
### 장점
#### 1차 캐시
- 엔티티를 조회할 때 1차 캐시에서 조회한다. 만약 없으면 데이터베이스에서 조회하여 1차 캐시로 가져온다. 
- 데이터베이스를 조회하지 않고 메모리에서 조회하기 때문에 성능상으로 이점이 있다.
- 2차 캐시: 어플리케이션 범위의 캐시로 어플리케이션이 종료될 때까지 유지된다. 
  - 동시성을 위해 캐싱한 객체를 복사해서 반환한다. (동일성을 보장하지 않는다.)
  - 하이버네이트에서 지원하는 2차 캐시
    - 엔티티 캐시: 엔티티 단위로 캐시. 식별자로 엔티티를 조회하거나 컬렉션이 아닌 연관된 엔티티 조회할 때 사용
    - 컬렉션 캐시: 엔티티와 연관된 컬렉션 캐시. 컬렉션이 엔티티를 담고 있는 경우, 식별자 값만 캐시
    - 쿼리 캐시: 쿼리와 파라미터 정보를 키로 사용해서 캐시. 결과가 엔티티일 경우, 식별자만 캐시
#### 동일성 보장
- == 연산이 가능하다.
- 식별자가 동일하게 엔티티를 조회하면 항상 같은 객체가 나온다.
- 다른 영속성 컨텍스트에서는 다음 특징이 존재한다.
  - == 비교에 실패한다.
  - 따라서 식별자 값이나 동등성 비교(`equals()`)를 진행해야 한다.
  - 하지만 식별자는 영속 상태일 때만 가능하고, 비즈니스 키를 사용한 동등성 비교가 주로 권장된다.
#### 쓰기 지연
- 트랜잭션이 커밋될 때까지 쿼리를 보내지 않고 한번에 보낼 수 있다.
- 등록 쿼리는 한번에 보냄으로써 성능을 최적화 할 수 있다.
#### 변경 감지(더티 체킹)
- 영속 상테의 엔티티의 값을 변경하면 쿼리가 날라간다.
- 원래 값과 커밋 시점의 값을 비교하여 update 쿼리를 날린다.
#### 지연 로딩
- 엔티티와 관계가 맺어진 엔티티를 조회할 때 사용 시점에 쿼리를 날려 가져온다.
## 참조
- https://incheol-jung.gitbook.io/docs/q-and-a/spring/persistence-context
</details>

<details>
    <summary><b>OSIV</b></summary>

## 정리
### OSIV 란?
- Open Session in View 의 약자로 영속성 컨텍스트를 뷰까지 열여둔다는 의미이다.
- 뷰 영역(Controller 포함)까지 열리면 여기서도 지연 로딩을 사용할 수 있다.
### 단점
- 같은 영속성 컨텍스트를 여러 트랜잭션이 공유할 수 있다.
- 프레젠테이션 계층에서 엔티티를 수정하고 트랜잭션으로 들어오면 엔티티가 수정된다.
- 프레젠테이션 계층에서 지연로딩에 의한 SQL 이 실행되기 때문에 성능 튜닝 시 확인할 부분이 늘어난다.
### 대안
- Facade
  - 파사드 계층을 초기화해서 준영속 상태가 되기 전에 프록시를 초기화한다.
- DTO
  - DTO 로 변환하여 반환한다.
## 참조
- https://incheol-jung.gitbook.io/docs/q-and-a/spring/osiv
</details>

---

<details>
    <summary><b>즉시/지연 로딩</b></summary>

## 정리
### 즉시 로딩과 지연 로징이란?
- 즉시 로징
  - 엔티티를 조회할 때 연관된 엔티티도 같이 조회하는 것
  - `@ManyToOne(fetch = FetchType.EAGER)`
  - 어플리케이션에서 연관된 엔티티를 같이 사용하는 빈도가 높은 경우 유리 
- 지연 로딩
  - 실제 엔티티가 사용될 때 조회하는 것
  - `@ManyToOne(fetch = FetchType.LAZY)`
  - 대부분의 경우 한번에 많은 데이터가 로딩되는 것을 막기 위해 지연 로딩을 사용하고, 이를 최적화하는 경우에 페치 방식을 변경한다.
### 즉시 로딩과 조인
- 하이버네이트에서는 즉시 로딩을 구현하기 위해 조인을 사용한다.
- 이 때 해당 객체가 nullable 하면 외부 조인이 발생한다.
  - 성능상으로 내부 조인에 비해 떨어진다.
- 내부 조인을 위해서는 `@JoinColumn`의 nullable 속성이나 `@ManyToOne`의 optional 속성을 이용하여 NULL 을 허용하지 않는다고 알려줘야 한다.
### 즉시 로딩 주의할 점
- 컬렉션을 하나 이상 로딩하는 것은 권장하지 않는다.
  - 서로 다른 컬렉션을 로딩하기 위해서는 일대다 조인을 하게 되는데, 이 경우 N*M 개의 데이터가 한번에 로딩되어 어플리케이션의 성능이 저하될 수 있다.
- 컬렉션의 즉시 로딩은 항상 외부 조인을 사용한다.
  - 일대다 관계나 다대다 관계의 경우 NULL 이 아니라고 알려줘도 항상 외부 조인을 사용한다.
  - `@ManyToOne`, `@OneToOne` -> NOT NULL 이라고 알려주면 내부 조인 사용
  - `@OneToMany`, `@ManyToMany` -> NOT NULL 이라고 알려줘도 외부 조인 사용
## 참조

</details>

<details>
    <summary><b>프록시</b></summary>

## 정리
### JPA 에서 프록시란?
- 하이버네이트에서는 지연 로딩을 지원하기 위해 프록시 방식을 이용한다. (추가로 바이트 코드 수정 방식도 존재)
- `em.find()` -> 실제 객체 조회
- `em.getReference()` -> 프록시 객체 조회
### 특징
- 사용될 때 한번 초기화된다.
- 프록시 객체가 초기화된다고 해서 실체 객체로 바뀌는 것은 아니다.
- 영속성 컨텍스트에 이미 엔티티가 존재하면 `em.getReferece()`를 해도 실제 객체를 반환한다.
- 초기화는 영속성 컨텍스트의 도움을 받아야 가능하므로 준영속 상태의 프록시를 초기화하면 `org.hibernate.LazyInitializationException`을 발생시킨다.
### 프록시 객체는 식별자를 들고있다.
- 프록시 객체는 식별자 값을 보관한다.
  - `@Access(AccessType.PROPERTY)` 인 경우 해당 객체의 아이디를 조회해도 초기화되지 않는다.
  - `@Access(AccessType.FIELD)` 인 경우에는 초기화된다.
- 따라서 연관관계를 설정할 때 초기화를 하지 않는다.
```java
class Example {
	public void test() {
      Member member = em.find(Member.class, "member1");
      Team team = em.getReferece(Team.class, "team1");
      member.setTeam(team);
	  // -> 해당 경우에 Team 을 초기화하는 쿼리가 발생하지 않는다.
    }
}
```
### 컬렉션 객체는 어떻게 프록시 처리를 할까?
- 컬렉션 객체는 하이버네이트에서 컬렉션 래퍼라는 것을 지원하여 이를 관리한다.
  - PersistentBag
- 컬렉션 래퍼를 통해 지연 로딩을 처리한다.
- 단순 컬렉션을 호출하면 초기화되지 않는다.
  - 실제 데이터를 사용했을 때 호출된다.
  - `member.getOrders()` -> 초기화 안됨
  - `member.getOrders().get(0)` -> 초기화됨 
### 영속성 컨텍스트는 프록시 객체와 엔티티의 동일성을 보장할까?
- `em.getReference()` 를 통해 조회한 프록시 객체와 `em.find()` 를 통해 조회한 실제 객체는 동일성을 보장할까?
- 이 경우, 동일성을 보장하지는 않는다. 
  - 이를 영속성 컨텍스트는 프록시로 조회된 엔티티에 대해서 같은 엔티티에 대해 조회 요청이 들어오면, 프록시 객체를 반환하고 있다.
  - 이를 통해 동일성을 보장하고 있다.
- 물론, 실제 객체를 조회한 후 프록시 객체를 조회하면 실제 객체가 반환된다.
  - 영속성 컨텍스트에 로딩이 되었기 때문
> 타입 비교의 경우 `==` 를 사용하지 못하고 'instanceof' 를 사용해야 한다.
### 프록시 객체와 실제 객체의 동등성 비교는?
- Intellij 같은 IDE 를 통해 equals() 를 재정의 할 경우 주의해야 할 점이 존재한다.
- 해당 자동 완성에서 `if (this.getClass() != obj.getClass()) return false;` 부분이 있다면 프록시 객체와의 동등성 비교에 실패한다.
  - 이를 해결하기 위해 `instanceof` 메서드 이용
- 또한 만약 `member.name` 이런 식으로 직접 참조가 되어있다면 프록시 객체에서는 접근 지정자에 의해 불러오지 못할 수도 있다.
  - 이를 해결하기 위해 getter 를 이용
## 참조

</details>

<details>
    <summary><b>N + 1 문제</b></summary>

## 정리
### N+1 문제란?
- 연관 관계가 설정된 엔티티를 조회할 경우 조죄한 데이터의 수만큼 연관된 엔티티가 추가로 조회되는 것
### 즉시 로딩과 N+1
- `em.find()` 를 할 때는 문제가 발생하지 않지만, `JPQL` 을 통해 엔티티를 조회할 때 N+1 문제가 발생한다.
- 엔티티를 가져오고 연관된 엔티티 컬렉션에 값을 채우기 위해 쿼리가 추가로 발생한다.
### 지연 로딩과 N+1
- 지연 로딩에서는 `JPQL` 을 사용할 때 문제가 발생하지는 않는다.
- 하지만 연관된 엔티티를 초기화 하는 과정에서 쿼리가 발생하기 때문에 엔티티를 순회하면서 연관된 엔티티를 호출하는 경우 쿼리가 발생한다.
```java
class Example {
	public void test() {
      // 지연 로딩도 N+1 를 해결할 수 없다.
      for (Member member : members) {
        System.out.println(member.getOrders().get(0)); // 조회 쿼리 발생
      }
    }
}
```
### 해결 방법
#### 페치 조인 사용
- 페치 조인을 이용하여 연관된 엔티티들을 한번에 가져와 N+1 문제를 해결할 수 있다.
- 일대다 조인의 경우 중복이 발생할 수 있기 때문에 `DISTINCT` 를 사용하는 것이 좋다.
- 단점
  - 페치 전략을 짜놓은게 의미가 없어진다.
  - 페이징 처리를 하지 못한다.
#### `@BatchSize`
- 하이버네이에서 제공하는 어노테이션으로 조회할 때 속성으로 지정한 size 만큼 SQL 의 IN 절을 사용하여 조회한다.
- 예를 들어 10건의 데이터가 연관되어 있고 size 를 5로 한다면, 쿼리가 총 2번만 추가로 발생한다.
  - 1번째 데이터 접근 시 1번, 6번째 데이터 접근 시 1번 -> 2번
#### `@Fetch(FetchMode.SUBSELECT)`
- 하이버네이트에서 제공하는 어노테이션으로 연관된 데이터를 조회할 때 서브 쿼리를 사용하여 조회한다.
- 즉시 로딩의 경우 엔티티 조회 시점에, 지연 로딩의 경우 엔티티와 연관된 엔티티가 실제 사용될 때 쿼리가 발생한다.
```mysql
SELECT O 
FROM ORDERS O
WHERE O.MEMBER_ID IN (
    SELECT M.ID
    FROM MEMBER M 
    WHERE #조건
  )
```
#### `@EntityGraph`
- Spring Data JPA 에서는 해당 어노테이션을 통해 Fetch Join 을 지원한다.
  - 해당 방식에서도 중복 값이 나올 수 있어 주의해야 한다.
- JPQL 을 작성하지 않고 페치 조인을 할 수 있다.
```java
interface ExampleRepository extends JpaRepository<Member, Long> {
	
	@EntityGraph(attributePaths = "team")
	List<Member> findAllEntityGraph();
}
```
## 참조

</details>

---

<details>
    <summary><b>단뱡향/양방향 매핑</b></summary>

## 정리
### 단방향
- 객체의 참조가 한쪽만 되어 있는 것
#### 일대다 단방향
- 이 경우 외래키를 다른 테이블에 있으므로 연관 관계 처리를 위해 UPDATE 쿼리가 추가로 필요하다.
#### 일대일 단방향
- 이 경우 연관관계의 주인을 설정해야 한다.
- JPA 에서 연관관계의 대상 테이블은 연관관계의 주인이 될 수 없다. 
### 양방향
- 객체의 참조가 양쪽 모두 되어 있는 것
- 연관관계의 주인
  - 테이블의 외래키를 가지고 있는 객체가 연관관계의 주인이다.
  - 주인만이 등록, 수정, 삭제할 수 있다. 주인이 아닌 쪽에서는 조회만 가능한다.
  - 일다다, 다대일의 관계에서는 다 쪽이 외래키를 가져 연관관계의 주인이 된다.
#### 일대일 양방향
- 외래키가 없는 쪽은 지연 로딩으로 설정해도 즉시 로딩된다.
## 참조

</details>

<details>
    <summary><b>Join vs Fetch Join</b></summary>

## 정리
### Fetch Join 이란?
- 페치 조인은 성능 최적화를 위해 제공하는 기능이다.
- 연관된 객체가 함께 조회된다.
### 컬렉션 페치 조인
- 컬렉션의 데이터를 채우기 위해 조인 연산을 시행한다.
- 일대다 조인의 경우 중복된 값이 조회될 수 있다.
- `JPQL` `distinct` 를 붙여 해결할 수 있다.
  - SQL 에 중복을 제거할 뿐만 아니라 어플리케이션에서 한번 더 중복을 제거한다.
### 한계점
- 둘 이상의 컬렉션을 페치할 수 없다.
- 컬렉션을 페치 조인할 경우 페이징 처리를 할 수 없다.
### vs Join
- Fetch Join 을 사용하지 않고 Join 을 사용할 경우 연관된 엔티티가 조회되지 않는다.
## 참조

</details>

<details>
    <summary><b>고아객체</b></summary>

## 정리
### 영속성 전이
- 종류
  - ALL: 모두 적용
  - PERSIST: 영속
  - MERGE: 병합
  - REMOVE: 삭제
  - REFRESH: refresh
  - DETACH: detach
### 고아객체
- 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능
## 참조

</details>

---