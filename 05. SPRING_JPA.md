## JPA

<details>
    <summary><b>JDBC, Spring JDBC</b></summary>

## 정리
### JDBC 란?
- 자바의 데이터 액세스 기술의 기본이 되는 로우 레벨 API 이다.
- 표준 인터페이스를 제공하고 여러 DB 벤더가 해당 인터페이스를 구현한 드라이버를 제공한다.
- 문제점
  - 쿼리를 실행하기 위해 많은 코드를 작성해야 한다.
  - DB 에 따라 정보가 달라져, 일관성이 없는 체크 예외가 발생한다.
- 장점
  - 표준화된 방식으로 데이터 액세스를 할 수 있다.
  - 러닝 커브가 크지 않다.
#### 실행 과정
1. Connection 을 가져온다.
2. SQL 을 담은 Statement(또는 PreparedStatement) 를 만든다.
3. Statement 를 실행한다.
4. Result 를 받아 객체로 옮긴다.
5. Connection, Statement, ResultSet 등 사용하지 않는 리소스를 해제한다.
6. JDBC API 가 만드는 예외를 처리한다.
### Spring JDBC 란?
- JDBC 의 장점과 단순성은 유지하고 문제를 해결하여 편리하게 사용할 수 있게 만든 API
#### DB 접근 방법
- JdbcTemplate
  - 가장 클래식하고 기본인 접근 방식
- NamedParameterJdbcTemplate
  - `?` 로 파라미터를 매핑하는 것 대신 이름으로 매핑
  - 파라미터가 여러 개 있을 때 유리하다.
- SimpleJdbcInsert, SimpleJdbcCall
  - DB 가 제공해주는 메타 데이터를 이용하여 코드 작성을 최소화해준다.
  - 메타 데이터에서 컬럼 정보와 파라미터 정보를 가져와서 삽입용 SQL 과 프로시저를 호출하기 때문에 편리하다.
  - 메타데이터를 제공하지 않는 DB 에서는 사용할 수 없다.
#### 제공하는 편의 기능
- Connection 열기와 닫기: 트랜잭션과 연계되어 커넥션 관리를 해준다.
- Statement 준비와 닫기
- Statement 실행
- ResultSet Loop 처리
- Exception 처리와 반환: CheckedException 인 SQLException 을 DataAccessException 으로 변환한다.
- Transaction 처리
## 참조
- https://docs.spring.io/spring-framework/reference/data-access/jdbc/choose-style.html
</details>

<details>
    <summary><b>Connection Pool</b></summary>

## 정리
### Connection 이란?
- DB 를 사용하기 위해 DB 와 애플리케이션 간 통신을 할 수 있는 수단
### Connection Pool 이란?
- Connection 객체들을 모아둔 공간
- 사용자의 요청이 올 때마다 Connection 을 생성하고 끊는 작업은 매우 비효율적이므로 Connection Pool 을 사용한다.
## 참조

</details>

<details>
    <summary><b>DataSource</b></summary>

## 정리
### 
### DBCP
- WAS 가 실행되면서 일정량의 Connection 객체를 미리 만들어서 Pool 에 저장했다가, 클라이언트 요청이 오면 Connection 객체를 빌려주고 해당 객체의 임무가 완료되면 다시 Connection 객체를 반납받아서 Pool 에 저장하는 프로그래밍 기법
### 장점
- DB 접속 설정 객체를 미리 만들어 메모리에 등록하기 때문에 생성, 삭제 작업이 사라지므로 효율적이다.
- DB Connection 수를 제한할 수 있어 과도한 접속으로 인한 서버 자원 고갈 방지가 가능하다.
- DB 접속 모듈을 공통화하여 DB 서버 환경이 바뀔경우 대처가 쉽다.
### 고려할 점
- 동시 접속자가 많을 경우
  - Connection 은 한정되어 있으므로 사용할 수 있는 Connection 객체가 반납될 때까지 대기해야 한다.
  - 이를 위해 Connection 의 제한을 크게 잡으면 사용자의 대기 시간은 줄어들지만, 메모리 소모가 크고,
  - 작게 잡으면 대기 시간이 길어진다.
- Connection Pool 이 커지게 되면?
  - 하나의 Connection 은 하나의 Thread 가 담당한다. 따라서 Thread Pool 과 Connection Pool 의 크기를 적절히 조절해야 한다.
  - Thread Pool <<< Connection Pool 인 경우 (Connection Pool 만 크기 증가)
    - 놀게 되는 Connection 이 많아지므로 효율적인 메모리 사용이 아니다.
  - Thread Pool, Connection Pool 둘 다 크기 증가인 경우
    - 노는 Connection 이 많아져 Thread 를 추가하게 되면 다음의 문제가 발생할 수 있다.
    - Thread 증가로 인해 Context Switching 이 발생한다.
    - Disk 경합 측면에서 성능 한계가 발생한다.
      - DB 는 하드디스크 하나 당 하나의 I/O 를 처리하기 때문에 병목이 발생할 수 있다.
- 적당한 Connection Pool 의 크기는? (Hikari CP)
  - Hikari CP 위키를 보면 다음 공식을 제안한다.
  - `Pool Size = Tn * (Cm - 1) + 1`
  - Tn: 전체 Thread 갯수
  - Cm: 하나의 Task 에서 동시에 필요한 Connection 수
### Hikari CP 란?
- 스프링 부터 2.0 버전부터 기본으로 사용하는 DBCP 이다.
- 장점
  - 적은 메모리 사용량
  - 높은 처리량
  - 작은 코드 베이스
  - 풍부한 구성 옵션
  - 스레드 안정성
- 설정 옵션
  - minimum-idle: Connection Pool 에 유지 가능한 최소 커넥션 개수
  - maximum-pool-size: Connection Pool 에 유지 가능한 최대 커넥션 개수
  - idle-timeout: Connection 이 Pool 에서 유휴상태(사용하지 않는 상태)로 남을 수 있는 최대 시간
  - pool-name: Connection Pool 이름
  - max-lifetime: Connection 의 최대 유지 가능 시간
  - connection-timeout: Pool 에서 Connection 을 구할 때 대기시간, 대기시간안에 구하지 못하면 Exception
  - connection-test-query: Connection 이 잘 되었는지 확인하는 TEST SQL
## 참조
- https://techblog.woowahan.com/2663/
- https://steady-coding.tistory.com/564
- https://dkswnkk.tistory.com/685
</details>

---

<details>
    <summary><b>Sql Mapper(MyBatis)</b></summary>

## 정리
### SQL Mapper 란?
- 객체와 관계형 데이터베이스의 데이터를 개발자가 작성한 SQL 로 매핑시켜주는 프레임워크
### 장단점
- 장점
  - JDBC 를 사용하는 것에 비해 코드 작성이 간편하다.
  - XML 을 통해 관리하기 때문에 변경에 용이하고 유지보수가 편하다.
- 단점
  - DBMS 에 따라 SQL 문법이 다르기 때문에 이에 종속적이다.
  - SQL 을 직접 작성해야 한다.
  - 객체 모델과 관계 모델을 따로 관리해야 한다. 
## 참조

</details>

---

<details>
    <summary><b>JPA, Hibernate</b></summary>

## 정리
### JPA 이란?
- Java 진영의 ORM 기술 표준이다.
### 장단점
- 장점
  - 객체지향적으로 데이터를 관리할 수 있다.
  - 데이터베이스에 종속적이지 않다.
  - 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩 등으로 성능 상으로 이점이 존재한다.
  - 생산성과 유지보수가 뛰어나다.
- 단점
  - 복잡한 쿼리를 작성하기 힘들다.
  - 러닝커브가 존재한다.
  - 제대로 사용하지 못하면 성능이 오히려 떨어진다.
### Hibernate 란?
- JPA 의 구현체이다.
## 참조
- https://incheol-jung.gitbook.io/docs/study/jpa/2020-04-07-jpa-chap1
</details>

<details>
    <summary><b>ORM</b></summary>

## 정리
### ORM 이란?
- 객체와 관계형 데이터베이스를 매핑한다는 의미이다.
- 객체와 테이블을 매핑하여 패러다임 불일치를 개선한다.
## 참조
</details>

---

<details>
    <summary><b>영속성 컨텍스트</b></summary>

## 정리
### 영속성 컨텍스트란?
- 서버와 데이터베이스 사이에 엔티티를 저장하는 논리적인 영역
- 엔티티 매니저는 영속성 컨텍스트에 엔티티를 저장하고 관리한다.
### 엔티티 생명 주기
- 비영속
  - 영속성 컨텍스트와 관계가 없는 상태
  - 단순 생성만한 상태
- 영속
  - 영속성 컨텍스트에 저장된 상태
  - 영속성 컨텍스트에 관리되는 상태
- 준영속
  - 영속성 컨텍스트에 저장되었다가 분리된 상태
  - 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않은 상태
  - em.detach(), em.close(), em.clear()
- 삭제
  - 삭제된 상태
  - em.remove()
### 특징
- 식별자
  - 엔티티를 식별자 값을 이용하여 구분한다.
  - 영속 상태에서는 반드시 식별자 값이 존재해야 한다.
- 저장
  - 영속성 컨텍스트에 저장된 엔티티는 트랜잭션이 끝날 때 보통 저장된다.
  - 플러시라고 한다.
### 장점
#### 1차 캐시
- 엔티티를 조회할 때 1차 캐시에서 조회한다. 만약 없으면 데이터베이스에서 조회하여 1차 캐시로 가져온다. 
- 데이터베이스를 조회하지 않고 메모리에서 조회하기 때문에 성능상으로 이점이 있다.
- 2차 캐시: 어플리케이션 범위의 캐시로 어플리케이션이 종료될 때까지 유지된다. 
  - 동시성을 위해 캐싱한 객체를 복사해서 반환한다. (동일성을 보장하지 않는다.)
  - 하이버네이트에서 지원하는 2차 캐시
    - 엔티티 캐시: 엔티티 단위로 캐시. 식별자로 엔티티를 조회하거나 컬렉션이 아닌 연관된 엔티티 조회할 때 사용
    - 컬렉션 캐시: 엔티티와 연관된 컬렉션 캐시. 컬렉션이 엔티티를 담고 있는 경우, 식별자 값만 캐시
    - 쿼리 캐시: 쿼리와 파라미터 정보를 키로 사용해서 캐시. 결과가 엔티티일 경우, 식별자만 캐시
#### 동일성 보장
- == 연산이 가능하다.
- 식별자가 동일하게 엔티티를 조회하면 항상 같은 객체가 나온다.
- 다른 영속성 컨텍스트에서는 다음 특징이 존재한다.
  - == 비교에 실패한다.
  - 따라서 식별자 값이나 동등성 비교(`equals()`)를 진행해야 한다.
  - 하지만 식별자는 영속 상태일 때만 가능하고, 비즈니스 키를 사용한 동등성 비교가 주로 권장된다. 
#### 쓰기 지연
- 트랜잭션이 커밋될 때까지 쿼리를 보내지 않고 한번에 보낼 수 있다.
- 등록 쿼리는 한번에 보냄으로써 성능을 최적화 할 수 있다.
#### 변경 감지(더티 체킹)
- 영속 상테의 엔티티의 값을 변경하면 쿼리가 날라간다.
- 원래 값과 커밋 시점의 값을 비교하여 update 쿼리를 날린다.
#### 지연 로딩
- 엔티티와 관계가 맺어진 엔티티를 조회할 때 사용 시점에 쿼리를 날려 가져온다.
## 참조
- https://incheol-jung.gitbook.io/docs/q-and-a/spring/persistence-context
</details>

<details>
    <summary><b>OSIV</b></summary>

## 정리
### OSIV 란?
- Open Session in View 의 약자로 영속성 컨텍스트를 뷰까지 열여둔다는 의미이다.
- 뷰 영역(Controller 포함)까지 열리면 여기서도 지연 로딩을 사용할 수 있다.
### 단점
- 같은 영속성 컨텍스트를 여러 트랜잭션이 공유할 수 있다.
- 프레젠테이션 계층에서 엔티티를 수정하고 트랜잭션으로 들어오면 엔티티가 수정된다.
- 프레젠테이션 계층에서 지연로딩에 의한 SQL 이 실행되기 때문에 성능 튜닝 시 확인할 부분이 늘어난다.
### 대안
- Facade
  - 파사드 계층을 초기화해서 준영속 상태가 되기 전에 프록시를 초기화한다.
- DTO
  - DTO 로 변환하여 반환한다.
## 참조
- https://incheol-jung.gitbook.io/docs/q-and-a/spring/osiv
</details>

---