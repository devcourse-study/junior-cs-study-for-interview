<details>
    <summary><b>Java 의 장단점에 대해 설명해주세요.</b></summary>

## 장점

- 운영체제에 독립적이다.
    - JVM에 의해 자바로 작성된 프로그램을 어디서든 실행 가능하다.
- 객체지향 언어이다.
    - 다형성, 상속 등의 객체 지향 개념을 통해 재사용성, 확장성이 높은 코드 작성이 가능하다.
- 언어를 사용해온 시간이 길고 자료가 많다.
    - 많은 개발자들이 오랜 기간동안 개발에 사용한 언어인 만큼 찾아볼 수 있는 자료가 많고 커뮤니티가 활발하다.
    - 많은 오픈 소스가 만들어지면서 이를 통해 많은 사람들이 쉽고 빠르게 개발이 가능해졌다.
- 멀티스레드 구현이 쉽게 가능하다.
    - 많은 라이브러리를 통해 멀티스레드 구현이 쉽다.
    - 운영체제에 독립적이어서 더욱 쉽게 할 수 있다.

## 단점

- 속도가 비교적 느리다.
    - 한번의 컴파일로 기계어로 변환되는 C, C++과는 다르게 한번의 컴파일이 아닌, JVM이 해석하고 실행하는 과정이 필요하기 때문에 확실히 속도는 느리다.
    - JIT 컴파일러의 도입으로 C, C++의 속도와 거의 비슷하게 개선되었다.
- 예외 처리가 불편하다.
    - 예외를 개발자들이 **직접** 처리해줘야 한다. 이를 해주지 않으면 컴파일 에러가 발생하여 프로그램이 실행되지 않는다.
</details>

---

<details>
    <summary><b>Java 의 데이터 타입에 대해 설명해주세요.</b></summary>

# Java의 데이터 타입

### 기본 데이터 타입

| 타입 종류 | 이름      | 크기     |
|-------|---------|--------|
| 정수형   | byte    | 1 byte |
|       | short   | 2 byte |
|       | int     | 4 byte |
|       | long    | 8 byte |
| 실수형   | float   | 4 byte |
|       | double  | 8 byte |
| 논리형   | boolean | 1 byte |
| 문자형   | char    | 2 byte |
- 기본 데이터 타입은 메모리의 Stack 영역에 저장된다.
- 기본값이 존재하며 null 값을 가질 수 없다.
- 운영체제에 독립적인 언어이기 때문에 기본 타입의 크기가 운영체제에 따라 달라지지 않는다.
- 기본 데이터 타입의 크기를 벗어나는 값을 할당할 경우 컴파일 에러가 발생한다.

### 레퍼런스 타입

- 위의 8가지를 제외하고 모두 레퍼런스 타입이다.
- 보통 클래스, 인터페이스, 배열, Enum을 저장하기 위한 용도로 사용된다.
- Heap 영역에 값이 저장된 곳의 주소값을 Stack 영역에 저장한다.
- 기본값이 없고, 빈 객체라는 표현으로 null 값을 가질 수 있어 NullPointException이 발생할 수 있다.
</details>

<details>
    <summary><b>Wrapper 클래스와 Boxing, Unboxing 에 대해서 설명해주세요.</b></summary>

# Wrapper 클래스

기본 데이터 타입을 객체로 다루어야 하는 상황에 사용하기 위해 만들어진 것으로 Integer, Chracter 등 기본 데이터 타입의 객체 타입을 통칭하여 Wrapper 클래스라고 부른다.

Wrapper 클래스는 기본 데이터 타입과 다르게 연산에 사용되지 않으며 값을 생성하고 객체가 가진 값을 참조할 수만 있다.

## Boxing

- 기본 객체 타입을 Wrapper 클래스로 변환하는 과정을 말한다.

## Unboxing

- Wrapper 클래스를 기본 객체 타입으로 변환하는 과정을 말한다.

보통 위의 두가지 과정을 클래스의 static 메소드를 통해 수행했지만, JDK 1.5부터 Boxing과 Unboxing 과정을 자동으로 처리해준다. 이것을 통해 기존의 조회만 가능했던 점을 극복하여 연산에도 활용할 수 있게 되었다.
</details>

---

<details>
    <summary><b>Java는 Call by Value인가요 Call by Reference인가요?</b></summary>

# Call By Value vs Call By Reference

## Call By Value

- 메소드를 호출할 때 전달되는 인자에 값이 복사되어 전달된다.
- 메소드에 전달된 인자는 바깥의 변수와 **완전히 서로 다른 변수**로 존재한다.
- 따라서 메소드 내부에서 값이 변경되어도 외부의 변수에 전혀 영향을 주지 않는다.

## Call By Reference

- 메소드를 호출할 때 전달되는 인자에 레퍼런스가 담겨 전달된다.
- 메소드에 전달된 인자와 바깥의 변수가 같은 레퍼런스를 가리키게 된다.
- 따라서 메소드 내부에서 값이 변경되면 외부의 변수도 동일하게 변경 사항이 반영된다.

## Java는 무슨 방식을 사용하나요?

Java는 항상 Call By Value로 작동한다.

1. 원시 타입의 경우

    ```java
    public class PrimitiveClass {
    
    	public void sum(int a, int b){ // 동일한 이름이지만 PrimitiveClass의 멤버 변수와 완전히 다른 변수
    		a += b;
    	}
    
    	public static void main(String[] args){
    			int a = 1;
    			int b = 2;
    
    			sum(a, b);
    
    			System.out.println("a : " + a);
    			System.out.println("b : " + b);
    	}
    }
    ```

   **실행 결과**

    ```
    a : 1
    b : 2
    ```

2. 레퍼런스 타입의 경우

    ```java
    public class User{
    	String name;
    
    	public User(String name){
    		this.name = name;
    	}
    
    	public String getName(){
    		return this.name;
    	}
    }
    
    public class ReferenceClass {
    
    	public void changeUser(User a){ // 동일한 이름이지만 ReferenceClass의 멤버 변수와 완전히 다른 변수
    		a = new User("kim");
    	}
    
    	public static void main(String[] args){
    			User a = new User("lee");
    
    			changeUser(a);
    
    			System.out.println("a name : " + a);
    	}
    }
    ```

   **실행 결과**

    ```
    a name : lee
    ```

   **🤔  reference를 전달하는데 왜 call by value 인거지?**

   위에 주석으로 적어놓은 것과 동일하게 현재 `changeUser` 라는 메소드에 인자로 전달되는 `a` 라는 변수는 `ReferenceClass` 가 멤버로 가진 `a` 변수와 서로 다른 변수이다.

   `changeUser`가 사용하게 될 `a`라는 변수에 User 인스턴스의 **주소값**이 복사되어 들어가게 되고, lee 라는 이름을 가진 객체에 접근이 가능하게 된다.

   하지만 완전히 다른 변수이기 때문에 a에 완전히 다른 새로운 인스턴스가 할당되게 되면 더이상 changeUser에서는 ReferenceClass의 멤버 변수 a에 접근이 불가능하다. 왜냐하면 주소값이 사라져버렸기 때문이다.

   즉, 주소값을 복사해서 전달한 것이지 레퍼런스를 그대로 전달한 것이 아니기 때문에 메소드 내에서 값이 변경되어도 기존의 값이 변경되지 않고 나오게 되는 것이다.


따라서, 자바는 항상 Call By Value로 작동하는 것을 확인할 수 있다.
</details>

---

<details>
    <summary><b>Java 의 접근제어자는 어떤 것이 있나요?</b></summary> 

# Java의 접근 제어자

| 종류        | 설명                                                                            | 접근 가능 범위                   |
|-----------|-------------------------------------------------------------------------------|----------------------------|
| private   | 그 어떤 외부 클래스에서도 접근이 불가능하며 동일한 클래스 내에서만 접근 및 사용이 가능하다.                          | 동일한 클래스 내                  |
| public    | 어디서든 접근이 가능하다.                                                                | 모든 패키지                     |
| protected | 같은 패키지에 존재할 경우 접근이 가능하며, 다른 패키지에 있더라도 상속 받은 자식 클래스는 접근이 가능하다.                 | 같은 패키지 혹은 패키지에 상관 없이 상속 관계 |
| default   | 아무것도 지정하지 않을 경우에 해당되며 같은 패키지 내에 있는 경우에만 접근이 가능하다. 그래서 pakage-private이라고도 부른다. | 같은 패키지                     |
</details>

---

<details>
    <summary><b>클래스, 객체, 인스턴스를 비교해주세요.</b></summary> 

# 클래스

- 객체를 구현하기 위한 설계도 및 틀
- 연관된 변수와 메서드를 가진다.

# 객체

- 소프트웨어 세계에 구현해야할 대상이다.
- 소프트웨어 세계에 구현하고자 하는 대상의 컨셉으로 이를 구현해내기 위해 클래스로 설계도를 만드는 것이다.
  - 그래서 클래스의 인스턴스라고 부르기도 한다.
- oop의 관점으로 클래스 타입으로 선언되었을 때 객체라고 부른다.

# 인스턴스

- 클래스가 소프트웨어 세계에서 구체적으로 실체화 된 것을 말한다.
- 실제로 메모리에 할당된다.
- oop의 관점으로 객체가 메모리에 할당되어 실제 사용될때 인스턴스라고 한다.

# 객체 vs 인스턴스

- 사실 객체는 인스턴스를 포괄하는 개념이다.
- 소프트웨어 세계에 더욱 가까운 개념이 인스턴스이고, 실제 개념에 가까운 것이 객체라고 할 수 있다.
- 코드상으로는 클래스 타입을 사용하여 선언된 것을 객체라고 하며,  객체에 실제 구체적인 구현체가 생성되면 그것을 인스턴스라고 한다.
</details>

---

<details>
    <summary><b>static 키워드에 대해 설명해주세요.</b></summary> 

- 객체 생성 없이도 접근이 가능하도록 만든다.
- static 키워드를 가지면 클래스가 로드되는 시점에 메모리에 적재된다.
- 클래스 로드 시점에 메모리에 적재된 후에 프로그램이 종료될 때까지 유지된다.
- 프로그램이 종료되면서 메모리에서 해제된다.
- GC의 관리 대상에서 제외되기 때문에 무문별한 static 사용은 메모리 낭비를 가져올 수 있으니 신중히 고려해야한다.
</details>

<details>
    <summary><b>static 멤버와 non-static 멤버는 무슨 차이가 있나요?</b></summary> 

## static 멤버 vs non-static 멤버

### static 멤버

- 객체 생성 없이 접근이 가능하다.
- JVM의 Runtime Data Area 중 Method Area에 들어간다.
- 컴파일 시점에 메모리에 적재되어야 하므로 정적 바인딩에 해당한다.
- static 멤버는 클래스 내의 non-static 멤버를 참조 할 수 없다.
- 클래스 당 하나로 관리된다.

### non-static 멤버

- 객체를 인스턴스로 생성하고 인스턴스를 통해 접근이 가능하다.
- non-static 멤버는 static 멤버를 참조 할 수 있다.
- 런타임 시점에 동적으로 할당되기 때문에 동적 바인딩에 해당한다.
- 생성된 인스턴스 별로 heap 영역에 객체와 함께 생성된다.


> 🚨 **클래스의 인스턴스 메소드는 객체별로 생성되지 않는다.**
> 
> 인스턴스 메소드는 메모리에 한 번 할당되고, 각 생성된 객체들은 그 메소드가 어디에 있는지 알고 있는 상태로 존재한다. 객체가 메모리의 주소를 알고 있고, 인스턴스를 통해 메소드를 호출할 때 알고 있는 메모리 주소를 통해 메소드를 호출하게 된다.

</details>
<details>
    <summary><b>main 메서드는 왜 static 메서드인가요?</b></summary> 

JVM의 실행에서 가장 먼저 호출하는 것이 main 메소드이다. JVM은 클래스의 인스턴스가 생성되지 않은 상태에서 main 메소드를 찾는다.

**따라서 실행 시점에 메모리에 main 메소드가 적재되어 있기 위해서 main 메소드는 static으로 선언된다.**
</details>

<details>
    <summary><b>자바 프로그램 실행 시 static 이 붙은 변수는 어떻게 처리되나요?</b></summary>

클래스 로더에 의해 static 키워드를 인식하여 클래스 로드 시점에 메모리에 적재합니다. JVM의 Runtime Data Area 중 로드된 클래스들이 저장되는 곳인 Method Area에 static 변수도 같이 적재됩니다. 이때 적재된 static 변수는 클래스 별로 하나만 적재됩니다.
</details>

---

<details>
    <summary><b>오버로딩과 오버라이딩을 비교해주세요.</b></summary> 

## 오버로딩

- 동일한 클래스 내 혹은 상속 관계에서 이루어진다.
- 동일한 메소드 명을 가지면서 전달되는 인자의 타입이나 갯수가 달라야한다.
- 같은 기능을 하는 다른 메소드를 하나의 동일한 메소드로 사용 가능하다.
- 타입 정보가 결정되는 시점에 정적으로 바인딩된다. = 정적 바인딩

## 오버라이딩

- 상속 관계에서만 이루어진다. 동일한 클래스 내에서는 이루어질 수 없다.
- 동일한 메소드 명을 가지면서 전달되는 인자의 타입과 갯수도 동일해야 한다.
- 부모가 가진 기능을 재정의 할 수 있다.
- 상속을 통해 이루어지기 때문에 컴파일 시점에 타입이 결정되지 못하고 동적으로 할당된 객체를 통해 메소드를 호출하기 때문에 오버라이딩은 동적 바인딩이다.
</details>

---

<details>
    <summary><b>인터페이스와 추상클래스를 비교해주세요.</b></summary> 

# 인터페이스

## 인터페이스 정의

- interface 키워드를 사용하여 클래스처럼 선언된 형태이다.
- 상수와 추상 메소드를 가진다.
  - 추상 메소드의 public abstract 키워드는 생략될 수 있다.
  - 상수의 public static final 키워드는 생략될 수 있다.
- 인터페이스는 인스턴스화 할 수 없다.
  - implements 키워드를 사용하여 클래스로 구현하여 인스턴스로 만들 수 있다.
  - 인터페이스를 상속 받은 클래스는 모든 추상 메소드를 반드시 구현해야 한다.

## 인터페이스 목적

- 인터페이스는 추상화와 다형성을 실천할 수 있는 핵심 개념이다.
  - 인터페이스를 통해 기능을 명세할 수 있으며, 즉 기능을 추상화 할 수 있다.
  - 인터페이스를 활용하여 객체를 선언하고 인스턴스를 사용할 때 내부 구현을 고려하지 않고 사용이 가능하다.
- 인터페이스는 서로 연관이 없는 클래스더라도 같은 기능을 동작하도록 보장한다.
  - 상속 받은 서브 클래스가 구현해야 할 메소드들의 원형을 알려주어 서브 클래스들이 모두 동일한 동작을 할 수 있도록 한다.

## 인터페이스의 다중상속

- 인터페이스는 추상 메서드만 가지기 때문에 여러 인터페이스에서 동일한 메소드를 가지고 있어도 실질적인 구현은 구현체에서 하기 때문에 문제가 발생하지 않는다.

> 🚨 **클래스에서 다중상속이 안되는 이유는 ?**
>
> A와 B, C 클래스가 있다고 할 때, C 가 A, B 를 모두 동시에 상속 받았다고 가정하자.
그런데 A와 B에 동일한 형태를 가진 메소드가 있다고 할때, C에서 그 메소드를 사용하게 되면 A, B 어떤 클래스에 속한 메소드를 가져와야 하는지 알 수가 없기 때문에 클래스는 다중 상속이 불가능하다.


# 추상 클래스

## 추상클래스 정의

- abstract 키워드를 사용하여 클래스를 선언한 형태이다.
- 추상 메소드를 가질 수도 있고 가지지 않을 수도 있다.
  - 추상 메소드를 가진다면 반드시 클래스도 추상 클래스로 선언해야 한다.
- 추상 클래스는 인스턴스화 할 수 없다.
  - 아직 구현되지 않은 추상메소드를 갖고 있기 때문이다.
  - 상속을 통해 구현하여 서브 클래스로 인스턴스를 만들 수 있다.

## 추상 클래스의 목적

- 상속을 위한 부모클래스로 활용하기 위한 목적이 있다.
  - 여러 클래스의 공통 기능을  추상화하여 상속 받는 자식 클래스에게 구현의 책임을 위임한다.
- 보통 연관된 클래스 간의 상속 관계에서 기능 확장을 위해 사용된다.
  - 클래스 간의 기능 구현을 각 클래스에게 위임하여 기능을 확장할 수 있다.

## 추상 클래스의 단일 상속

- 추상 클래스는 추상 메소드외에 구현된 인스턴스 메소드도 가질 수 있다. 따라서 클래스의 상속 관계에서 이루어질 수 있는 충돌의 발생 가능성이 있기 때문에 추상 클래스도 다중 상속을 허용하지 않는다.

## 추상 클래스 vs 인터페이스

`공통점`

- 모두 자체만으로 인스턴스화 할 수 없다.
- 추상 메서드를 가질 수 있다.
- 상속을 통해 모든 추상 메서드를 구현해야 하는 강제성을 가진다.
- 모두 다형성을 실현할 수 있다.

`차이점`

- 추상 클래스는 기능을 추상화하여 관련있는 클래스들 간의 기능 확장을 위해 사용되는 반면, 인터페이스는 연관이 없는 클래스더라도 같은 기능을 가진 것을 보장하기 위해 사용된다.
- 추상 클래스는 다중 상속이 불가능 하지만 인터페이스는 다중 상속이 가능하다.
</details>

---

<details>
    <summary><b>Java의 Error, Exception 구조에 대해 설명해주세요.</b></summary> 

# Error

- 주로 자바 가상 머신에서 발생한다.
- Java.lang.Error 클래스의 서브 클래스들로 시스템에 무언가 비정상적인 상황이 발생한 경우에 사용된다.
- 애플리케이션 코드에서 처리할 수 없는 예외이다.
- 대표적으로 StackOverFlowError, OutOfMemoryError가 있다.

# Exception

- 시스템이 아닌 개발자가 작성한 애플리케이션 코드에 의해 발생하는 예외이다.
- java.lang.Exception 클래스의 서브 클래스들인데, Exception을 상속하느냐, RuntimeException을 상속하느냐에 따라 예외 처리 방식이 다르다.
- Exception을 상속 받은 서브 클래스들은 Check Exception 이라고 하며, try-catch, throws를 통해 반드시 예외를 처리해야 하는 강제성을 가진다.
- RuntimeException을 상속 받은 서브 클래스들은 UnChecked Exception 이라고 하며, RuntimeException이 명시적인 예외 처리를 강제하지 않기 때문에 Unchecked Exception은 예외처리가 강제되지 않는다.

</details>

<details>
    <summary><b>CheckedException 과 UncheckedException 은 무슨 차이인가요?</b></summary> 

- Exception을 상속 받은 서브 클래스들은 Check Exception 이라고 하며, try-catch, throws를 통해 반드시 예외를 처리해야 하는 강제성을 가진다.
- RuntimeException을 상속 받은 서브 클래스들은 UnChecked Exception 이라고 하며, RuntimeException이 명시적인 예외 처리를 강제하지 않기 때문에 Unchecked Exception은 예외처리가 강제되지 않는다.

</details>

<details>
    <summary><b>예외처리의 세 가지 방법을 설명해주세요.</b></summary> 

## 예외 복구

예외 상태를 파악한 후에 문제를 해결하여 정상을 돌려 놓는 것이다.

```java
public sendFile(String fileName) {
    File file;
    try {
      file = FileFindService.find(fileName);
    }
    catch (FileNotFoundException e){
      file = FileFindeService.find("defalut.png");
    }

    send(file);
}
```

자주 사용되지 않는 방법이라고 한다. 예외가 발생하면 복구할 수 있는 경우가 거의 없기 때문이다.

예를 들어 유니크해야 하는 이메일 값이 중복되어 SQLException이 계속 발생한다면 RuntimeException을 발생시키고 사용자에게 다시 입력을 유도하는 것이 현명하기 때문이다.

따라서 복구를 해야할 일이 생긴다면 아래 처럼 코드의 흐름으로 제어하는 것이 좋다.

```java
public void sendFile(String fileName){
    if(FileFindService.existed(filename)){ // 파일의 유무에 따라 행동 제어
        send(FileService.find(fileName);
    } else {
        send(FileService.find("default.png");
    }
}
```

## 예외 처리 회피

예외를 직접 담당하지 않고 호출한 쪽으로 던져 회피하는 방법이다.

무작정 예외를 회피하는 것은 무책임한 방법이며, 전달할 객체에게 예외를 반드시 알려야 하는 상황에 사용된다.

```java
public Object someMethod() throws IOException {
    ...
}
```

## 예외 전환

예외 처리 회피와 비슷하게 메소드 밖으로 예외를 던지지만, 적절한 예외로 전환해서 넘기는 방법이다.

보통 예외 처리를 위해 RuntimeException을 상속받은 적절한 예외처리 핸들러를 만들어 그 예외 클래스로 전환하여 던진다.

복구를 위해 Unchecked Exception을 이용하는 방법이다.

```java
public int divide(int num1, int num2){
    try {
        return num1 / num2;
    } catch (ArithemeticException e){
        throw new CalculateException("0으로 나눌 수 없음!");
    }
}

public class CalculateException extends RuntimeException {
    public CalculateException(String message){
        super(message);
    }
}
```
</details>

---

<details>
    <summary><b>final 키워드는 왜 사용할까요? 어떤 이점이 있을까요?</b></summary> 

final 키워드를 선언하게 되면 한번의 초기화 후에 변경할 수 없음을 나타낸다.

# final 선언시 무엇이 달라질까?

## 클래스

클래스 이름 앞에 사용되면 클래스를 **상속 받을 수 없음**을 지정한다.

### 가장 대표적인 final 클래스 = String


> ☁️ Immutable Object : 하나의 인스턴스로 복제하여 공유할 수 있다.


String 클래스는 final로 선언되어 상속이 불가능하다. String의 특성을 잘 생각해보면 이 이유를 알 수 있다.

String 클래스는 String Pool에서 하나의 인스턴스를 공유하는 형태로 사용된다. 즉, 문자열 별로 인스턴스가 만들어지지만 동일한 값을 가진 인스턴스는 생성되지 않고 복제되어 공유된다는 것이다. 그렇기 때문에 String은 불변객체로 만들어져 관리된다.

만약 이렇게 공유되는 String 클래스가 상속이 가능한 형태라면 어떨까? String 을 상속받은 Sub Class가 만들어지고, String pool에서는 String 클래스인지, String 클래스처럼 보이는 Sub Class인지 알기가 힘들다.

따라서 String은 불변 객체이면서 상속이 불가능한 final 클래스로 정의된 것이다.

이런 식으로, 상속을 통해서 확장이 되지 않았으면 하는 클래스에 대해 final 키워드를 사용할 수 있다.

## 메소드

메소드에 선언되면 **오버라이딩 할 수 없는 메소드**임을 선언한다.

만약 상속받은 클래스의 부모 클래스에 final 메소드가 존재하면 오버라이딩 할 수 없으며, 해당 메소드를 상속받아서 사용해야만 한다.

## 필드

필드에 선언되면 **상수**가 된다.

상수 필드는 한번 초기화되면 값을 변경할 수 없으며, public static 키워드와 함께 선언하면 어디서든 사용할 수 있는 전역 상수를 만들 수 있다.

### 기본 데이터타입에 사용

기본 데이터 타입에 사용시 해당 변수의 값 자체가 변하지 않도록 한다.

### 참조 타입에 사용

참조 타입에 사용시 해당 변수가 가진 주소값이 변하지 않도록 한다. 참조하고 있는 주소값에 해당하는 객체의 상태값은 강제할 수 없다.

# final 사용으로 얻는 이점

- 시스템을 통해 변하지 않고 통일성을 유지해야 하는 값이 바뀌지 않도록 강제할 수 있다.
- final 변수로 선언하여 변하지 않는 값을 일관성 있게 사용이 가능하며, 따로 상수를 선언해둘 경우 변경이 용이하다.
- 값이 변경되지 않기 때문에 컴파일러가 효율적으로 코드를 생산할 수 있게 된다.
- 메소드에 사용할 경우, 변경되면 안되는 메소드로 지정이 가능하다.
</details>


<details>
    <summary><b>final, finally, finalize 에 대해 설명해주세요</b></summary> 

## final

- 사용되는 곳에 따라 의미가 다르다.
- 클래스에 사용시 상속이 불가능한 클래스를 만들게 되고, 메소드에 쓰일 경우 오버라이딩이 불가능한 메소드를 만들게 되고, 필드에 사용시 한번의 초기화 이후에 변경이 불가능한 변수임을 의미하게 된다.

## finally

- try-catch 구문에서 try, catch 블록이 실행된 후 마지막에 반드시 실행해야 하는 로직이 있을 경우에 사용할 수 있는 선택적 블럭이다.
- try에서 자원을 사용하게 된 경우에 개발자가 직접 finally를 통해 자원을 해제시킬 때 주로 많이 사용된다.
    - 자원을 사용 후 해제하지 않으면 계속해서 자원이 열려있게 되면서 프로그램에 버그를 만들 수 있다.
- finally 코드로 매번 동일한 코드를 작성하게 되면 가독성을 해치기 때문에 java 7에서 AutoCloseable을 구현한 클래스에 한해 자동으로 자원을 해제하는 문법이 생겼다.

## finalize

- 이것은 메소드로, 가비지 컬렉터가 더 이상 참조가 존재하지 않는 객체를 발견하였을 때 메모리 낭비가 되지 않도록 객체를 삭제하기 위해 호출하는 메소드이다.
- 이 메소드는 Object 클래스 내에 구현되어 있는 메소드로 모든 객체가 가지고 있으며, 객체 삭제 시 추가적인 행위를 주고 싶을 때 오버라이딩 해서 사용도 가능하다.
    - 하지만 가비지 컬렉터가 언제 이 함수를 호출할 지 예상할 수 없기 때문에 중요한 로직은 이곳에 추가하지 않는 것이 좋다.
</details>

<details>
    <summary><b>final 키워드는 컴파일 과정에서 다르게 실행될까요?</b></summary> 

# final 은 컴파일에 어떻게 될까?

- final 값은 컴파일 시에 타입 검사와 접근자를 구분해내고, 문제가 없다면 변수에서 바로 값으로 변경된다. 즉, 변수명으로 작성해 두었던 것들이 모두 값으로 변경된다는 것이다.
- 바로 값으로 변경되기 때문에 변수에 대해 메모리를 할당할 필요가 없으며, 객체가 생성되지 않고 바인딩도 이루어지지 않는다.
</br>(하지만 사용자의 입력이나 난수를 통해 값이 결정되는 경우에는 메모리 공간이 할당되어 값이 초기화 된 후에 메모리에 저장된다. )
</details>

---

<details>
    <summary><b>제네릭에 대해 설명해주세요.</b></summary> 

# 정의

- 모든 종류의 타입을 다룰 수 있도록 일반화된 타입 매개 변수로 클래스나 메서드를 선언하는 기법이다.
- 클래스 내부에서 지정하는 것이 아닌 외부의 사용자에 의해 타입을 지정하는 것을 의미한다.
- 사용자는 필요에 의해 타입을 지정하게 된다.

# 사용방법

### 1. 클래스 및 인터페이스에 선언

```java
public class ClassName<T> { ... }
public interface InterfaceName<T> { ... }
```

- 위와 같이 선언할 수 있으며, 이렇게 선언된 클래스는 객체 생성시 타입을 반드시 지정해줘야 한다.

**주의사항 🔥**

- 제너릭의 타입으로는 참조타입과 사용자 정의 타입만 가능하며 기본 데이터 타입은 사용할 수 없다.
- 제너릭 클래스 내에서는 제너릭 클래스의 인스턴스 생성이 불가능하다.
- 제너릭은 하나가 아닌 두개도 받을 수 있다.

**사용하는 이유**

- 상황에 따라 필요로 되는 데이터 타입으로 클래스를 사용하고 싶은 경우에 사용할 수 있다.

### 2. 제너릭 메서드

```java
public <T> T genericMethodName(T o) { ... }
```

**주의사항 🔥**

- 만약 클래스가 이미 제너릭으로 선언되었더라도 다른 제너릭으로 따로 제너릭 메서드를 생성할 수 있다.

**지정된 클래스의 타입이 아닌 다른 제너릭으로 선언될 수 있는 이유**

클래스 인스턴스는 선언 시 new 생성자로 객체를 생성하고 <> 내부에 구체적인 타입을 전달하여 지정된다. 하지만 우리가 정적 메소드를 선언한다고 가정해보자.

클래스를 로딩하는 시점에 메모리에 정적 제너릭 메소드가 등록되어야 한다. (해당 클래스가 사용중이라면) 하지만 클래스와 동일한 제너릭으로 선언된 상태에서는 타입을 알 수가 없기 때문에 메모리에 등록할 수가 없다. 왜냐하면 new 생성자를 통해 객체의 인스턴스를 생성하지 않았기 때문에 타입이 전달되지 않은 상태이기 때문이다. 따라서 정적 메소드가 호출 시에 타입이 결정될 수 있도록 선언된 클래스와 전혀 다른 제너릭으로 선언되는 것이다.

같은 알파벳을 사용하여 선언한다 하더라도 그것은 같은 제너릭이 아닌 전혀 다른 제너릭으로 존재한다는 사실을 꼭 알고 넘어가야 한다.

### 3. 제한된 제너릭

위에서 소개한 방식은 아주 간단하고 일반적인 제너릭 사용방법이다.

제너릭을 사용하면서 특정 범위를 지정할 수 있는데 사용방법은 다음과 같다.

- <K **extends** T>
- <K **super** T>

**extends**

<K extends T> 는 K가 T이거나 또는 T의 자식인 타입이어야만 한다는 뜻이다. 즉, T를 상속받은 자식 클래스이거나 자기 자신만 타입으로 받을 수 있다는 말이다. 

예를 들어 `ClassName<K extends Number>`로 선언된 클래스가 존재하고 이것의 인스턴스를 생성한다고 할 때, K에 들어갈 수 있는 클래스들은 Number 객체를 상속 받은 Integer, Double 등등이 가능할 것이다. 하지만 Number를 상속받지 않은 String, Character 등의 클래스는 들어가지 못한다. (컴파일 에러가 발생한다.)

**super**

<K super T> 는 K가 T의 부모이거나 조상이어야 또는 자신만 타입이어야만 한다는 뜻이다. 즉, T가 K를 상속 받은 자식클래스이어야 한다는 말이다. 

예를 들어 ClassName<K super Fruit> 이라고 한다면 K는 Fruit이라는 클래스를 상속 받은 타입만을 가질 수 있으며, ClassName을 Fruit으로도 활용 할 수 있게 된다. 즉, `업 캐스팅`이 가능해진다. 더 예를 들어 K가 Fruit을 상속받은 Apple이라고 한다면 우리는 사과라는 필드가 아닌 과일이라는 필드를 가지고 활용해야 할 때도 분명히 존재할 것이다. (과일 목록만 뽑아오고 싶을 때 우리는 사과를 사과가 아닌 과일로 바라보고 싶을 것이다)

super와 extends에서 또 사용할 수 있는 것이 **와일드 카드**이다.

와일드 카드는 어떤 타입이든 상관이 없다는 것을 의미한다. 즉, 자바의 최상휘 클래스의 타입을 상속 받은 것을 받겠다는 것과 동일하다. ( == Object)

그리고 와일드 카드의 특이한 점은 위의 두가지 경우와 다르게 타입을 지정해도 타입 전달이 안된다는 특징이 있다. 따라서 지정된 타입이 없기 때문에 타입을 참조할 수가 없다.

### super와 와일드 카드

우리는 객체간의 비교를 하고 싶을 때가 있을 것이다. 제너릭으로 선언된 클래스를 비교하고 싶을 때는 어떻게 할까?

우리는 보통 객체 비교를 위해 Comparable을 상속받아 비교한다. 그러면 제너릭 클래스인 ClassName에서 Comparable을 구현해보자.

```java
public class ClassName<E extends Comparable<E>> { 
	E element;

	@Override
	public int compareTo(E o){ ... }
}
```

우리는 제너릭 타입을 가진 객체간에 비교를 하기 위해 가지고 있는 멤버들로 비교가 가능하도록 Comparable을 구현하도록 extends를 통해 강제할 수 있다.

즉, 여기서 E extends Comparable<E> 은 E가 Comparable을 반드시 구현해야 한다는 의미랑 동일하다. 왜냐하면 위에서 말했다싶이 extends는 제너릭 타입이 부모 클래스를 상속한 클래스만 올 수 있기 때문이다.

그러면 우리는 우리가 선언한 타입을 가진 클래스를 가지고 객체 간의 비교가 가능해진다. 자 여기서 이런 상황이 된다고 가정해보자.

```java
import java.util.*;

public class Generic {

  public static void main(String[] args){
    SaltClass<Student> saltClass = new SaltClass<>(new Student("name", 15));
  }
}

class SaltClass <E extends Comparable<E>> {
	E member;

  public SaltClass(E member) {
    this.member = member;
  }

  public E getMember(E requestMember){
    member.compareTo(requestMember);
    return this.member;
  }
}

class Person {
  String name;

  public Person(String name) {
    this.name = name;
  }
}

class Student extends Person implements Comparable<Person>{
  Integer age;

  public Student(String name, Integer age) {
    super(name);
    this.age = age;
  }

  @Override
  public int compareTo(Person o) {
    return 0;
  }
}
```

현재 상황은 Student 클래스가 Person을 상속 받은 상태이며 Student는 Comparable을 구현했지만 상위 클래스에 대한 기준으로 구현했다. 하지만 SaltClass는 E 타입을 가지며 E 타입은 Comparable<E>를 구현해야 한다고 정의하고 있다.

하지만 Student는 Comparable<Student>는 구현하지 않았으므로 컴파일 에러를 발생시킨다. 따라서 이런 경우에는 E extends Comparable<? super E>> 라고 표현하여 상위 클래스에 대해서도 구현할 수 있도록 하여, 해당 클래스가 업 캐스팅이 가능하도록 한다. 그러면 하위 클래스로 SaltClass를 선언해도 Person 즉, 상위 클래스에 구현이 되어 있으므로 Comparable<? super E> 에서 납득이 가능하다.

따라서 Student를 사용해서 정렬을 해도 Person을 사용해서 정렬을 해도 문제가 없게 되므로, Comparable<E>를 사용하는 것보다 훨씬 안정적이고 유연한 개발이 가능해진다.

**변경한 코드**

```java
import java.util.*;

public class Generic {

  public static void main(String[] args){
    SaltClass<Student> saltClass = new SaltClass<>(new Student("name", 15));
  }
}

class SaltClass <E extends Comparable<? super E>> { 
  E member;

  public SaltClass(E member) {
    this.member = member;
  }

  public E getMember(E requestMember){
    member.compareTo(requestMember);
    return this.member;
  }
}

class Person {
  String name;

  public Person(String name) {
    this.name = name;
  }
}

class Student extends Person implements Comparable<Person>{
  Integer age;

  public Student(String name, Integer age) {
    super(name);
    this.age = age;
  }

  @Override
  public int compareTo(Person o) {
    return 0;
  }
}

```

[레퍼런스](https://st-lab.tistory.com/153)
</details>

---

<details>
    <summary><b>리플렉션이 무엇이고, 언제 활용 가능한지 설명해주세요.</b></summary> 

# 정의

자바에서 이미 로딩이 완료된 클래스에서 또 다른 클래스를 동적으로 로딩하여 생성자, 멤버 필드, 그리고 멤버 메소드 등을 사용할 수 있도록 하는 기법이다.

# 사용하는 이유

- 실행 시간에 (런타임에) 다른 클래스를 동적으로 로딩하여 접근하고자 할 때 클래스의 구조, 멤버 필드, 메소드 정보를 가져오기 위해 사용한다.

⇒ 대표적으로 스프링 프레임워크, 하이버네이트, Jackson 라이브러리에서 사용된다.

# 사용 예시

Jackson 라이브러리의 ObjectMapper를 살펴보자.

### 직렬화

객체를 통해 json문자열을 만드는 과정이다.

이때 바로 리플렉션이 사용되는데, 우선 json 문자열을 만들기 위해서는 어떤 필드들이 객체에 존재하는지 알아야한다. 그리고 얻은 필드 정보를 통해서 값들을 가져와야 하는데 이때 클래스의 getter를 통해 가져온다. (이건 정해진 원칙)

Jackson 라이브러는 사용자가 이 라이브러리를 어떤 객체를 사용하여 적용하는지 알 길이 없다. getter를 사용하여 값을 넣을 수 있도록 라이브러리를 만들어 놓은 후에 런타임에 동적으로 json 문자열로 변경하고자 하는 클래스를 읽어와 클래스의 필드 정보와 getter 메소드를 찾는다. 바로 이것이 리플렉션에 해당되는 것이다.
</details>

<details>
    <summary><b>리플렉션의 장단점에 대해 설명해주세요.</b></summary> 

# 리플렉션을 사용하면 좋은 점

- 오브젝트의 이름을 사용하여 확장성 오브젝트들의 인스턴스를 만들어냄으로써 애플리케이션이 외부에서 사용자가 정의한 클래스들을 사용할 수 있게 하는 확장성을 가지고 있다.
- 디버깅과 테스트 도구에서 사용하여 클래스의 private 함수에도 접근이 가능하도록 한다.

# 리플렉션을 사용해서 나쁜 점

- 성능 오버헤드가 발생할 수 있다.
    - 당연히 리플렉션이 있는 것보다 없는 것이 속도가 훨씬 빠르기 때문에 성능에 아주 민감한 코드라면 리플랙션을 사용하지 않는 것이 좋다.
- 캡슐화를 저해시킨다.
    - 리플렉션 기능을 사용하면 private 메소드에도 접근할 수 있기 때문에 여러 부작용이 발생할 수도 있다.
    - 추상화를 깨트릴 수 있기 때문에 플랫폼 업그레이드시 동작이 변경될 수 있다는 우려가 있다.
</details>

---

<details>
    <summary><b>자바의 직렬화와 역직렬화에 대해 설명해주세요.</b></summary> 
</details>

---

<details>
    <summary><b>자바의 Synchronized 키워드를 설명해주세요.</b></summary> 
</details>

<details>
    <summary><b>동기화와 비동기화의 차이를 설명해주세요.</b></summary> 
</details>

<details>
    <summary><b>동시성 문제가 무엇인가요? 자바에서 동시성 문제를 해결할 수 있는 방법이 있을까요?</b></summary> 
</details>

---

<details>
    <summary><b>자바의 어노테이션에 대해 설명해주세요.</b></summary> 
</details>

