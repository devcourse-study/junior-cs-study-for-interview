<details>
    <summary><b>Java 의 장단점에 대해 설명해주세요.</b></summary> 

> 👉 자바의 장점은 JVM 위에서 프로그램이 실행되므로 운영체제에 독립적이고, 객체지향언어로써 기존 코드의 재사용이 편리하다는 장점이 있습니다. 또한 변경사항이 생기면 해당 클래스만 수정하면 되기 때문에, 유지 보수가 쉽고 빠릅니다. 단점으로는 C/C++ 같은 컴파일 언어 대비 비교적 실행속도가 느리다는 단점이 있습니다.  

- 장점
    - 운영체제에 독립적
        - JVM 위에서 동작하므로 플랫폼에 종속적이지 않음(운영체제가 달라져도 추가적인 작업 불필요)
    - 객체지향적인 언어
        - 기존 코드를 재사용 가능하고 모듈식 프로그램을 개발 가능
    - 동적 로딩을 지원
        - 애플리케이션 실행시점에 모든 객체가 생성되는 것이 아닌, 객체가 필요할 때 클래스를 동적으로 로딩
        - 변경사항이 생기면 해당 클래스만 수정하면 되기 때문에, 전체 애플리케이션 컴파일 불필요. 유지보수가 쉽고 빠름
- 단점
    - C/C++ 과 같은 컴파일 언어 대비 실행 속도가 비교적 느림
        - Java는 컴파일 후 바이트 코드가 생성되고 JVM에서 기계어로 번역되고 실행되는 과정을 거치므로 컴파일언어 대비 실행속도가 비교적 느림

</details>

---

<details>
    <summary><b>Java 의 데이터 타입에 대해 설명해주세요.</b></summary>

> 👉 자바의 자료형은 기본형과 참조형이 있습니다. 기본형 같은 경우 int, char 등 총 8개의 자료형이 있으며, 크기가 작고 고정적이므로 메모리의 스택 영역에 저장됩니다. 기본형을 제외한 나머지 자료형은 모두 참조형입니다. class, array, interface 등이 참조형에 해당하며 크기가 가변적이고 동적이므로, 동적으로 관리되는 메모리의 힙 영역에 저장됩니다.   

- 기본 데이터 타입
    - 기본형으로는 int, char, boolean 등이 있다.
        - 정수형: byte, short, int, long
        - 실수형: float, double
        - 논리형: boolean(true/false)
        - 문자형: char
    - 기본형은 크기가 작고 고정적이므로 메모리의 Stack 영역에 저장된다.
- 참조 데이터 타입
    - 기본형을 제외하고는 모두 참조형
    - new 키워드를 이용해 객체를 생성하고, 데이터가 생성된 주소를 참조하는 타입
        - String 과 배열은 new 키워드 없이 생성가능하지만 참조 데이터 타입이다.
    - 참조타입의 종류는 class, array, interface, Enumeration 등이 있음
    - 참조형 데이터는 크기가 가변적이고 동적이므로, 동적으로 관리되는 메모리의 Heap 영역에 저장됨
        - **_데이터는 Heap 영역에 저장되지만 메모리의 주소값은 Stack 영역에 저장된다._**
    - 데이터를 더 이상 참조하는 변수가 없을 때 가비지 컬렉션에 의해 삭제된다.

---

</details>

<details>
    <summary><b>Wrapper 클래스와 Boxing, Unboxing 에 대해서 설명해주세요.</b></summary>

> 👉 Wrapper 클래스란, 기본 자료형의 데이터를 객체로 포장해주는 클래스입니다. java.lang 패키지에 기본 자료형 8개와 매핑되는 래퍼 클래스가 있습니다. 산술 연산을 위해 정의된 클래스가 아니므로 인스턴스에 저장된 값이 불변이라는 특징이있습니다. 기본형 데이터를 참조형 데이터로 변환하는 것을 박싱, 참조형 데이터를 기본형 데이터로 변환하는 것을 언박싱이라고 합니다.

### Wrapper 클래스 
  - **기본 타입의 데이터를 객체로 포장해주는 클래스**
  - 기본 타입의 데이터를 객체로 취급해야하는 경우 사용한다.
    - 예) 매개변수로 객체를 요구할 때, 기본형 값이 아닌 개체로 저장해야할 때 등
  - java.lang 패키지에 기본 데이터 타입 8개와 매핑되는 Wrapper 클래스가 존재
  - Wrapper 클래스는 산술 연산을 위해 정의된 클래스가 아니므로, 인스턴스에 저장된 값을 변경할 수 없다.

### Boxing, Unboxing 

- Boxing 
  - **기본 타입의 데이터를 Wrapper 클래스의 인스턴스로 변환하는 과정**
- Unboxing
  - **Wrapper 클래스의 인스턴스에 저장된 값을 기본 타입의 변수에 할당하는 과정**

### AutoBoxing

- **JDK 1.5부터 박싱과 언박싱 과정이 자동으로 처리되는데 이를 autoboxing 이라 한다.**
- 오토박싱은 컴파일 시에 처리 코드가 자동으로 생성되어서 이루어진다.

```java
int n1 = 10; 
Integer obj1 = n1; // 오토박싱. Integer obj1 = Integer.valueOf(n1);
```

```java
Integer obj2 = Integer.valueOf("20");
int n2 = obj2; // 오토언박싱. int n2 = obj2.intValue(); 
```

- Wrapper 클래스와 기본 데이터의 연산도 가능하다. (Wrapper 클래스는 내부적으로 기본 데이터로 변경되어 처리되기 때문)
    ```java
    Integer obj3 = 30; // Integer obj3 = Integer.valueOf(30);
    int n3 = obj + 40; 
    ```

<br>

(참고) Java의 Wrapper class

기본 타입	| 래퍼 클래스
---|---
`byte`|`Byte`
`short`|`Short`
`int`|`Integer`
`long`|`Long`
`float`|`Float`
`double`|`Double`
`char`|`Character`
`boolean`|`Boolean`


</details>

---

<details>
    <summary><b>Java는 Call by Value인가요 Call by Reference인가요?</b></summary> 

<br /> 

> 👉 자바는 메서드 호출 시에 Call by Value 방식을 사용하고 있습니다. 데이터 타입이 기본형인 경우 원시값을 복사해서 인자로 전달하고, 참조형인 경우 주소값을 복사해서 인자로 전달합니다. 이 때문에 함수 안의 지역 변수가 변경되어도 외부 변수의 값은 변경되지 않는다는 특징이 있습니다.    

- Java 에서는 메서드를 호출 시 새롭게 지역 변수를 만들어서 값만 복사하고 할당하는 방식이므로, 항상 Call by Value 이다.
    - value 는 기본형 데이터 타입의 값 또는 객체의 주소값
    - 기본 자료형의 경우 변수의 값을 복사해서 인자로 전달
    - 참조 자료형의 경우 객체의 주소값을 복사해서 인자로 전달

---

- **Call by Value**
    - 함수 호출 시 ***인자로 전달되는 변수의 값을 복사하여 함수의 인자로 전달***하는 방식
        - 호출자의 변수와 수신자의 파라미터는 복사된 서로 다른 변수
    - 함수 안에서 지역변수가 변경되어도 외부 변수의 값은 변경되지 않는다.

- **Call By Reference**
    - 함수 호출 시 인자에 참조를 직접 전달하는 방식
        - **호출 쪽의 변수와 수신자의 파라미터는 완전히 동일한 변수**
    - 메서드 내에서 파라미터 변경 시 원본 변수도 변경

</details>

---

<details>
    <summary><b>Java 의 접근제어자는 어떤 것이 있나요?</b></summary> 

> 👉 접근 제어자는 클래스, 변수, 메서드 등 각 요소에 대한 접근 권한을 조절하는 방법입니다. 조건 없이 무조건 접근 가능한 public, 같은 패키지 내에 있거나 상속 받은 경우에만 접근 가능한 protected, 같은 패키지 내에서만 접근 가능한 default, 같은 클래스 내에서만 접근 가능한 private 이 있습니다. 

### 접근 제어자

- 접근 제어자
  - 개발할 때, 코드의 어떤 부분은 외부에서 사용할 수 있도록 공개하고 어떤 부분은 비공개로 해서 데이터를 보호해야함. 즉 `접근 제어자`는 각 요소에 접근 권한을 조절하는 방법
  - 클래스와 필드, 메서드 선언시 지정 가능 
- 접근 제어자 종류
  - `public` : 조건 없이 무조건 접근 가능
  - `protected` : 같은 패키지 내에 있거나 상속받은 경우에만 접근 가능
  - `default` : 같은 패키지 내에 있을 때만 접근 가능
  - `private` : 같은 클래스 내에서만 접근 가능

### 패키지 

- 패키지 
  - 클래스를 관리하는 방법이며, 물리적으로는 파일 시스템의 디렉터리를 의미
  - 애플리케이션을 개발할 때 클래스들을 분류하지 않으면 이름이 중복되거나, 어떤 클래스가 어떤 일을 하는지 혼동되는 일이 발생. 따라서 패키지가 필요.
  
</details>

---

<details>
    <summary><b>클래스, 객체, 인스턴스를 비교해주세요.</b></summary> 


 > 👉 객체는 소프트웨어 세계에 구현할 대상이고, 이를 구현하기 위한 설계도가 클래스입니다. 이 설계도에 따라 소프트웨어 세계에 구현된 실체가 인스턴스입니다.  


- 클래스
  - 객체를 만들어 내기 위한 `설계도`, 또는 `틀`
  - 연관관계가 있는 변수와 메서드의 집합 
- 객체
  - 소프트웨어 세계에 구현할 `대상`
  - OOP 관점에서 클래스의 타입으로 변수가 선언되었을 때를 `객체`라고한다.
  - 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖음 
- 인스턴스
  - 설계도를 바탕으로 소프트웨어 세계에 구현된 실체
  - 객체가 메모리에 할당되어 실제 사용될 때를 인스턴스라고 부른다.

```java
public class Animal { // 클래스
    ...
}

public class Main {
	
    public static void main(String[] args) {
	    
        Animal cat, dog; // 객체
        
        // 인스턴스화
        cat = new Animal(); // cat은 Animal 클래스의 '인스턴스'(객체를 메모리에 할당)
        dog = new Animal(); // dog은 Animal 클래스의 '인스턴스'(객체를 메모리에 할당)
    }
}
```

Q. 클래스 vs 객체

- 클래스는 설계도, 객체는 설계도를 따라 구현한 모든 대상을 의미

Q. 객체 vs 인스턴스

- 클래스의 타입으로 변수가 선언될 때를 객체, 객체가 메모리에 할당되어 실제 사용할 때를 인스턴스라고 한다.
- 객체는 현실세계에 가깝고, 인스턴스는 소프트웨어 세계에 가깝다. 

※ Reference
- http://cerulean85.tistory.com/149

</details>

---

<details>
    <summary><b>static 키워드에 대해 설명해주세요.</b></summary> 

> 👉 
> - 자바에서 static 키워드를 사용하는 것은 클래스가 로드될 때 메모리에 단 한 번만 할당되어 프로그램이 종료될 때 메모리에서 해제됨을 의미합니다. 단 가비지 컬렉션에 의해 직접적으로 관리되지 않으므로 시스템 퍼포먼스를 고려하여 사용할 필요가 있습니다.
> - static 은 변수나 메서드, 특정 코드블럭 앞에 선언할 수 있으며, 이 중 static 멤버는 클래스당 하나만 생성되며, 같은 클래스의 모든 인스턴스가 공유한다는 특징을 가집니다.

</details>

<details>
    <summary><b>static 멤버와 non-static 멤버는 무슨 차이가 있나요?</b></summary>

> 👉 `non-static` 멤버는 객체마다 별도로 존재하고 객체간 공유되지 않습니다. 객체가 생성될 때 같이 생성되고 삭제 시 같이 삭제됩니다. 반면에 `static` 멤버는 클래스 당 하나만 생성되고 같은 클래스의 모든 객체에 의해 공유됩니다. 클래스 로딩 시에 멤버가 생성되며, 프로그램 종료 시에 삭제됩니다.

- `non-static` 멤버
  - 공간적 특성
    - 멤버가 객체마다 별도로 존재
    - `인스턴스 멤버` 라고 부른다.
  - 시간적 특성
    - 객체와 생명 주기가 동일하다.
  - 공유의 특성
    - 객체 간 공유되지 않는다. 
    - 멤버는 객체 내에서 각각의 공간을 차지

- `static` 멤버
  - 공간적 특성
    - 멤버가 클래스당 하나만 생성된다.
    - `클래스 멤버`라고 부른다.
  - 시간적 특성
    - **_클래스 로딩 시에 멤버가 생성된다._**
    - 객체의 생성 여부와 상관없이 사용 가능.
    - 프로그램이 종료될 때 삭제된다.
  - 공유의 특성
    - 동일한 클래스의 모든 객체에 의해 공유된다.

_※ 클래스의 `멤버`란?_
- 속성을 표현하는 `필드`와 기능을 표현하는 `메서드`를 일컬어 '멤버'라고 한다. 

_※ 인스턴스의 메서드는 힙 메모리에 만들어지지 않는다._

- 메서드 코드는 실행 시작 시점에 클래스 로더에 의해 `코드 영역`에 만들어지고 이후 다시 메모리에 만들어지지 않는다.
- 인스턴스 메서드는 코드 영역에 생성된 내용을 사용한다.
- 인스턴스 변수만 힙 메모리에 생성된다. 

</details>

<details>
    <summary><b>main 메서드는 왜 static 메서드인가요?</b></summary> 

> 👉 static 멤버는 프로그램 시작 시 메모리에 로드되어 인스턴스를 생성하지 않고 사용이 가능합니다. JVM은 인스턴스를 생성하지 않은 채 클래스의 main 메서드를 호출해야하기 때문에 main 메서드는 static 이어야 합니다. 

- `static` 키워드
  - static 멤버는 클래스 로딩(프로그램 시작) 시에 메모리에 로드되므로, 인스턴스 생성없이 호출 가능하다.
- JVM 이 main 메서드를 실행하는 과정 
  - 컴파일을 실행하면 컴파일러가 .java 파일을 .class 바이트 코드로 변환
  - 클래스 로더가 .class 파일을 메모리 영역에 로드
  - 메모리의 Runtime Data Area 중 메서드 영역(=Class Area, Static Area)에 클래스 변수들이 저장되는 데, static 멤버도 여기에 포함
  - JVM은 메모리의 메서드 영역에 로드된 main()을 실행

</details>

<details>
    <summary><b>자바 프로그램 실행 시 static 이 붙은 변수는 어떻게 처리되나요?</b></summary>

> 👉 먼저 static 변수를 호출하게 되면 클래스로더가 해당 클래스를 메모리의 Runtime Data Area 에 로드합니다. 클래스가 로드되면서 static 변수는 코드 영역에 저장되고, 초기화 됩니다. 마지막으로 초기화가 완료된 후의 static 변수를 사용하게 됩니다. 

- static 변수 호출 
- 클래스 로더가 해당 클래스 파일을 가져와서 JVM의 메모리에 로드 (동적 로딩)
- 이 때 static 변수를 메모리의 Runtime Data Area의 코드 영역에 저장하고 초기화.
- static 변수 사용

📄 **Ref**

- [클래스는 언제 메모리에 로딩 & 초기화 되는가](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EC%96%B8%EC%A0%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90-%EB%A1%9C%EB%94%A9-%EC%B4%88%EA%B8%B0%ED%99%94-%EB%90%98%EB%8A%94%EA%B0%80-%E2%9D%93)

</details>

---

<details>
    <summary><b>오버로딩과 오버라이딩을 비교해주세요.</b></summary> 

> 👉 
> - 오버로딩을 메서드를 확장하기 위한 기능입니다. 메서드의 이름은 같지만 매개변수의 자료형이나 개수가 다른 경우가 오버로딩에 해당합니다. 
> - 오버라이딩은 기존의 메서드를 덮어쓰기 위해서 사용합니다. 부모 클래스의 메서드 시그니처만 가져와 기능을 재정의하는 것을 의미합니다.

- 오버로딩(Overloading)
  - 메서드의 이름은 같지만 매개변수의 자료형이나 개수가 다른 경우 
- 오버라이딩(Overriding) 
  - 부모 클래스의 메소드 시그니처를 복제해서 자식 클래스에서 새롭게 구현
  - 부모 클래스의 기능은 무시하고, 자식 클래스에서 덮어씀

</details>

---

<details>
    <summary><b>인터페이스와 추상클래스를 비교해주세요.</b></summary> 
</details>

---

<details>
    <summary><b>Java의 Error, Exception 구조에 대해 설명해주세요.</b></summary> 
<ul>
<li>CheckedException과 UncheckedException은 무슨 차이인가요?</li>
</ul>
</details>

<details>
    <summary><b>CheckedException 과 UncheckedException 은 무슨 차이인가요?</b></summary> 
</details>

