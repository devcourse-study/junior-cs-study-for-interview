<details>
    <summary><b>Java 의 장단점에 대해 설명해주세요.</b></summary>

> 먼저 자바의 장점에 대해서 설명해보겠습니다. 자바는 객체지향의 특징을 잘 살려서 개발할 수 있는 언어입니다.  
> 그리고 자바는 JVM 위에서 동작하기 때문에, 자바 프로그램은 운영체제에 관계 없이 실행할 수 있다는 장점이 있습니다.  
> 또한 자바의 가비지 컬렉터가 메모리를 자동으로 괸리해준다는 장점도 있습니다.  
> 자바의 단점으로는, 자바 코드가 실행되기 위해서는 바이트코드로 컴파일되고, 다시 한번 컴퓨터가 이해할 수 있는 기계어로 번역되어야 합니다.  
> 그렇기 때문에 속도가 느리다는 단점이 있습니다. 이 단점은 JIT 컴파일러와 같은 기술들로 많이 개선되었습니다.  
> 그리고 파이썬과 같은 언어에 비해 코드가 복잡하다는 단점도 있습니다.

- 장점
    - Java의 장점으로는 JVM에서 동작하기 때문에, 운영체제에 독립적이라는 점입니다.
    - Java는 객체지향의 특징을 잘 살려서 개발할 수 있는 언어입니다.
    - 또한 가비지 컬렉터에 의해 GC가 일어나서, 메모리 관리를 자동으로 해준다는 장점이 있습니다.<br>
- 단점
  - 단점으로는 바이트 코드로 컴파일되고, 이 바이트 코드가 다시 한번 컴퓨터가 이해할 수 있는 기계어로 번역되기 때문에, 수행속도가 비교적 느립니다.
  - 또한 python 과 같은 언어와 비교했을 때 코드가 다소 장황하다는 단점도 있습니다.

- 꼬리질문
  - JIT 컴파일러에 대해 설명해주실 수 있나요?
  - JIT 컴파일러의 어떤 점 때문에 앞서 말하신 단점이 개선된건지 설명해주실 수 있나요?
  - JVM 관련 질문
  - OOP 관련 질문
    - 자바가 객체지향의 특징을 잘 살렸다고 하셨는데, 예시를 하나 들어주실 수 있나요?
</details>

---

<details>
    <summary><b>Java 의 데이터 타입에 대해 설명해주세요.</b></summary>

> 자바의 데이터 타입에는 기본형 타입과 참조형 타입이 있습니다.  
> 기본형 타입은 정수형, 실수형, 문자, 논리 값을 직접 저장하는 타입을 말합니다.
> 참조형 타입은 기본형 타입을 제외한 나머지 타입으로, 힙 영역에 저장된 데이터의 주소가 변수에 저장된다는 특징이 있습니다.  
> 참조형 타입의 종류로는 클래스, 인터페이스, 열거형, 배열 등이 있습니다.

- Java 의 데이터 타입에는 primitive 타입과 reference 타입이 존재합니다. 
  - primitive 타입은 정수형, 실수형, 문자, 논리 값을 직접 저장하는 타입입니다.
  - reference 타입은 primitive 타입을 제외한 타입으로, reference 타입에는 힙 영역에 저장된 데이터의 메모리 주소를 저장합니다.
- 꼬리 질문
  - String은 기본형인가요, 참조형인가요?
</details>

<details>
    <summary><b>Wrapper 클래스와 Boxing, Unboxing 에 대해서 설명해주세요.</b></summary>

> 우선 래퍼 클래스는 기본형 타입을 객체로 감싼 클래스입니다. 프로그래밍을 하다 보면 객체 타입만을 받아야 하는 경우가 있는데, 기본형 타입을 객체 타입으로 취급해야 할 때 사용합니다.  
> 박싱은 기본형 타입을 래퍼 클래스로 감싸는 과정을 의미하고, 언박싱은 래퍼 클래스를 기본형 타입으로 꺼내는 과정을 의미합니다.

- 래퍼 클래스란 원시 타입의 데이터를 객체로 감싼 클래스입니다. 
  - 프로그래밍을 하다 보면 객체 타입만을 받을 수 있는 경우가 있는데, 원시 타입을 객체로 취급해야 할 때 사용합니다.
- 래퍼 클래스의 값을 변경할 수 없습니다. 값이 바뀌길 원한다면 새로운 값을 감싼 래퍼 클래스를 생성해야 합니다.
- 박싱은 원시 타입을 래퍼 클래스로 감싸는 과정을 의미하고, 언박싱은 래퍼 클래스를 기본형 데이터로 꺼내는 과정을 의미합니다.
- 꼬리질문
  - 오토박싱이라는 키워드에 대해 설명해주세요
  - JDK 1.5 부터는 박싱, 언박싱을 명시적으로 해주지 않아도 자동으로 해당 작업을 해주는 오토박싱, 오토언박싱이 가능합니다.
    - 오토박싱은 원시 타입의 데이터를 래퍼 클래스에 대입할 때 이루어집니다. 
    - 오토 언박싱은 래퍼 클래스의 값을 원시 타입으로 변환할 때 이루어집니다.
    - 오토박싱은 언뜻보면 원시 값을 편리하게 래퍼 클래스로 사용할 수 있어보이지만, 내부적으로는 객체 생성과 같은 비용이 나가는 동작이 포함되어있기 때문에, 의도하지 않은 오토박싱을 없애야 합니다.
</details>

---

<details>
    <summary><b>Java는 Call by Value인가요 Call by Reference인가요?</b></summary>

> 자바는 Call by Value입니다. 우선 기본형 타입을 전달할 때는 그 값을 복사해서 전달합니다.   
> 그리고 자바에서 래퍼런스 타입을 파라미터로 넘길 때, 레퍼런스 자체를 전달하는 것이 아니라 레퍼런스가 저장된 메모리 주소를 복사해서 전달합니다.  
> 그렇기 때문에, 메서드 내부에서 레퍼런스 타입의 파라미터를 재할당 한다고 해도, 메서드 밖의 원본에는 영향이 가지 않습니다.
> 이런 이유로, Call by Value입니다.

- Java는 모든 타입이 Call by Value로 동작합니다. 
  - C와 다르게 Java는 Reference Type을 전달할 때 레퍼런스 자체를 전달하는 것이 아니라, 레퍼런스가 저장된 메모리 주소를 복사해서 전달합니다.
  - 그렇기 때문에, 메서드 내부에서 reference type 파라미터에 객체를 재할당 한다고 해도, 원본에는 영향이 가지 않습니다.
</details>

---

<details>
    <summary><b>Java 의 접근제어자는 어떤 것이 있나요?</b></summary>

> Java의 접근 제어자에는 private, default, protected, public이 있습니다.  
> private은 멤버가 속한 클래스에서만 접근할 수 있게 하는 접근 제어자입니다.  
> default는 별다른 접근 제어자를 선언하지 않았을 때 적용되고, 클래스와 클래스가 속한 패키지 내부에서만 접근 가능합니다.  
> protected는 default 접근 제어자가 가능한 범위에 해당 클래스를 상속한 자식 클래스까지 접근을 허용합니다.  
> public은 프로젝트의 모든 클래스에서 접근 가능합니다.

- 접근 제어자란 클래스 멤버의 외부에서의 접근을 제어하는 키워드입니다. 
- 접근 제어자에는 private, default, protected, public 의 4가지가 존재합니다.
  - private 은 외부에서의 접근을 할 수 없도록 하는 접근 제어자입니다. 
  - default 접근 제어자는 Java에서 지원하는 기본 접근 제어자로, 별다른 접근 제어자를 선언하지 않으면 자동으로 default 접근 제어자가 적용됩니다. 같은 클래스 내부에서, 그리고 같은 패키지 내부의 다른 클래스에서 접근 가능합니다.
  - protected 은 default 접근 제어자의 적용 범위에서 상속받은 자식 클래스 까지 접근을 허용하는 접근제어자 입니다.
  - public 은 프로젝트 내부의 어디에서든 접근할 수 있는 접근 제어자입니다.
- 인터페이스의 메서드에 접근제어자를 붙여주지 않게 되면 접근 범위는 어떻게 되나요?
</details>

---

<details>
    <summary><b>클래스, 객체, 인스턴스를 비교해주세요.</b></summary> 

> 클래스란 서로 연관된 필드와 메서드로 이루어진 객체의 설계도라고 할 수 있습니다.  
> 객체는 클래스의 설계대로 구현될 대상을 의미합니다.  
> 인스턴스는 클래스를 통해서 구체화된 각각의 실체를 의미합니다.

- 클래스란 연관된 필드와 메서드로 이루어진 객체의 설계도라고 할 수 있습니다.
- 객체는 클래스의 설계대로 구현해야 할 대상을 의미합니다.
- 인스턴스는 클래스를 통해서 구체된화 각각의 실체를 의미합니다.
</details>

---

<details>
    <summary><b>static 키워드에 대해 설명해주세요.</b></summary> 

> static 멤버를 선언하면, 클래스가 로드되는 시점에 같이 초기화 되어서 인스턴스 생성 없이 사용할 수 있습니다.  
> 또한 static 멤버는 스태틱 영역에 생성되기 때문에, 모든 객체들이 공유할 수 있습니다. 그리고 처음 메모리에 할당되면 프로그램이 종료될 떄 까지 할당된 채로 존재합니다.

- 클래스에서 static 멤버를 선언하면, 해당 클래스가 Method 영역 메모리에 적재되는 시점에 같이 초기회되어 모든 객체가 공유할 수 있습니다.
- static 멤버는 처음 메모리에 적재되면 프로그램이 종료될 때 까지 할당된 채로 존재합니다.
</details>

<details>
    <summary><b>static 멤버와 non-static 멤버는 무슨 차이가 있나요?</b></summary>

> static 멤버는 클래스당 한번 생성됩니다. 그리고 Method 영역에 할당됩니다. 따라서 static 멤버는 인스턴스가 생성되지 않고도 사용할 수 있고, 모든 객체가 공유할 수 있습니다. 하지만 GC의 관리를 받을 수 없습니다.  
> non-static 멤버는 객체마다 각각 생성됩니다. 그리고 객체가 생성될 때 heap 영역에 할당됩니다. 객체가 사라지면 non-static 멤버도 함께 사라지고, GC의 관리를 받을 수 있습니다.

- 생성 시점
  - static 멤버는 클래스당 한번 생성됩니다. 
  - 하지만 non-static 멤버는 클래스의 인스턴스마다 생성됩니다. 
- 메모리 영역
  - static 멤버는 JVM 메모리의 Method 영역에 적재됩니다. 따라서 static 멤버는 인스턴스가 생성되기 전에도 사용할 수 있습니다. 대신 프로그램이 종료될 때 까지 존재합니다.
  - 하지만 non-static 멤버는 인스턴스화될 때 Heap 영역에 할당됩니다. 그래서 GC의 관리를 받을 수 있다는 장점이 있습니다. 객체가 사라지면 non static 멤버도 사라집니다.</p>
- 꼬리질문
  - 그럼 non-static 멤버는 메모리 공간의 어디에 저장되나요?
  - non-static inner 클래스와 static inner 클래스의 차이점은 무엇인가요?
    - non-static inner가 인스턴스화되기 위해서는 먼저 바깥 클래스를 인스턴스화되어야 하고, 이 과정에서 클래스 외부 참조가 생깁니다. 그렇기 때문에 외부 클래스가 더이상 사용되지 않아도 내부 클래스가 유지된다면 GC의 대상이 되지 않습니다  
    - static inner 클래스는 외부 참조가 없기 때문에, 내부 참조를 생성하기 위해 일회용으로 생성된 바깥 클래스는 GC의 대상이 되어 제거됩니다.
  - static 메서드는 오버라이딩될까요?
    - 되지 않습니다. static 메서드는 컴파일 시점에 어떤 타입의 메서드가 실행될지 정해집니다. 
    - 반면에 오버라이딩된 메서드는 런타임 시점에 어떤 타입의 메서드가 실행될 지 결정됩니다.
    - 메서드가 실행될 시점이 서로 다르기 때문에 static과 오버라이딩은 어울릴 수 없습니다.
</details>

<details>
    <summary><b>main 메서드는 왜 static 메서드인가요?</b></summary> 

> main 메서드는 프로그램의 시작점이기 때문에, main 메서드가 선언된 클래스가 인스턴스화되지 않고 실행되어야 합니다. 그렇기 때문에 main 메서드는 static이어야 합니다.

- main 메서드는 프로그램의 시작점입니다. main 메서드가 선언된 클래스가 인스턴스화되지 않고 실행되어야 하기 때문에 main 메서드는 static이어야 합니다.
</details>

<details>
    <summary><b>컴파일 시 static 이 붙은 변수는 어떻게 처리되나요?</b></summary>

> static 변수는 클래스 로딩 시점에 Method 영역에 초기화됩니다.

- static 변수는 클래스 로딩 시점에 Method 영역에 초기화됩니다.
</details>

---

<details>
    <summary><b>오버로딩과 오버라이딩을 비교해주세요.</b></summary> 

> 오버로딩은 메서드의 이름은 동일하지만, 파라미터의 종류와 개수를 다르게 하여 정의하는 방식입니다.  
> 그리고 오버라이딩은 부모 클래스 혹은 인터페이스의 메서드를 동일한 시그니처로 재정의하는 방식을 의미합니다.

- 오버로딩은 메서드의 이름은 동일하지만, 파라미터의 종류와 개수를 다르게 하여 정의하는 방식입니다.
- 그리고 오버라이딩은 부모 클래스 혹은 인터페이스의 시그니처가 동일한 메서드를 재정의하는 방식입니다.
  - 오버라이딩 한 메서드의 리턴 타입은 부모 클래스의 메서드 리턴 타입과 동일해야 하거나, 리턴 타입의 자식 클래스여야 합니다.
</details>

---

<details>
    <summary><b>인터페이스와 추상클래스를 비교해주세요.</b></summary> 

> 추상 클래스는 abstract 키워드가 붙은 클래스로, 추상 메서드가 있다면 상속 받은 클래스는 해당 메서드를 오버라이딩 해야합니다.  
> 추상 클래스는 공통되는 필드와 메서드들을 상위 클래스로 추상화하고, 하위 클래스에서 그 기능을 확장하고자 할 때 사용합니다.  
> 인터페이스는 interface 키워드로 생성할 수 있고, 상수와 추상 메서드, default 메서드 등을 가지고 있습니다.  
> 인터페이스는 인터페이스를 구현한 클래스들이 같은 동작을 한다는 것을 보장하기 위해 사용합니다. 다중 상속을 위해서 사용할 수도 있습니다.

- 추상 클래스
  - 추상클래스는 abstract 키워드가 붙은 클래스를 의미합니다.  
  - 추상 메서드가 없어도 추상 클래스로 만들 수 있지만, 추상 메서드가 있다면 반드시 추상 클래스로 선언해야 합니다.  
  - 추상 메서드의 목적은 인스턴스를 생성하기 위함이 아니라, 상속을 위한 부모 클래스로 활용하기 위합입니다.
  - 추상클래스는 클래스들이 공통 멤버(필드, 메서드)들이 많아서 공통점들을 상위 클래스로 추상화하고 싶을 때 사용합니다. 
- 인터페이스
  - 인터페이스는 interface 키워드로 생성하고, 상수와 추상 메서드, 혹은 default 메서드만을 가지고 있습니다.
  - 인터페이스는 구체 클래스가 같은 동작을 한다는 것을 보장하기 위해 사용합니다. 혹은 다중 상속을 하고 싶을 때 사용합니다.
- 꼬리 질문
  - 추상 메서드?
    - 추상 메서드에 final과 static 키워드를 붙일 수 있나요?
  - 어느 상황에 추상 클래스를 사용하고, 어느 상황에 인터페이스를 사용할 것 같나요?(본인 생각)
</details>

<details>
    <summary><b>클래스는 왜 다중 상속을 허용하지 않을까요?</b></summary> 

> 자바는 클래스의 다중 상속 시 생기는 다이아몬드 문제를 언어 차원에서 막기 위해 다중 상속을 허용하지 않습니다.  
> 여기에서 다이아몬드 문제란, 상속구조가 다이아몬드 형태로 이루어져 있을 때 어느 부모 쪽의 메서드를 호출해야할지 모호해지는 문제를 의미합니다.  
> 하지만, 인터페이스는 다중 상속을 지원합니다. 인터페이스의 추상 메서드는 구체화되어있지 않기 때문에, 다중 상속을 받아도 문제가 되지 않습니다.

- 자바는 클래스의 다중 상속 시 생기는 다이아몬드 문제를 언어적으로 막기 위해 다중 상속을 허용하지 않습니다.  
  - 다이아몬드 문제란, 상속구조가 다이아몬드 형태로 이루어져 있을 때 부모 클래스 두 곳에서 모두 동일한 메서드를 오버라이딩했다면, 어느 쪽 메서드를 호출해야 할지 몰라 충돌이 발생하는 문제입니다.  
  - 인터페이스는 다중 상속을 지원합니다. 상위 여러 인터페이스를 다중 상속받아도 상위 인터페이스의 메서드는 구체화가 되어있지 않기 때문에, 다이아몬드 문제가 발생하지 않습니다.
  - 다만 default 메서드로 이루어져 있을 경우에는, 인터페이스를 구현하는 쪽에서 상위 인터페이스의 메서드를 호출하는 식이 아니라, 직접 메서드를 구현해야 합니다.
</details>

---

<details>
    <summary><b>Java의 Error, Exception 구조에 대해 설명해주세요.</b></summary>

> 우선 Error와 Exception은 Throwable 클래스를 상속하고 있습니다.  
> Throwable 클래스를 상속받음으로써 에러와 예외는 발생한 오류 상황에 대한 메세지 관리와, 오류의 원인들을 연결해서 출력하는 기능을 갖습니다.  
> 에러와 예외는 오류의 심각도를 기준으로 각기 다르게 사용됩니다.  
> Error는 프로그래머가 대처하기 어려운, 심각한 오류를 의미합니다.  
> Exception은 프로그래머가 대처할 수 있고, 혹은 직접 발생시켜 프로그램의 흐름을 제어할 수 있는 오류를 의미합니다.

- 우선 Error와 Exception은 Throwable 를 상속받고 있습니다.  
- Throwable 클래스는 getMessage와 printStackTrace 메서드가 있습니다.
- 따라서 에러와 예외는 공통적으로 발생한 오류 상황에 대한 메세지를 관리하고, 오류의 원인들을 연결해서 출력하는 기능을 갖고 있습니다.

- 꼬리 질문
  - Error와 Exception의 차이는 뭘까요?
    - Error는 프로그래머가 대처하기 어려운 오류를 의미합니다. 대표적으로 StackOverFlow와 OutOfMemory 에러가 있습니다.  
    - Exception은 프로그래머가 대처할 수 있고, 혹은 직접 발생시켜 프로그램의 흐름을 제어할 수 있는 오류를 의미합니다. 대표적으로 NPE가 있습니다.   
     
</details>

<details>
    <summary><b>CheckedException 과 UncheckedException 은 무슨 차이인가요?</b></summary> 

> CheckedException은 컴파일 시점에 해당 예외를 catch하는지 확인합니다. 해당 예외를 잡지 않으면 컴파일 에러가 발생하기 때문에, 반드시 예외를 해결하도록 강제합니다.  
> CheckedException이 발생하면 트랜잭션을 rollback시키지 않고 commit합니다.  
> 그에 반해 UncheckedException은 해당 예외를 잡아서 처리해도 되고, 잡지 않아도 됩니다.  
> 개발자의 실수, 혹은 사용자의 실수에 의해 예외가 발생하는 경우 처리를 위임하는 방식으로 사용할 수 있습니다.  
> UnckeckedException이 발생하면 트랜잭션이 rollback됩니다.

- CheckedException은 컴파일 시점에 해당 예외를 catch하는지 확인합니다.
  - 해당 예외를 잡지 않으면 컴파일 에러가 발생하기 때문에, 반드시 예외를 해결하도록 강제합니다.
  - CheckedException이 발생하면 트랜잭션을 rollback 시키지 않고 commit합니다.
- UncheckedException은 컴파일 시점에 해당 예외를 체크하지 않습니다.
  - 해당 예외를 잡아서 처리해도 되고, 잡지 않아도 됩니다.
  - 개발자의 실수, 혹은 사용자의 실수에 의해 예외가 발생할 경우 처리를 위임하는 방식으로 사용할 수 있습니다.
  - UncheckedException이 발생하면 트랜잭션이 rollback됩니다.
- Exception과 트랜잭션 관련한 포스팅: https://sup2is.github.io/2021/03/04/java-exceptions-and-spring-transactional.html

- 꼬리 질문
  - 지원자님은 Checked와 Unchecked 중에 어떤 예외를 선호하시나요? 이유와 함께 설명해주세요 
</details>

<details>
    <summary><b>예외처리의 세 가지 방법을 설명해주세요.</b></summary>

> 첫 번째 방법은 예외를 복구하는 방법입니다. 예외가 발생하면 문제를 해결해서 정상적인 상태로 되돌려 놓는 방법으로, 예외가 발생해도 어플리케이션은 정상적으로 동작합니다.  
> 두 번째 방법은 예외를 회피하는 방법입니다. 예외를 처리하지 않고 호출한 쪽으로 예외를 전달하는 방식으로, 호출한 쪽에서 처리하는 것이 최선일 때 사용하는 것이 좋습니다.  
> 세 번째 방법은 예외를 전환하는 방법입니다. 예외를 처리하지 않지만 적절한 예외로 변환해서 던지는 방법입니다. 좀 더 명확한 의미로 예외를 발생시키기 위한 방법입니다.
</details>

---

<details>
    <summary><b>final 키워드는 왜 사용할까요? 어떤 이점이 있을까요?</b></summary> 

> final 키워드를 사용함으로써 변경 가능성을 최소화할 수 있습니다.  
> final 키워드를 변수에 사용하면, 해당 변수는 상수가 되기 때문에 상태를 추적할 필요가 사라집니다.  
> 또한 final 키워드를 활용해 객체 자체를 불변으로 만든다면, 객체 역시 상태를 추적하지 않고 단순하게 사용할 수 있습니다.  
> 이를 통해 코드의 사이드이펙트를 줄이고, 디버깅 시 이점을 줄 수 있다고 생각합니다.

- final 키워드는 상태를 변경시킬 수 없게 만들기 위해 사용합니다.
  - final 변수를 선언할 경우, 한번 초기화된 경우 변수가 저장하는 값을 변경할 수 없습니다.
  - final 메서드를 선언할 경우, 하위 클래스가 해당 메서드를 오버라이딩 할 수 없습니다.
  - final 클래스를 선언할 경우, 해당 클래스는 상속 불가능한 클래스가 됩니다.
- 객체 세상에서 final을 사용하는 이유를 생각해보면, 변경 가능성을 최소화한다는 이점이 있습니다. 
  - final 키워드를 사용하면, 해당 변수는 상수로서 존재하기 때문에, 상태값을 추적할 필요가 사라집니다.
  - 이를 통해 코드의 사이드이펙트를 줄이고, 디버깅 시 이점을 줄 수 있다고 생각합니다.

- 꼬리 질문
  - 불변 객체의 장단점(이펙티브 자바 - 아이템 17)
</details>


<details>
    <summary><b>final, finally, finalize 에 대해 설명해주세요</b></summary> 

> final은 변수, 메서드, 클래스 등에 선언하여 변경되거나 오버라이딩, 상속될 수 없음을 명시하는 키워드입니다.
> finally는 try - catch 구문 동작 이후 꼭 실행되어야 할 동작을 작성하는 코드 구문입니다.
> finalize는 GC가 해당 객체가 더이상 참조되지 않는다고 판단할 때 호출하는 메서드입니다.

> finally 실행중에 예외가 
</details>

<details>
    <summary><b>final 키워드는 컴파일 과정에서 다르게 실행될까요?</b></summary> 

> final 변수를 참조하고 있는 java 파일이 컴파일 될 때 해당 참조를 상수로 변환하여 컴파일합니다.
</details>

---

<details>
    <summary><b>제네릭에 대해 설명해주세요.</b></summary>

> 제네릭은 타입 안정성을 높여주고 형변환의 번거로움을 줄여주는 기능입니다.   
> 제네릭이 있기 전에는 컬렉션에서 객체를 꺼낼 때 마다 형변환을 해주어야 했고, 잘못된 타입을 넣었다면 형변환 시 예외가 발생했습니다. 
> 하지만 제네릭을 사용하면 컬렉션이 담을 수 있는 타입을 컴파일러에게 알려줘서, 형변환 체크를 컴파일 시점에 할 수 있게 됩니다.

  ```java
  class NonGeneric{
    List numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
    int sum = 0;
    for (Object number : numbers) {
      sum += (int) number;
    }
  }
  
  class Generic{
    List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6); // 잘못된 타입이 들어왔다면 컴파일 시점에 이를 검사할 수 있음
    int sum = 0;
    for (Integer number : numbers) {
        sum += number; // 불필요한 형변환이 사라짐
    }
  }
  ```

- 꼬리 질문
  - 와일드카드에 대해서 설명해주세요
</details>

---

<details>
    <summary><b>리플렉션이 무엇이고, 언제 활용 가능한지 설명해주세요.</b></summary> 

> 리플렉션은 메모리에 올라와있는 클래스에 대한 정보들을 가져와 동적으로 인스턴스화하고 활용할 수 있도록 하는 API 입니다.  
> 리플렉션은 Class 객체를 통해서 생성자, 메서드, 필드, 어노테이션 등의 자세한 정보를 가져올 수 있습니다.  
> 뿐만 아니라 해당 클래스 정보를 통해 인스턴스화하고, 메서드를 실행하며, 필드의 값을 변경하는 등의 작업도 가능합니다.  
> 리플렉션은 컴파일 타임에는 어떤 클래스를 사용해야 할지 모르지만, 런타임 시점에서 특정 클래스를 사용해야 할 경우에 활용합니다.

- 리플렉션은 메모리에 올라와있는 클래스에 대한 정보들을 가져오는 기능입니다.  
- 리플렉션 API는 Class 인스턴스를 통해 사용할 수 있습니다. 클래스 객체를 통해서 생성자, 메서드, 필드, 어노테이션 등의 정보를 가져올 수 있습니다.  
- 단순히 정보를 가져오는 것 뿐만 아니라, 클래스의 인스턴스를 만들고, 메서드를 실행하며, 필드의 값을 변경할 수도 있습니다.  
- 그리고 클래스의 요소들이 private로 감춰져 있다고 해도, 해당 요소의 접근 가능 여부를 변경하여 직접 접근할 수도 있습니다.  
- 작성 시점에는 어떤 클래스를 사용해야 할지 모르지만, 런타임 시점에서 클래스를 사용해야 할 경우에 활용합니다.

- 꼬리 질문
  - Spring 에서 리플렉션이 사용되는 예시를 설명해주세요
  - Spring의 DI에서 리플렉션이 사용됩니다.
</details>

<details>
    <summary><b>리플렉션의 장단점에 대해 설명해주세요.</b></summary> 

> 리플렉션의 장점으로는, 클래스의 타입을 알지 못해도 런타임 시점에 동적으로 클래스를 인스턴스화하고 조작하는 등의 유연한 프로그래밍이 가능하다는 점입니다.  
> 이런 장점을 활용해서 프레임워크, 라이브러리, 디버깅 및 테스트 도구 등을 설계할 수 있습니다.  
> 리플렉션의 단점으로는, 런타임 시점에 클래스에 대한 정보를 가져오므로 성능 이슈가 있습니다.  
> 또한 private로 감쳐줘 있는 필드, 메서드들을 그대로 가져올 수 있으므로, 내부가 노출되면서 추상화가 깨지는 단점이 있습니다.

- 장점
  - 리플렉션은 클래스의 타입을 알지 못해도, 이를 런타임 시점에 동적으로 생성하고 조작하는 등의 유연한 프로그래밍이 가능합니다.  
    - 이런 장점을 활용하여 프레임워크, 라이브러리, 디버깅 및 테스트 도구 등을 설계합니다. 사용자가 어떤 클래스를 만들지 알 수 없기 때문입니다.  
- 단점
  - 런타임 시점에 클래스에 대한 정보를 가져오므로 성능 이슈가 있습니다.  
  - 또한 private로 감춰져 있는 필드, 메서드들을 그대로 갖고 올 수 있으므로, 내부가 노출되면서 추상화가 깨집니다.  
  - 이런 이유들로, 개발자를 위한 도구를 만드는 등 리플렉션을 사용해야만 하는 경우가 아니라면 사용하지 않는 것이 좋다고 생각합니다.
</details>

---

<details>
    <summary><b>자바의 직렬화와 역직렬화에 대해 설명해주세요.</b></summary> 

> 자바의 직렬화, 역직렬화 자바 시스템 내부에서 사용되는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 변환, 그리고 객체로 다시 변환하는 기술을 통틀어 의미합니다.  
> 직렬화를 하기 위해서는 직렬화하고자 하는 클래스가 Serializable 마커 인터페이스를 구현해야 합니다.  
> 역직렬화가 되기 위해서는 직렬화 대상인 클래스 파일이 class path에 존재해야 합니다. 그리고 동일한 serialVersionUID를 가지고 있어야 합니다.

- 자바의 직렬화와 역직렬화란 자바 시스템 내부에서 사용되는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 변환, 그리고 객체로 다시 변환하는 기술을 통틀어 의미합니다.  
- 직렬화를 하기 위해서는 직렬화하고자 하는 클래스가 Serializable 마커 인터페이스를 구현해야 합니다.  
- 역직렬화가 되기 위해서는 직렬화 대상인 클래스가 class path에 존재해야 합니다. 그리고 동일한 serialVersionUID를 가지고 있어야 합니다.  
- serialVersionUID의 경우, 별도로 선언하지 않으면 직렬화 과정에서 해시 값으로 설정됩니다. 이때 클래스의 버전이 변경된다면 해당 값도 바뀌기 때문에, 역직렬화 시 예외가 발생하게 됩니다.  
- 그래서 자바에서는 serialVersionUID을 직접 설정하고 관리하는 것을 추천합니다.  

- transient : 직렬 대상에서 제외하고자 하는 변수에 선언하는 키워드입니다.  
</details>

<details>
    <summary><b>자바의 직렬화는 언제, 어디서 사용되나요?</b></summary> 

> 자바의 직렬화는 메모리에 올라가 있는 데이터 그대로 영속화하고자 할 때, 혹은 데이터를 전송하고자 할 때 주로 사용됩니다.  
> 직렬화 기본 조건만 지키면 바로 직렬화/역직렬화가 가능하여 자바 시스템끼리는 전달받은 데이터를 객체로 바로 사용할 수 있기 때문입니다.  
> 실제로는 자바 시스템에서 캐시에 직렬화된 데이터를 저장하는 등으로 활용합니다.

- 자바의 직렬화는 자바 시스템에서 최적화되어있습니다. 직렬화 기본 조건만 지키면 바로 직렬화/역직렬화 할 수 있습니다. 자바 시스템에선 전달받은 데이터를 기존 객체로 바로 사용할 수 있습니다.  
- 그럻기 때문에, 자바의 직렬화는 JVM의 메모리에 올라가 있는 데이터 그대로 영속화하고자 할 때, 혹은 데이터를 전송하고자 할 때 주로 사용됩니다.  
- 실제로는 자바 시스템에서 캐시에 직렬화된 데이터를 저장하는 방식으로 사용된다고 합니다.
</details>

---

<details>
    <summary><b>자바의 Synchronized 키워드를 설명해주세요.</b></summary> 

> Synchronized 키워드는 자바에서 동기화를 위해 사용하는 키워드입니다.  
> 멀티 쓰레드 환경에서 여러 스레드가 동시에 공유 자원에 접근하려고 할 때 race condition이 발생할 수 있습니다.  
> 이를 방지하기 위해 자바는 Synchronized 키워드로 공유 자원에 대해 단 하나의 스레드만을 접근할 수 있게 하여 동기화를 수행합니다.

- Synchronized 키워드는 자바에서 동기화를 위해 사용하는 키워드입니다.  
- 멀티 쓰레드 환경에서 여러 스레드가 동시에 공유 자원에 접근하려고 할 때 race condition이 발생할 수 있습니다.  
- 이를 방지하기 위해 자바는 Synchronized 키워드로 공유 자원에 대해 단 하나의 스레드만을 접근할 수 있게 하여 동기화를 수행합니다.

- race condition이란?
  - race condition이란 공유 자원에 대해 둘 이상의 스레드가 동시에 접근하려고 하는 상태를 의미합니다.  
  - 여러 스레드가 접근하는 순서에 따라 공유 자원의 상태가 달라질 수 있는 상태입니다. 

- synchronized 키워드의 사용 유형과 각각의 차이
  1. synchronized 메서드
     - 자신이 포함된 인스턴스에 lock을 겁니다.  
     - 만약 같은 타입이지만 서로 다른 인스턴스인 경우 lock이 공유되지 않아 동기화가 발생하지 않습니다.  
     - 만약 synchronized 키워드가 두개 이상이라면, 해당 메서드가 실행된 인스턴스 내부의 모든 synchronized의 접근까지 lock이 걸리게 됩니다.  
  2. static synchronized 메서드
     - static의 성질이 그대로 적용되어, 클래스 단위로 lock이 걸립니다. non-static synchronized 메서드와 lock을 공유하지 않습니다.  
  3. synchronized block
     - 메서드 내부에 동기화가 필요한 부분에만 lock을 겁니다.  
     - synchronized block의 인자로 lock을 걸 대상을 받습니다.  
     - 하나의 인스턴스에서 서로 다른 lock을 갖도록 하려면, 각각의 block에 다른 객체를 인자로 전달해야 합니다.

- volatile : https://jeong-pro.tistory.com/227
- atomic
- 이펙티브 자바
</details>

<details>
    <summary><b>동기화와 비동기화의 차이를 설명해주세요.</b></summary> 

> 동기란 요청한 작업이 끝나기 전까지 다른 요청이 실행될 수 없고, 그 자리에서 결과가 주어져야 함을 의미합니다.  
> 비동기란 한 요청이 완료되었는지 여부와 상관없이 다음 요청을 실행할 수 있음을 의미합니다.
</details>

<details>
    <summary><b>동시성 문제가 무엇인가요? 자바에서 동시성 문제를 해결할 수 있는 방법이 있을까요?</b></summary>

> 동시성 문제란 공유 자원에 대해 여러 스레드가 동시에 접근할 때 발생하는 문제입니다.  
> 동시성 문제가 발생하기 전에 예방하는 방법은 객체를 불변 객체로 만드는 것입니다. 객체가 절대 변할 필요가 없으니 스레드에 안전해집니다.  
> 만약 불변 객체로 만들 수 없다면, synchronized 같은 키워드로 동시성 처리를 해줄 수 있습니다.  
> 혹은 concurrent 패키지의 클래스들을 활용하여 동시성을 해결할 수 있습니다.  
> 만약 스레드 사이에 간섭이 없어야 하는 데이터를 관리하고 싶으면 Thread Local을 이용합니다.

- 동시성 문제란 동일한 공유 자원에 대해 여러 스레드가 동시 접근할 때 발생하는 문제입니다.  
- 자바에서의 동시성 문제는 인스턴스 필드(heap) 혹은 정적 필드(static)에서 발생합니다.  
- 자바에서 동시성 문제를 해결하기 위해 우선 객체가 시간에 따라 변하는 상태를 갖을 필요가 있는지 분석하는 것입니다. 만약 그럴 필요가 없다면 불변 객체로 만들어 동시성 문제를 해결할 수 있습니다.  
- 만약 불변 객체로 만들 수 없다면, synchronized 같은 키워드로 동시성 처리를 해줄 수 있습니다.
- 혹은 concurrent 패키지의 클래스들을 활용하여 동시성을 해결할 수 있습니다.
- 만약 스레드 사이에 간섭이 없어야 하는 데이터를 관리하고 싶으면 Thread Local을 이용합니다.
</details>

<details>
    <summary><b>Thread Local에 대해 설명해주세요.</b></summary> 

> Thread Local이란 스레드 사이에 간섭 없이 데이터를 관리하게 해주는 Java의 기능입니다. 혹은 하나의 스레드 내부에서 파라미터 전달 없이 값을 공유하고 싶을 때 사용하는 기능입니다.  
> Thread Local 객체를 생성해 값을 setting해주고, 필요할 때 값을 꺼내는 식으로 사용할 수 있습니다.  
> 쓰레드 풀 환경에서 Thread Local을 사용할 경우 반드시 Thread Local에 저장된 값을 remove 해줘야 합니다.  
> 쓰레드 풀 환경에서는 쓰레드가 소멸되지 않기 때문에, 다른 요청에 의해 이전 요청의 데이터가 조회될 위험이 있기 때문입니다.

- 쓰레드 풀이 사용해본 경험이 있다면 말씀해주세요, 혹은 Spring에서 사용되는 기술을 아시나요?
  - Thread Local은 Spring Security에서 사용자의 인증 정보를 전파할 때 사용하고, 그 밖에 쓰레드 기준으로 동작해야 하는 기능을 구현할 때 사용합니다.

- 트랜잭션 매니저에서 Thread Local이 사용되는 과정에 대해 설명해주세요
</details>


---

<details>
    <summary><b>자바의 어노테이션에 대해 설명해주세요.</b></summary> 

> 어노테이션은 주석이라는 의미를 갖지만, 실제로는 컴파일 시점과 런타임 시점에 코드를 어떻게 처리해야 할 지 정보를 전달하는 기능을 합니다.  
> 자바에서 기본적으로 제공하는 어노테이션이 있고, 커스텀 어노테이션을 만들기 위해 제공하는 메타 어노테이션이 있습니다.  
> 커스텀 어노테이션을 만들어 원하는 로직의 흐름을 처리하고, 반복되는 코드를 줄일 수 있습니다.

- 커스텀 어노테이션을 만들기 위해 어떻게 해야하나요?  
  - 우선 @interface 키워드로 어노테이션 클래스를 선언하고, 클래스 선언부 위에 메타 어노테이션을 명시합니다.  
  - Retention 어노테이션으로 어노테이션의 유지기간을 정하고, Target 어노테이션으로 적용 대상을 정합니다.  
  - 몸통에는 어노테이션의 필드 타입을 정의할 수 있습니다. enum, String, 기본형, 기본형 배열만을 타입으로 가질 수 있습니다.  
  - 그 밖에 어노테이션을 상속할 수 있는지 여부, 동일한 어노테이션을 연속적으로 달 수 있는지 여부 등을 명시하는 어노테이션을 추가할 수 있습니다.  
  - 이렇게 어노테이션을 정의했다면, 이제 활용하고자 하는 코드에 어노테이션을 추가하여 컴파일, 런타임 시점에 원하는 동작을 처리를 해줄 수 있습니다.

- Spring에서 어노테이션을 활용해봤던 경험, 혹은 커스텀 어노테이션을 정의해봤던 경험이 있나요?  
  - ArgumentResolver 사용 경험
  - Controller, Service, Repositoroy, Component
</details>

---

<details>
    <summary><b>자바 8에 추가된 기능들에 대해 간단히 설명해주세요.</b></summary>

> Java 8에는 크게 람다, 스트림 API, Optional, default 메서드와 추가되었습니다.  
> 람다란 일종의 익명 함수로, 메서드에 전달할 수 있는, 간결한 표현식입니다.  
> 스트림이란 컬렉션에 저장된 데이터들을 선언형으로 처리할 수 있도록 함수들을 제공하는 API 입니다.  
> Optional이란 null이 올 수 있는 값을 감싸는 Wrapper 클래스입니다.   
> default 메서드란 구현체와의 하위호환성을 유지하면서 인터페이스에 기능을 추가할 수 있도록 해주는 메서드입니다.
</details>

<details>
    <summary><b>Stream에 대해 설명해주세요.</b></summary> 

> Stream이란 컬렉션에 저장된 데이터들을 선언형으로 처리할 수 있도록 함수들을 제공하는 API 입니다.  
> Stream의 특징으로는 컬렉션으로부터 스트림 객체를 생성하기 때문에, 원본 컬렉션 데이터를 변경하지 않는다는 점이 있습니다.  
> 또한 Stream은 일회용이기 때문에, 한번 사용이 완료된 Stream을 다시 사용하려고 하면 예외가 발생합니다.  
> Stream의 장점은 람다식을 활용하여 간결하게 데이터 처리 코드를 작성할 수 있다는 점입니다.  
> 그리고 parallel Stream, 혹은 parallel 메서드를 사용하는 것 만으로 여러 쓰레드를 이용하여 병렬 데이터 처리가 가능합니다.  

- Stream의 연산 종류에 대해 설명해주세요  
  - Stream의 연산은 생성, 가공, 결과 만들기의 순으로 진행됩니다.  
  - 생성하는 단계에서는 데이터를 기반으로 Stream 객체를 생성합니다.  
  - 가공하는 단계에서는 원본 데이터를 가공하는 중간 연산들이 진행됩니다. 중간 연산의 반환값은 Stream이기 때문에, 여러 중간 연산들을 체이닝할 수 있습니다.  
  - 결과 만들기 단계에서는 가공된 데이터로부터 원하는 결과물을 만드는 단계입니다.  
- 선언형의 의미가 뭔가요?  
  - 선언형이란 데이터 처리를 위해 직접 코드를 구현하는 것이 아니라 DB의 질의와 같이 선언만 하면 된다는 뜻을 의미합니다.  
- 컬렉션과 Stream 차이는 뭔가요?  
  - 컬렉션과 Stream의 가장 큰 차이는 데이터를 언제 계산하느냐입니다.  
  - 컬렉션은 계산된 결과가 저장되어있는 자료구조입니다. 따라서 요소를 컬렉션에 저장하기 전에 계산이 되어있어야 합니다.  
  - 반면 스트림은 요청할 때만 요소를 계산하는 고정된 자료구조입니다.  
  - 둘의 차이에는 내부 반복과 외부 반복도 있습니다.  
  - 컬렉션은 명시적으로 for문을 통해 외부 반복을 합니다. 하지만 스트림은 스트림 API에서 실질적인 반복이 구현되어있고, 사용하는 입장에서는 어떤 동작을 해야할지만 알려주면 됩니다.

</details>

<details>
    <summary><b>Stream과 반복문 for문의 성능차이가 있을까요?</b></summary>

> 조건에 따라 다릅니다.  
> 기본형 타입에 대한 간단한 데이터 처리를 하는 경우 for-loop이 컴파일러 수준에서 최적화가 잘 되어있기 때문에 스트림보다 성능이 좋습니다.  
> 하지만, 기본형이 아니라 참조형 타입을 사용하거나, 혹은 반복 동작 자체가 cost가 많이 드는 작업이라면 Stream이 더 좋은 성능을 냅니다.

- for문과 Stream.forEach()의 비교
</details>

<details>
    <summary><b>Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해주세요.</b></summary> 

> 함수형 인터페이스는 함수를 1급 객체처럼 다루기 위해 추가된 개념으로, 추상메서드가 하나뿐인 인터페이스를 의미합니다.  
> 람다식이 함수형 인터페이스를 반환하기 때문에, Stream API의 인자로 람다식을 전달하여 간결한 코드 작성이 가능합니다.  

- 함수형 프로그래밍이란?
</details>

<details>
    <summary><b>Lambda에 대해 설명해주세요.</b></summary>

> 람다란 일종의 익명 함수로, 메서드에 전달할 수 있는 간결한 표현식입니다.  
> 람다식은 익명 클래스에 비해 코드가 간결하다는 장점이 있는데, 함수형 인터페이스 덕분에 간결한 표현식인 람다로 메서드에 전달할 수 있게 됩니다.  
> 함수형 인터페이스는 추상 메서드가 하나뿐인 인터페이스로, 파라미터의 타입으로 함수형 인터페이스와 동일한 형태의 람다식만을 활용할 수 있습니다.  
> 람다식은 재사용이 불가능하다는 단점이 있습니다.  
> 그리고 중복되는 람다 식이 여러번 사용되면 오히려 코드가 지저분해질 수 있습니다.
</details>

<details>
    <summary><b>익명 클래스(Anonymous Inner Class)와 Lambda의 차이점을 알고계신가요?</b></summary> 

> 익명 클래스는 이름이 없는 클래스로, 클래스 또는 인터페이스의 메서드를 오버라이드하여 상속 없이 인스턴스화 할 수 있습니다.  
> 익명 클래스의 특징으로는 추상 메서드가 여러개여도 사용할 수 있다는 점과, 자기 자신 인스턴스를 참조할 수 있다는 점입니다. 익명 클래스는 this를 통해 자기 자신의 인스턴스를 참조할 수 있습니다.  
> 하지만 람다식은 그 자체로 표현식이고, 별도의 구현을 하지 않습니다.  
> 람다식의 특징으로는 추상 메서드가 오로지 하나인 함수형 인터페이스에만 사용할 수 있다는 점과, 자기 자신을 참조할 수 없다는 점입니다. 람다식 내부에서 this를 사용하면 바깥 인스턴스를 참조하게 됩니다.  
</details>

<details>
    <summary><b>람다식에서, 외부 변수를 사용할 때 final 키워드를 붙여서 사용하는 이유가 무엇일까요? final을 안 붙여도 되지 않을까요?</b></summary> 

> 람다식에서 사용하는 외부 지역변수가 final 특징이 있어야 하는 이유는 멀티 쓰레드 환경에서 외부 지역변수가 항상 최신값임을 보장하기 위함입니다.  
> 람다식에서 외부 변수의 값을 변경하면 안되는 이유는 JVM 메모리 구조와 연관이 있습니다.
> 스태틱 변수, 인스턴스 변수와 다르게 지역변수는 스택 영역에 값이 존재하고, 스택 영역은 스레드마다 고유한 메모리 영역을 할당받습니다.  
> 스택 영역의 특징 때문에 람다식에서 외부 지역 변수를 사용할 때에는 값을 복사해옵니다.  
> 멀티 쓰레드 환경에서 값을 복사해온다면 그 값이 최신값이라는 것을 보장할 수 없기 때문에, 바뀌지 않는 값이어야 한다는 제약이 필요합니다.  

- 그럼 지역변수는 항상 final이 붙어있어야 하나요?
  - 람다식에서 외부 지역변수를 사용할 때 해당 지역변수는 final이거나 effectively final이여야 합니다.  
  - 이 말 뜻은, final이 아니라고 할지라도 final의 속성을 가지고 있어야 함을 의미하고, 즉 값이 바뀌면 안됩니다.  
</details>


<details>
    <summary><b>Optional에 대해 설명해주세요. Optional을 사용하면 무슨 이점이 있을까요?</b></summary> 

> Optional이란 null이 올 수 있는 값을 감싼 Wrapper class 입니다.  
> null일 수 잆는 값을 다룰 때 이전에는 null check를 필수로 해야 했습니다.  
> 이런 방식은 코드가 번잡해지고, 개발자의 실수로 놓칠 수 있습니다.  
> 이 문제를 해결하고자 Optional이 추가되었고, null일 가능성이 있는 값을 Optional로 감싸서 null로 인한 예외를 명시적으로 처리하도록 할 수 있습니다.  
> Optional에는 null일 수 있는 값에 대한 다양한 정적 팩토리 메서드와 멤버 메서드들을 제공해줘서 간결한 코드로 null을 컨트롤 할 수 있게 해줍니다.


- orElse와 orElseGet의 차이점을 아시나요?
  - orElse는 파라미터로 값을 필요로 합니다. 그에 비해 orElseGet은 파라미터로 Supplier 함수형 인터페이스를 받습니다.
  - 만약 orElse 의 파라미터로 특정 동작을 하는 메서드의 반환값을 전달해준다면, null 여부와 상관없이 해당 메서드는 반드시 실행되어서 "값이 없을 때만 함수 실행" 이라는 목적을 달성할 수 없습니다.
  - 때문에 "null일 때만 함수 실행"이라는 동작을 하고자 할 때에는 orElseGet을 사용해야 합니다.

</details>
<details>
    <summary><b>Optional을 사용하면서 주의해야할 점이 있을까요?</b></summary> 

> Optional은 null을 반환하면 오류가 발생할 가능성이 높은 경우에 결과 없음을 명시하고자 반환값에만 사용해야 합니다.  
> 그리고 Optional에 있는 값이 null인지 판단하지 않고 꺼내면 NPE 대신 다른 예외가 발생할 수 있습니다.  
> 또한 Optional을 올바르지 않게 사용하면 코드의 가독성이 떨어진다는 점도 있습니다.  
> 올바른 Optional 사용을 위해선, 우선 Optional 자체에 null을 할당해서는 안되고, 빈 값인 경우에는 empty를 사용합니다.  
> 그리고 값을 꺼낼 때 isPresent와 get을 조합해서 꺼내지 말고, orElse~~로 시작하는 메서드로 꺼냅니다.  
> 그 밖에 단순히 값을 전달하는 목적으로 Optional을 사용하지 말고, 생성자, 수정자, 메서드 파라미터 등에 사용하지 않도록 합니다.
</details>

---

<details>
    <summary><b>Object 클래스의 equals()와 hashcode()는 무슨 역할을 하나요? 둘의 차이점을 설명해주세요.</b></summary> 

> equals는 2개의 객체가 동일한지 검사하는 메서드입니다. Object에 구현되어있는 equals는 두 객체의 주솟값을 비교합니다. 즉, 동일성을 확인합니다.  
> hashcode는 객체의 유일한 int값을 반환합니다. 기본적으로 저장된 주솟값을 활용합니다. hashcode는 HashMap, HashTable과 같은 자료구조에 값을 저장하기 위한 위치를 정할 때 사용합니다.  
</details>

<details>
    <summary><b>equals()와 hashcode()는 언제 재정의해야할까요? 또, 왜 같이 오버라이딩 하는게 좋을까요?</b></summary> 

> equals와 hashcode는 해시를 사용하는 자료구조에 우리가 정의한 동등성 비교를 규칙으로 객체를 저장하고 싶을 때 함께 재정의해야 합니다.  
> equals를 정의하게 되면 객체의 동등성을 비교할 수 있지만, hashcode를 정의해주지 않게 되면 equals의 결과가 true인 두 객체를 저장할 때 문제가 발생하기 때문입니다.  
> hash를 사용하는 자료구조는 객체를 비교할 때 hashcode의 리턴값을 먼저 비교하고, hash값이 같다면 그 후에 equals의 결과를 확인합니다. 즉, 둘이 다른 hash 값을 가지고 있다면 그 즉시 다른 객체라고 결론짓습니다.  
> 그렇다면 우리가 의도한 대로 자료구조에 저장되지 않기 때문에, equals와 hashcode는 같이 재정의해야합니다.

- equals와 hashcode는 hash를 사용하는 자료구조에 우리가 정의한 동등성 비교를 규칙으로 객체를 저장하고 싶을 때 함께 재정의해야합니다.  
- 우선, equals는 만약 주솟값의 비교가 아니라, 객체가 가지고 있는 값의 비교를 통해 객체가 동등한지 검사하고 싶을 때 정의할 수 있을 것입니다.  
- equals를 재정의함으로써 객체의 값으로 비교가 가능해졌지만, hashcode를 같이 재정의 해주지 않으면 hash를 사용하는 자료구조에 equals의 결과가 true인 두 객체를 저장할 때 문제가 발생합니다.  
- hash를 사용하는 자료구조는 객체를 비교할 때 hashcode의 리턴값을 먼저 비교하고, 둘이 다른 hash 값을 가지고 있다면 그 즉시 다른 객체라고 결론짓습니다.  
- 그렇다면 우리가 의도한 대로 자료구조에 저장되지 않기 때문에, equals와 hashcode는 같이 재정의해야합니다.

- 그럼 hash를 사용하는 자료구조에는 넣을 필요가 없는, 단순히 값 비교를 통해 객체 동등성을 파악하고자 할 때에는 equals만 정의해도 되겠네요?
  - 그렇지 않습니다. 협업 환경, 혹은 인수인계가 되고 코드가 레거시가 될 수 있는 환경에서, equals만 재정의하고 hashcode를 재정의 하지 않는다면 이 객체를 hash 자료구조에 담고 싶어하는 다른 개발자의 코드에서 오작동이 발생할 수 있습니다.  
  - 이런 위험한 상황을 예방하기 위해 hashcode도 같이 재정의하는 것이 좋다고 생각합니다.
</details>

<details>
    <summary><b>서로 다른 인스턴스가 같은 hashcode값을 가질 수 있을까요?</b></summary> 

> 가질 수 있습니다. hashcode의 리턴 타입은 int 이고, int는 4바이트의 크기를 갖습니다.  
> int가 포함할 수 있는 범위의 자료형은 hashcode가 중복되지 않겠지만, String이나 자바 객체같은 경우에는 hash 값이 겹치는 경우가 발생합니다.  
> 그렇기 때문에 다른 인스턴스가 같은 hash값을 가질 가능성이 있습니다.

- 그럼 hash값이 같고 equals가 다른 두 객체는 해시 자료구조에서 어떻게 저장되나요?
  - hash를 사용하는 자료구조에서 객체를 비교할 때 hash값이 같다면 equals로 객체를 비교하기 때문에, 서로 다른 객체로 각각 저장됩니다.
- Java hashMap에서 사용되는 해시 충돌 해결방식 : Seperate Channing
</details>


---

<details>
    <summary><b>String 클래스는 final로 선언되어있습니다. 왜 그런걸까요?</b></summary> 

> String이 불변 클래스로 선언된 이유는 String Constant Pool에 저장함으로써 메모리를 효율적으로 관리하고, 스레드에 안전하게 사용하기 위함입니다.  
> String은 자바의 설계자가 예상한, 가장 많이 쓰일 것 같은 자료형입니다. 그렇기 때문에 동일한 값의 String 객체가 중복 생성되는 것을 방지하기 위해 Constant Pool에 리터럴을 저장하고 공유하기 위해 불변으로 설계하였습니다.  
> String이 final 클래스인 이유는, Constant Pool에 저장되기 때문에, 상속을 막기 위함입니다. 만약 상속이 가능하면 String Constant Pool에서 해당 객체가 하위 어느 클래스인지 알 수 없게 되기 때문입니다.  
> 또한 String은 자주 쓰이는 자료형이기 때문에, 불변으로 설계하여 외부에서 동기화 관련한 코드가 없도록 하였습니다.

- String은 불변객체의 특성 때문에 Hash 관련 자료구조에 key로 쓰일 때 이점이 있는데요, 무슨 이점이 왜 있을까요?  
  - String은 불변객체이기 때문에 hashcode를 오버라이딩하여, 아직 hash를 계산한적이 없을 때에만 연산을 수행하고 계산한 값이 있다면 그 값을 그대로 참조합니다.  
  - 이런 hash 값 캐싱 덕분에 hash 자료구조에서 키로 자주 사용될 수록 성능 향상이 있습니다.
</details>


<details>
    <summary><b>String을 new 또는 "" 로 생성했을 때의 차이점을 설명해주세요.</b></summary> 

> 동일한 문자열을 가지는 두 String을 생성한다 할 때, String을 new 키워드로 생성하면 각각의 String 객체를 heap 메모리에 생성하게 됩니다.  
> 하지만, String을 리터럴로 생성하게 되면, 해당 문자열은 String Constant Pool에 저장되어서, 만약 이미 해당 리터럴이 존재한다면 리터럴이 저장된 주솟값을 참조하게 됩니다.  
> 즉, 동일한 리터럴에 대한 개별적인 객체가 생성되지 않고, 동일한 주솟값을 참조하게 됩니다.  
</details>

<details>
    <summary><b>String, StringBuilder, StringBuffer 를 각각 비교해주세요.</b></summary> 

> String은 불변 클래스이고, StringBuilder와 StringBuffer는 가변 클래스입니다.  
> String은 불변이기 때문에, String변수에 새로운 문자열 값이 할당되면 이전의 값을 수정하는 것이 아니라, 새로운 값으로 참조가 일어납니다.  
> 기존의 값이 더이상 쓰이지 않게 되면 GC의 대상이 되어 할당이 해제됩니다. 이런 특성 때문에 만약 자주 수정되는 문자열의 경우 성능이 떨어집니다.  
> 이런 경우에 사용할 수 있는 클래스가 StringBuilder, StringBuffer입니다.  
> StringBuilder와 StringBuffer는 공통적으로 AbstractStringBuilder를 상속합니다.  
> 이 추상 클래스는 배열인 value에 문자들을 저장하기 때문에, 문자열에 대한 추가, 수정 삭제가 동일한 객체에 대해 수행되는 것입니다.  
> 두 클래스의 차이는 동기화 여부입니다. StringBuilder는 동기화를 지원하지 않는 반면에, StringBuffer는 내부적으로 동기화와 관련한 키워드를 사용하여 멀티 쓰레드에서 사용할 수 있도록 처리해놓았습니다.

- JDK 1.5이후로 바뀐 String + 연산에 대해 설명해주실 수 있나요?
  - 한줄에 + 연산자를 통해 문자열을 합치는 경우에는 컴파일러가 이를 StringBuilder로 변환합니다.  
  - 반복문, 혹은 여러 줄에 걸쳐 concat 연산 등을 하는 경우에는 매 연산마다 StringBuilder가 생성됩니다.  
  - 그렇기 때문에 하나의 코드라인에서 + 연산자로 문자열을 합쳐서 할당할 경우에는 String 타입에 + 연산자로 사용해도 효율적입니다.
</details>

---

<details>
    <summary><b>컬렉션 프레임워크에 대해 설명해주세요.</b></summary> 

> 컬렉션 프레임워크란 자바에서 다수의 데이터를 저장하고 관리할 수 있도록 기능을 제공해주는 요소들의 집합입니다.  
> 배열은 크기가 고정되어있는데 반해 컬렉션 프레임워크의 자료구조들은 데이터를 가변적으로 저장할 수 있습니다.  
> 또한 데이터 삽입, 탐색, 삭제 등의 다양한 기능들을 직접 구현하지 않고 컬렉션 프레임워크의 기능들을 이용하여 편리하게 개발할 수 있습니다.  
> 주요 클래스 및 인터페이스로는 List, Map, Set, Stack, Queue가 있습니다.
</details>

---

<details>
    <summary><b>List 인터페이스의 구현체에 대해 설명해주세요.</b></summary> 

> List의 구현체로는 ArrayList, LinkedList, Vector가 있습니다.  
> 구현체들의 공통점은 객체를 일렬로 늘어놓은 구조로, 데이터를 인덱스로 접근할 수 있다는 특징입니다.  
> ArrayList는 내부에서 Object 배열에 데이터를 저장합니다.  
> LinkedList는 Node라는 내부 클래스끼리의 인접 참조로 데이터를 저장합니다.  
> Vector는 ArrayList와 같이 Object 배열로 데이터를 저장합니다. 차이점은 동기화 처리가 되어있어 한번에 하나의 쓰레드만 Vector에 접근할 수 있다는 점입니다.  
</details>

<details>
    <summary><b>Array와 ArrayList는 어떤 차이점이 있을까요?</b></summary> 

> 배열은 크기가 고정이지만, ArrayList는 용량을 초과한다면 자동으로 크기를 늘린다는 가변적인 특징을 갖고 있습니다.  
> 배열은 초기화시 크기를 명시해줘야 하지만, ArrayList는 경우에 따라 초기 용량을 지정해줄 수도 있고, 하지 않아도 됩니다.  
> 배열은 기본형과 참조형 타입 모두를 저장할 수 있지만, ArrayList는 참조형 타입만을 저장할 수 있습니다.

- 배열의 length와 size 간의 라이프사이클
  - 논리적인 크기(size)는 초기화 시 0이고, ArrayList에 데이터가 추가됨에 따라 크기(size)가 증가합니다.
</details>

<details>
    <summary><b>ArrayList는 내부적으로 어떻게 구현되어있나요?</b></summary> 

**🆀 배열로 구현되어있으면 크기가 꽉 찬 경우 일반 배열처럼 예외가 발생할텐데 ArrayList 는 어떻게 무한히 데이터를 받을 수 있을까요?** 

> ArrayList는 기본적으로 Object 타입의 배열과 int형 size 필드가 있습니다.  
> 초기화 시 경우에 따라 static으로 미리 선언되어있는 빈 배열을 활용하여 초기화합니다.  
> add 연산의 경우 size가 배열의 크기와 같다면, grow 메서드를 호출해 배열의 크기를 늘립니다.  
> grow 호출과 상관 없이 값을 배열에 저장하고, size 변수를 +1 해줍니다. 

- add 연산의 시간복잡도는 어떻게 되나요?
  - 크기를 재산정해주는 로직 때문에, 배열의 크기가 늘어난다면 O(N), 크기가 늘어나지 않는다면 O(1)의 시간복잡도를 갖습니다.
- 삭제 로직이 어떻게 되는지 아시나요?
  - index를 받으면 index에 해당하는, 지워질 값을 임시 변수에 저장합니다.  
  - 그 후 지워질 값 이후부터 마지막 요소의 값까지를 삭제되는 index위치로 옮깁니다.  
  - 그 후 GC에 의해 마지막 객체가 할당 해제가 되도록 size 인덱스에 있는 객체를 null 처리합니다. 
**※ Ref**

- https://f-lab.kr/blog/java-backend-interview-1

</details>


<details>
    <summary><b>ArrayList 와 LinkedList를 비교해주세요.</b></summary> 

> ArrayList는 데이터를 저장하기 위해 내부적으로 Object 배열을 사용합니다.  
> 그에 비해 LinkedList는 데이터를 저장하기 위해 Node라는 내부 클래스를 사용하고, 이 Node끼리의 인접 연결 형태로 저장합니다.  
> 둘은 동작 유형에 따라 성능 차이가 있습니다.  
> 특정 데이터를 검색할 경우, ArrayList는 인덱스 기반의 자료구조이기 때문에 O(1)의 시간복잡도를 갖지만, LinkedList는 첫 요소부터 순차탐색을 진행해야 하기 때문에 최악의 경우 O(N)의 시간복잡도를 갖습니다.  
> 데이터를 삽입/삭제하는 경우, ArrayList는 경우에 따라 내부 배열을 복사하는 과정을 거쳐야 하기 때문에 최악의 경우 O(N)의 시간복잡도를 갖지만, LinkedList는 노드 간의 참조 상태만 변경하면 되기 때문에 O(1)의 시간복잡도를 갖습니다.  
> 다만 LinkedList는 중간의 원소를 삽입/삭제하는 경우에 index만큼 검색을 해야하므로, 최악의 경우 O(N)의 시간복잡도를 갖습니다.   
</details>

---


<details>
    <summary><b>Map 인터페이스의 구현체에 대해 설명해주세요.</b></summary> 

- Map은 키와 value 쌍으로 데이터를 저장하는 자료구조입니다. 키는 중복 저장될 수 없지만, 값은 중복저장될 수 있습니다.  
- Map은 List와 다르게 값들이 순차적으로 관리되는 것이 아니라, key를 통해 value값을 얻어오는 방식으로 관리합니다.   
- Map 인터페이스의 주요 구현체로는 HashMap, HashTable, LinkedHashMap, TreeMap 등이 있습니다.  
- HashMap은 해시 기법을 사용하여 key와 value에 해당하는 객체를 저장하는 컬렉션입니다. key에 대한 순서를 보장하지 않습니다. 그리고 스레드에 안전하지 않습니다.  
- Hashtable은 HashMap과 내부 구조는 비슷하지만 동기화와 관련한 키워드로 메서드들이 정의되어있어 스레드에 안전하다는 특징이 있습니다.  
- LinkedHashMap은 HashMap의 구조를 갖지만 key-value쌍이 저장되는 순서를 보장한다는 특징이 있습니다.  
- TreeMap은 이진트리를 기반으로 key,value를 저장하는 컬렉션입니다. TreeMap은 값을 저장할 때 즉시 정렬한다는 특징이 있습니다.  

</details>

<details>
    <summary><b>HashTable에 대해 설명해주세요.</b></summary> 

- HashTable은 컬렉션 프레임워크 이전부터 존재하던 클래스로, 호환을 위해 Map을 구현하도록 설계를 변경해서 남겨놓았습니다.  
- HashTable은 스레드에 안전하다는 특징이 있고, key와 value에 Null이 들어올 수 없습니다. 
</details>

<details>
    <summary><b>HashMap과 HashTable을 비교해주세요.</b></summary> 

- HashMap은 스레드에 안전하지 않은 반면, HashTable은 동기화를 지원해주기 때문에 스레드에 안전합니다.  
- HashMap은 key와 value에 null을 허용하지만, HashTable은 null을 허용하지 않습니다.  
- HashMap은 성능 개선을 위해 지속적으로 업데이트되고 있지만, HashTable은 호환을 위해 구조만 변경했을 뿐 구현에 지속적인 변화가 없습니다.

- HashMap이 어떻게 개선되었는지 예시를 들어줄 수 있나요?  
  - HashMap은 해시 충돌을 해결하기 위해 Seperate Chaning을 이용하는데, 기존에 연결 리스트만을 이용했을 때 요소개수가 많아지면 선형 시간만큼 성능이 안좋아지는 문제가 있었습니다.  
  - 이를 보완하고자 요소 개수가 일정 수치보다 더 많아지면 연결 리스트에서 트리로 변경하여 저장하는 식으로 성능을 개선하였습니다.
- 그럼 멀티쓰레드 환경에서는 HashTable 사용이 필수적인가요? 다른 대안이 있는지, 그 이유는 뭔가요?  
  - ConcurrentHashMap을 쓰는 것이 성능상 더 좋습니다.  
  - HashTable은 인스턴스에 lock을 걸지만, ConcurrentHashMap은 조작중인 엔트리 단위로 lock을 걸기 때문에 비교적 성능이 더 좋습니다.
</details>

<details>
    <summary><b>HashMap과 ConcurrentHashMap은 어떤 차이가 있나요?</b></summary> 

- HashMap은 동기화 처리를 해주지 않아서 스레드에 안전하지 않습니다. 대신 싱글 스레드에서 사용할 때 ConcurrentHashMap에 비해 성능이 더 좋습니다.  
- ConcurrentHashMap은 사용되고 있는 Entry 객체에 대해서, 추가 혹은 삭제 연산 시에만 synchronized를 겁니다. 따라서 쓰레드에 안전하게 사용할 수 있습니다.  
- 또한, HashMap은 key, value에 null을 허용하지만, ConcurrentHashMap은 key, value에 null을 허용하지 않습니다.
</details>

--- 

<details>
    <summary><b>Set 인터페이스의 구현체에 대해 설명해주세요.</b></summary> 

- Set은 순서가 보장되지 않는 집합이며, 데이터를 중복허용하지 않는 컬렉션입니다. Map의 key-value 구조에서 key 대신 value가 쓰여 value를 key로써 관리하는 컬렉션입니다.  
- HashSet은 hash 기법으로 데이터를 저장하는 구현체입니다.  
- TreeSet은 데이터의 추가 삭제 시 자동으로 정렬해주는 Set입니다.  
- LinkedHashSet은 데이터의 저장된 순서를 보장해주는 Set입니다.

- LinkedHashSet이 어떻게 순서 보장?
</details>

<details>
    <summary><b>List와 Set을 비교해주세요.</b></summary>

- List는 index로 데이터를 조회할 수 있는 반면에, Set은 index로 특정 아이템을 조회할 수 없습니다.  
- List는 중복되는 요소를 저장할 수 있는 반면에, Set은 중복을 허용하지 않습니다.  
- 객체가 존재하는지 확인하는 contains 메서드의 시간복잡도는 List가 O(N)인데 반해 Set은 O(1)을 갖습니다.  

- 언제 List를 사용하고 언제 Set을 사용하는게 좋을까요?  
  - List는 index 기반으로 순회하거나, index 위치에 있는 값을 조회하고 싶을 때 사용하면 좋을 것 같습니다.  
  - Set은 중복을 허용하지 않고 원하는 객체를 빠르게 조회하고자 할 때 사용하면 좋을 것 같습니다.

**※ Reference**

- [기술 면접에서 list와 set의 차이를 물어보는 이유](https://www.youtube.com/watch?v=CMgpTGs_N_w)

</details>

--- 

<details>
    <summary><b>Java의 컴파일(실행) 과정을 설명해주세요.</b></summary> 

- java 파일을 작성하고 컴파일을 하게 되면 컴파일러에 의해 JVM이 실행시킬 수 있는 자바 바이트 코드로 컴파일됩니다.  
- 컴파일된 자바 바이트 코드는 클래스 로더에게 전달되어 필요한 클래스들을 JVM의 메모리 영역에 올립니다.  
- 메모리 영역에 올라온 바이트 코드들은 실행 엔진에 의해 실행됩니다.  

- 인터프리터와 JIT 컴파일러
  - 자바는 원래 인터프리터 기반의 언어였습니다. 인터프리터는 컴파일 언어에 비해 실행시간이 느리다는 단점이 있기 때문에, 자바는 인터프리터와 함께 JIT 컴파일러를 도입하였습니다.  
  - JIT 컴파일러는 런타임 시 바이트 코드를 기계어로 번역하는 컴파일러로, 기계로 변환된 코드를 캐시에 저장하고 코드가 중복 실행되면 컴파일된 기계어를 재사용하는 방식으로 성능을 향상시켰습니다.
</details>

<details>
    <summary><b>JDK, JRE, JVM에 대해 설명해주세요.</b></summary> 

> 먼저 JVM에 대해서 설명드리면, JVM은 자바 가상 머신으로, 자바 바이트 코드를 운영체제에 맞게 실행시켜주는 가상 머신입니다. JVM은 자바 인터프리터, JIT 컴파일러, GC로 구성되어있습니다.  
> JRE는 우리가 작성한 코드가 JVM에서 정상적으로 작동하기 위한 환경을 제공해줍니다. 우리가 작성한 코드에는 Java에서 기본적으로 제공해주는 클래스들이 존재하고, 그리고 여러 클래스 파일들을 JVM에 적재할 수 있어야 합니다.  
> 이를 위해 JRE에는 JVM과 함께 Java Class Library가 존재하여 기본적인 자바 클래스들을 제공하고, 클래스 로더가 존재하여 필요한 클래스들을 JVM의 메모리 영역에 올릴 수 있습니다.  
> JDK는 자바 어플리케이션을 개발하고 실행할 수 있는 도구들을 제공하는 개발 키트입니다. JDK에는 JRE와 함께 자바 컴파일러, 디버거 등이 포함되어 있습니다.
</details>

<details>
    <summary><b>JVM의 메모리 구조에 대해 설명해주세요.</b></summary> 

> JVM의 메모리 구조는 스레드가 공유하는 힙, 메서드 영역과 스레드별로 생성되는 스택, 네이티브 메서드 스택, PC 레지스터로 구성되어있습니다.  
> 힙 영역은 new 키워드로 생성되는 객체와 배열들이 저장되는 영역으로, GC의 대상이 되는 영역입니다.  
> 메서드 영역은 클래스의 각종 필드 정보와 메서드 정보, 데이터 타입 정보, static 변수, Runtime Constant Pool 등이 위치하는 영역입니다.  
> 스택 영역은 지역변수, 파라미터, 리턴 값 등이 생성되는 영역입니다. 메서드가 실행되면서 스택에 쌓이고 메서드 실행이 끝나면 사라집니다.  
> 네이티브 메서드 스택은 자바로 작성되지 않은 메서드를 다루는 영역입니다. 스택과 마찬가지로 네이티브 메서드가 실행되면 쌓이게 됩니다.  
> PC 레지스터는 멀티 스레드 환경에서 정상적인 실행을 보장하기 위한 영역으로, 현재 스레드가 최근에 실행한 명령의 주솟값을 저장하는 영역입니다.

- 레퍼런스 타입이 저장되는 위치(메서드 내부의 레퍼런스 & 클래스 인스턴스 내부의 레퍼런스)
- 네이티브 메서드는 왜 사용되나요? 어느 경우에 사용되나요?
- Runtime Constant Pool vs String Constant Pool : https://8iggy.tistory.com/229
  - GC 공부하면서 다시 수정
- 힙 영역의 내부 구조에 대해서 설명해주실 수 있나요?  
  - 힙 영역은 효율적인 GC를 위해 Young Generation, Old영역, Perm 영역으로 구성되어있습니다.  
  - GC에 따른 영역 설명은 다음 시간에 계속...
</details>

---

<details>
    <summary><b>클래스 로더</b></summary>

### 클래스 로더란?
클래스 로더는 런타임 중에 JVM의 메서드 영역에 컴파일된 바이트코드를 로드하는 역할을 합니다.

### 클래스 로딩 과정
클래스 로딩은 크게 로딩, 링킹, 초기화의 과정을 거쳐 진행됩니다.
- 로딩: 바이트 코드를 가져와 JVM의 메모리에 로드합니다.
- 링킹: 검증, 준비, 분석의 3단계 링킹 과정에 거칩니다.
  - 검증: 읽어 들인 클래스가 자바 언어 명세 및 JVM 명세에 명시된 대로 잘 구성되어 있는지 검사합니다.
  - 준비: 클래스가 필요로 하는 메모리 공간을 준비합니다.
  - 분석: 심볼릭 메모리 레퍼런스를 실제 레퍼런스로 교체합니다. 여기서 심볼릭 메모리 레퍼런스란 클래스의 실제 메모리 주소가 아니라, 해당 클래스의 이름만을 지징한 것입니다.
- 초기화: 클래스의 static 변수들을 선언된 값으로 초기화합니다.

### 클래스 로더의 계층 구조와 원칙
클래스 로더는 Bootstrap ClassLoader, Extension ClassLoader, System ClassLoader의 3가지 종류로 계층 구조를 이룹니다.

클래스 로더의 원칙
- 위임 원칙: 어떤 클래스 파일을 로딩할 때, 취상위 클래스로더까지 그 책임을 위임하는 위임 모델을 따라야 합니다.
- 가시 범위 원칙: 하위 클래스로더는 상위 클래스로더가 로딩한 클래스를 찾을 수 있지만, 그 반대는 안됩니다.
- 유일성 원칙: 하위 클래스로더가 상위 클래스로더에서 이미 로딩한 클래스를 다시 로딩할 수 없습니다.
- 그 밖에 특징: 한번 로드된 클래스는 JVM 상에서 삭제할 수 없습니다.

### 동적 클래스 로딩
클래스 로딩은 특정 클래스가 필요할 때 동적으로 메모리에 적재함으로써 효율적으로 관리합니다.
최초 클래스 로딩 시점에 모든 클래스 파일들이 로드되면 사용되지 않는 불필요한 클래스가 로드되는 등 효율적이지 않습니다.
그렇기 때문에 클래스 로더는 동적으로 클래스 파일을 로딩합니다.
- 로드타임 동적 로딩: 클래스가 로드될 때 필요한 모든 클래스들을 로드하는 클래스 로딩 방식입니다.
- 런타임 동적 로딩: 클래스의 코드가 실행되는 시점에 클래스를 로딩하는 방식입니다.

### 클래스는 언제 로딩되고 초기화되는가?
로딩 시점: 클래스는 1) 클래스 인스턴스가 생성될 때, 2) 클래스의 final이 아닌 정적 변수가 호출될 때, 3) 클래스의 정적 메서드가 실행될 때 로드됩니다.
- static final 클래스가 호출해도 클래스가 로딩되지 않는 이유: 상수는 Constant Pool에 따로 관리되기 때문입니다.
- 내부 클래스를 갖는 클래스의 로딩
  - 1) static 내부 클래스 호출(생성): 내부 클래스만 로딩됩니다. 외부 클래스와 독립적으로 생성될 수 있기 때문입니다.
  - 2) 내부 클래스 호출(생성): 내부 클래스와 외부 클래스 모두 로딩됩니다. 외부 클래스와 암묵적으로 연결되고 참조할 수 있기 때문입니다. 이로 인해 메모리 누수 문제가 발생합니다.

초기화 시점: 로딩 시점과 동일합니다. 여기서 초기화란 static 블록과 static 변수의 값을 할당하는 것을 의미합니다.
로딩 과정과 초기화 과정은 사실상 거의 동시에 일어납니다.

### 클래스는 최초 한번만 로딩되고 초기화됩니다.
이로 인해 클래스 로딩 및 초기화 동작은 쓰레드에 안전합니다.
이 사실은 Singleton 패턴의 응용 사례에 이용됩니다.
단순한 방식의 Singleton 패턴 문제점은 멀티 쓰레드에 안전하지 않을 수 있다는 점과 eager loading일 경우 사용되지 않음에도 생성된다는 비효율적인 문제가 있습니다.
이 문제를 해결하고자 클래스로딩의 한번만 로딩되고 초기화된다는 성질을 이용하여 싱글톤 패턴을 설계하는 방식이 있습니다.

  ```java
class Singleton { // 싱글톤 클래스가 초기화되어도 static inner 클래스는 로드되지 않음
    private Singleton() {}
    
    // static 내부 클래스를 이용. 클래스는 최초 1번만 초기화되기 때문에 멀티쓰레드 환경에서도 싱글톤 객체가 단 한번 생성됨.
    private static class SingleInstanceHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
  
    public static Singleton getInstance() {
        return SingleInstanceHolder.INSTANCE;
    }
}
  ``` 
</details>

<details>
    <summary><b>정적 바인딩, 동적 바인딩</b></summary>

### 바인딩이란?
바인딩이란 프로그램에서 사용되는 메서드나 변수 등의 모든 것들이 결정되도록 연결짓는 것을 의미합니다.

### 동적 바인딩 vs 정적 바인딩
정적 바인딩
- 컴파일 시점에 결정됩니다.
- 오버로딩된 메서드, private & final & static이 붙은 멤버(필드, 메서드)가 이에 해당합니다.
- 오버로딩된 메서드는 컴파일 시점에 오버로딩된 메서드들 중 어떤 메서드가 실행될지를 결정할 수 있기 때문에 컴파일 타임에 바인딩됩니다.

동적 바인딩
- 런타임 시점에 결정됩니다.
- 위에 언급하지 않은 메서드와 오버라이딩된 메서드가 이에 해당합니다.
- 하지만 오버로딩된 메서드는 컴파일 시점에 어떤 하위 클래스의 메서드가 실행될지 알 수 없으므로, 런타임 시점에 바인딩됩니다.

### static 메서드가 오버라이딩 되지 않는 이유
- static 메서드는 메서드를 갖는 인스턴스가 생성되기 전에 이미 클래스 로더에 의해 메모리에 적재되기 때문에, 정적 바인딩의 성격을 가져서 오버라이딩 되지 못합니다.
</details>

<details>
    <summary><b>가비지 컬렉터</b></summary>

### 가비지 컬렉터란?
가비지 컬렉터는 유효하지 않은 메모리를 자동으로 정리해주는 JVM의 요소입니다. 
GC는 Heap 메모리 구조가 Young 영역과 Old 영역으로 구성되어 있고, 공통적으로 Stop the world와 mark and sweep이라는 과정을 거칩니다.
Stop the world는 가비지 컬렉션을 실행하기 위해 JVM이 어플리케이션의 실행을 멈추는 단계로, GC가 실행되는 쓰레드를 제외한 모든 쓰레드의 실행이 멈춥니다.
이후에는 Mark and Sweep이라는 실질적인 가비지 컬렉션이 일어나는데, 우선 스택과 메서드 영역의 모든 변수와 기타 요소들로부터 Reachable한 객체들을 모두 탐색하며 mark합니다.
mark했다는 뜻은 탐색 가능하다는 뜻이고, 이는 아직 사용중인 메모리라는 뜻입니다. 
mark 작업이 끝나면 sweep 이 실행되고, mark되지 않은 객체들을 Heap에서 제거하게 됩니다. 이런 과정으로 GC가 동작합니다.

### Heap 메모리 구조
Heap 메모리구조는 Young 영역과 Old 영역으로 나뉩니다. Perm 영역의 경우 Java 8 이후에 제거되었습니다.(그렇기 때문에 Perm에 저장되던 Static Object 또한 heap으로 넘어와서 gc의 대상이 됩니다.)
Young 영역은 객체가 생성되면 제일 먼저 위치하는 영역입니다. Young 영역은 Eden 영역과 Survivor 영역 2개로 이루어져있습니다.
대부분의 객체가 금방 Unreachable 상태가 되기 때문에, 많은 객체들이 Young 영역에서 생겼다가 제거됩니다.
Old 영역은 Young 영역에 Reachable 상태를 유지하던 객체가 옮겨지는 영역입니다. 
Old 영역은 Young 영역보다 더 큰 공간을 할당받는데, Young 영역의 객체들은 수명이 짧기 때문에 그만큼 영역이 적어도 되고, 큰 객체의 경우 바로 old 영역에 할당되기 때문입니다.
Old 영역의 객체가 Young 객체를 참조하는 경우에 대비하여 Old 영역에는 card table이 존재합니다. 
카드 테이블이 존재하는 이유는 minor gc가 동작할 때 매번 old 영역의 객체가 young 영역의 객체를 참조하는지 모든 객체들을 탐색하는 것이 비효율적이기 때문입니다.
카드 테이블에는 old 영역의 객체가 young 영역의 객체를 참조할 때 마다 그에 대한 정보를 표시해 minor gc 동작 시에 카드 테이블만 탐색하면 됩니다.

### Minor GC & Major GC
Minor GC
1. 새로운 객체가 Young의 Eden 영역에 쌓입니다.
2. 객체가 계속 생성되어 Eden 영역이 꽉 차면 Minor GC가 발생합니다.
   - 사용되지 않는 객체는 제거되고 사용되는 객체는 1개의 Survivor 영역으로 이동합니다.
3. 1~2를 반복하다가 Survivor 영역이 꽉차면 Survivor 영역의 살아남은 객체들을 다른 Survivor 영역으로 옮깁니다.
   - Survivor 영역은 2개중 오직 하나에만 객체들이 존재합니다.
4. Minor GC에서 살아남은 횟수를 기록하고, 일정 age 이상이 된 객체는 Old 영역으로 옮겨집니다.

Major GC 
- Young GC에서 넘어온 객체가 쌓여서 Old 영역이 꽉 차면 GC를 실행합니다.
- GC 알고리즘에 따라서 처리 절차가 달라집니다.

### GC 알고리즘
1. Serial GC: GC를 처리하는 기본적인 mark sweep 과정에 heap 메모리를 객체가 쌓여있는 부분과 쌓여있지 않은 부분으로 나누어 정리하는 compact 과정이 추가된 알고리즘입니다. 
   - CPU 코어 수가 1개일 때를 고려하여 만들어진 알고리즘으로, CPU 코어 수가 부족할 때 사용합니다.
2. Parallel GC: Serial GC를 여러 쓰레드로 수행하는 알고리즘으로, Java 8까지 default GC로 선택되었습니다.
3. Parallel Old GC: Parallel GC에서 Old 영역의 과정만 다른 알고리즘입니다. Sweep 단계 대신 Summery 단계를 수행하는데, 앞서 GC를 수행한 영역에 대해서 별도로 살아있는 객체를 식별합니다.
4. CMS GC: stop the world 단계를 여러번 가져서 각각 초기 mark, remark, sweep 단계를 concurrent 하게 수행하는 알고리즘입니다. stop the world 시간이 짧기 때문에, 응답성이 중요한 어플리케이션에 사용하면 좋습니다.
    - 하지만, CPU 사용량이 다른 알고리즘에 비해 많고, Compaction 단계가 기본적으로 제공되지 않습니다. 그리고 다른 알고리즘에 비해 조각난 메모리가 많기 때문에, compaction 시 stop the world 시간이 길 수 있습니다.
5. G1 GC: 기존의 Heap 구조가 아니라, 바둑판 형태의 각 구역에 객체를 할당하고 GC를 실행합니다. Heap을 동일한 크기의 Region으로 나누고, 가비지가 많은 Region에 대해 우선적으로 GC가 일어납니다.
    - Minor: Eden 영역에 대해 minor gc가 실행되면, 해당 리전은 사용되지 않는다는 뜻의 Available/Unused 가 되고, 복제되어온 리전은 Survivor 리전이 됩니다.
    - Major: 객체가 많아지면 Major GC가 실행됩니다. 어느 영역의 가비지가 많은지 알고 있기 때문에 가비지가 많은 영역들에 대해서만 GC를 수행하게 되고, 이는 concurrent하게 일어납니다.
    - GC가 자주 일어나지만, 작은 영역에 대해서 concurrent하게 일어나기 때문에, 지연이 크지 않고 효율적입니다. 
    - 메모리 공간이 큰 멀티 프로세스 기반의 환경을 위해 고안되었고, Java 9부터 default GC로 선정되었습니다.

### GC와 성능 튜닝

</details>

---

<details>
    <summary><b>객체 지향 프로그래밍(캡상추다)</b></summary>

### 객체지향 프로그래밍의 4가지 특징
1. 추상화: 구체적인 대상의 공통 속성이나 기능으로 뽑아내는 것을 의미합니다. 추상화를 통해서 중복 코드를 줄이고, 유지보수를 쉽게 할 수 있습니다.
2. 캡슐화: 외부로부터 감추고 싶은 데이터를 보호하는 은닉성을 제공할 수 있음을 의미합니다. 
자바에서는 캡슐화를 지원하기 위해 다양한 접근 제어자들을 제공해줍니다. 이를 통해 객체의 상태가 외부에 공개되는 것을 막을 수 있고, 객체 간의 경계를 명확히 하여 견고한 객체지향 프로그래밍을 가능하게 합니다.
3. 상속: 상속은 부모 클래스의 속성과 기능을 그대로 이어받아 사용하거나, 필요할 경우 기능의 일부분을 재정의하여 사용할 수 있음을 의미합니다. 상속으로 인해 코드의 재사용성이 늘어납니다.
자바에서는 기본적으로 추상 클래스와 인터페이스에 이를 상속할 객체들의 공통 기능들을 정의해 놓음으로써 상속을 이룰 수 있습니다.
4. 다형성: 다형성은 프로그래밍의 요소에 다양한 타입을 적용할 수 있는 성질을 의미합니다. 자바에서는 메서드의 오버라이딩을 통해 런타임 시점에 타입을 정해서 유동적으로 메서드를 실행할 수 있습니다.
- Spring에서는 다형성을 활용할 수 있도록 설게되었는데요, 스프링은 IoC 컨테이너를 통해 우리가 구현한 클래스들을 스프링 컨테이너에 등록하고 필요한 구현체들을 주입시켜줍니다. 
- 이를 통해 주입받는 쪽에서는 인터페이스 타입으로 받도록 하면 어떤 Bean을 주입받는지 사용하는 쪽에서는 알 필요가 없게 됩니다.
</details>

<details>
    <summary><b>SOLID 원칙</b></summary>

### SRP
단일 책임 원칙. 한 클래스는 하나의 책임만을 가져야 하고, 클래스를 수정해야 할 이유는 단 한가지여야 합니다. 
SRP는 여러 책임을 갖는 한 객체 각 책임을 갖는 여려 클래스로 분리하는 것 뿐만 아니라, 여러 곳에 분포되어있는 책임을 한 클래스로 모으는 것도 해당됩니다.
- 경험: Spring 기반 API 서버 개발 프로젝트를 개발할 때, 각 계층별로 validation 해야하는 레벨에 대해서 고민한 적이 있었습니다.
- 이때 SRP 원칙대로 클래스마다, 즉 계층마다 갖는 책임에 따른 validation만을 진행하기로 결정하였습니다. Controller와 Service에서 데이터를 주고받는 DTO 클래스는 비즈니스 로직이 없는 단순 값으로서의 유효성을 판단하고,
- 서비스 레이어에서는 DB, 혹은 다른 컴포넌트와의 협력을 통해 검증할 수 있는 것들을 검증하였습니다. 마지막으로 도메인 클래스에서는 그 도메인이 갖는 비즈니스 요구사항에 맞는 검증을 진행하였고, SRP원칙을 따라가며 설게한 결과 계층별 검증 책임을 명확하게 나눌 수 있었습니다.

### OCP
개방 폐쇄 원칙. 소프트웨어 요소는 확장에는 열려있어야 하고, 수정에는 닫혀있어야 합니다. 변경이나 추가사항이 있을 경우 기능의 확장을 통해 변경은 최소한으로 해야 하고, 기존 요소들을 재사용할 수 있어야 함을 의미합니다.
객체 간의 결합도가 높아질 수록 변경에 영향을 받게 됩니다. 그렇기 때문에 OCP를 만족시키기 위해 객체 간의 결합도를 낮춰야 하고, 이는 곧 본질적으로 OCP를 위해 추상화를 시켜야함을 의미합니다.
- 자바에서 OCP가 적용된 예시: default 메서드의 추가라고 생각합니다. 기존에는 인터페이스 기반의 프레임워크 혹은 라이브러리에 어떤 메서드를 추가하게 되면, 이 기능을 사용하는 모든 코드에 컴파일 에러가 발생합니다. 이런 경우는 변경이 불가피한 상황이었고,
- 그래서 default 메서드가 추가되었고, 기능 확장이 필요한 경우 default 메서드로 설계하면, 이를 사용하던 코드에서는 필요한 경우에만 해당 기능을 재정의 하는 식으로 확장할 수 있게 되었습니다.
- Spring에서 OCP가 적용된 예시: Spring은 IoC 컨테이너를 통해 우리가 구현한 클래스들을 스프링 컨테이너에 등록하고 필요한 구현체들을 주입시켜줍니다.
- 이 때 의존성이 필요한 클래스들의 타입을 인터페이스 타입으로 선언해놓는다면, 추후에 기능 명세가 달라져도 인터페이스를 구현하는 새로운 구현체를 만들어서 대신 주입시키도록 하면 수정에는 닫혀있고, 변경에는 열려있도록 개발이 가능해집니다.

### LSP
리스코브 치환의 원칙. 하위 클래스는 상위 클래스, 인터페이스의 규약을 다 지켜야 함을 의미합니다.
인터페이스를 구현체로 구현하는 과정에서 LSP를 지킴으로써 OCP를 만족할 수 있습니다. 
만약 List의 구현체 중 ArrayList를 사용중이었는데, 요구사항이 바뀌어서 LinkedList를 사용하게 되었다면, 레퍼런스를 담는 타입을 상위 인터페이스인 List로 받으면
변경을 최소화하여 ArrayList에서 LinkedList로 변경할 수 있고, 메서드들 또한 그대로 사용할 수 있습니다. 이는 List 인터페이스와 각 구현체들이 LSP를 지키기 때문입니다.

### ISP
인터페이스 분리의 원칙. 특정 클라이언트를 위한 여러 인터페이스가 여러 종류의 클라이언트를 위한 범용 인터페이스 하나 두는 것보다 더 낫습니다. 
이렇게 설계하면 하나의 인터페이스를 수정하더라도 다른 인터페이스에는 영향이 가지 않습니다.
- 만일 클래스가 어떤 인터페이스를 구현하고 있었는데, 해당 클래스에 추가 기능이 필요해지는 경우를 생각해보겠습니다. 
- 이때 이 추가 기능을 기존 인터페이스에 추가하게 되면 이 인터페이스는 여러 기능을 갖는 범용 인터페이스가 되고, 이를 구현하는 여러 구현체들은 원하는 기능 뿐만 아니라, 알 필요 없는 나머지 기능들도 다 알게 됩니다.
- 이를 개선하기 위해 ISP를 적용하여 해결할 수 있습니다. 추가 기능에 대한 인터페이스를 새로 작성하고, 클래스는 두 인터페이스를 모두 상속하도록 한 다음, 필요한 인터페이스 타입으로 받게 되면 필요한 기능들만을 알게 됩니다.

### DIP
의존관계 역전 원칙. 구체화에 의존하면 안되고, 추상화에 의존해야 함을 의미합니다.
- Spring에서 DIP가 적용된 예시: Spring은 의존성을 갖는 구체 클래스를 개발자가 직접 설정하는 것이 아니라 IoC 컨테이너를 통해서 프레임워크 차원에서 의존성을 주입해줍니다.
- 개발자의 코드에 직접적인 구체 클래스 타입이 보이지 않기 때문에, 객체 간의 결합도가 낮아졌고 코드의 유연성을 확보할 수 있습니다.

### Spring의 IoC 컨테이너
Spring의 IoC 컨테이너는 프로그램에서 사용될 객체들을 빈으로 등록하여 생명주기를 관리하고, 필요한 의존성을 주입시켜주는 컨테이너입니다.
컨테이너가 없는 코드에는 의존성을 연결해주기 위해서는 클래스 간의 강한 결합이 불가피합니다. 요구사항이 변경되면 해당 코드라인을 직접 변경해줘야 합니다.
이를 해결하기 위해 프레임워크의 도움을 받으면, 외부로부터 의존성을 주입받을 수 있습니다. Spring IoC 컨테이너가 바로 이 역할을 하는 것입니다.
Spring IoC 컨테이너로 인해 강하게 결합되었던 클래스들을 분리하고, 애플리케이션 실행 시점에 각 객체들관의 의존관계를 결정해주기 때문에 결합도를 낮추고 유연성을 확보할 수 있습니다.
</details>

<details>
    <summary><b>객체 지향 프로그래밍 vs 절차 지향 프로그래밍</b></summary>

절차 지향 프로그래밍이란 프로그램이 순차적으로 처리되도록 하는 프로그래밍 기법입니다. 전체적인 기능 동작을 고려하여 각 단계별로 기능을 구현합니다.
절차 지향 프로그래밍은 컴퓨터와 비슷한 처리 구조를 갖기 때문에 속도가 빠르지만, 모든 시스템 구성요소가 연결되어있기 때문에 유지보수가 어렵습니다.
객체지향 프로그래밍이란 책임을 갖는 객체들 간에 협력의 순서와 방향을 설게하여 프로그램이 실행되도록 하는 프로그래밍 기법입니다.
각 객체는 자신만의 책임을 수행하기 위해 상태와 행동을 갖고 있고, 객체 간에는 메세지를 주고받음으로써 상호작용합니다.
객체지향 프로그래밍은 프로그램의 구성요소들을 클래스로 설게하고 런타임 시점에 객체로 다룸으로써 재사용이 가능하고, 유지보수에 용이하게 할 수 있습니다. 
하지만 절차지향 프로그래밍 언어에 비해 속도가 느리고, 요구사항에 맞는 객체들을 설계하고 개발 시에 이들에 대한 이해도가 요구되기 때문에 개발 속도가 느릴 수 있습니다.
</details>