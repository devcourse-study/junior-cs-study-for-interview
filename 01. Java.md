<details>
    <summary><b>Java 의 장단점에 대해 설명해주세요.</b></summary>

> 먼저 자바의 장점에 대해서 설명해보겠습니다. 자바는 객체지향의 특징을 잘 살려서 개발할 수 있는 언어입니다.  
> 그리고 자바는 JVM 위에서 동작하기 때문에, 자바 프로그램은 운영체제에 관계 없이 실행할 수 있다는 장점이 있습니다.  
> 또한 자바의 가비지 컬렉터가 메모리를 자동으로 괸리해준다는 장점도 있습니다.  
> 자바의 단점으로는, 자바 코드가 실행되기 위해서는 바이트코드로 컴파일되고, 다시 한번 컴퓨터가 이해할 수 있는 기계어로 번역되어야 합니다.  
> 그렇기 때문에 속도가 느리다는 단점이 있습니다. 이 단점은 JIT 컴파일러와 같은 기술들로 많이 개선되었습니다.  
> 그리고 파이썬과 같은 언어에 비해 코드가 복잡하다는 단점도 있습니다.

- 장점
    - Java의 장점으로는 JVM에서 동작하기 때문에, 운영체제에 독립적이라는 점입니다.
    - Java는 객체지향의 특징을 잘 살려서 개발할 수 있는 언어입니다.
    - 또한 가비지 컬렉터에 의해 GC가 일어나서, 메모리 관리를 자동으로 해준다는 장점이 있습니다.<br>
- 단점
  - 단점으로는 바이트 코드로 컴파일되고, 이 바이트 코드가 다시 한번 컴퓨터가 이해할 수 있는 기계어로 번역되기 때문에, 수행속도가 비교적 느립니다.
  - 또한 python 과 같은 언어와 비교했을 때 코드가 다소 장황하다는 단점도 있습니다.

- 꼬리질문
  - JIT 컴파일러에 대해 설명해주실 수 있나요?
  - JIT 컴파일러의 어떤 점 때문에 앞서 말하신 단점이 개선된건지 설명해주실 수 있나요?
  - JVM 관련 질문
  - OOP 관련 질문
    - 자바가 객체지향의 특징을 잘 살렸다고 하셨는데, 예시를 하나 들어주실 수 있나요?
</details>

---

<details>
    <summary><b>Java 의 데이터 타입에 대해 설명해주세요.</b></summary>

> 자바의 데이터 타입에는 기본형 타입과 참조형 타입이 있습니다.  
> 기본형 타입은 정수형, 실수형, 문자, 논리 값을 직접 저장하는 타입을 말합니다.
> 참조형 타입은 기본형 타입을 제외한 나머지 타입으로, 힙 영역에 저장된 데이터의 주소가 변수에 저장된다는 특징이 있습니다.  
> 참조형 타입의 종류로는 클래스, 인터페이스, 열거형, 배열 등이 있습니다.

- Java 의 데이터 타입에는 primitive 타입과 reference 타입이 존재합니다. 
  - primitive 타입은 정수형, 실수형, 문자, 논리 값을 직접 저장하는 타입입니다.
  - reference 타입은 primitive 타입을 제외한 타입으로, reference 타입에는 힙 영역에 저장된 데이터의 메모리 주소를 저장합니다.
- 꼬리 질문
  - String은 기본형인가요, 참조형인가요?
</details>

<details>
    <summary><b>Wrapper 클래스와 Boxing, Unboxing 에 대해서 설명해주세요.</b></summary>

> 우선 래퍼 클래스는 기본형 타입을 객체로 감싼 클래스입니다. 프로그래밍을 하다 보면 객체 타입만을 받아야 하는 경우가 있는데, 기본형 타입을 객체 타입으로 취급해야 할 때 사용합니다.  
> 박싱은 기본형 타입을 래퍼 클래스로 감싸는 과정을 의미하고, 언박싱은 래퍼 클래스를 기본형 타입으로 꺼내는 과정을 의미합니다.

- 래퍼 클래스란 원시 타입의 데이터를 객체로 감싼 클래스입니다. 
  - 프로그래밍을 하다 보면 객체 타입만을 받을 수 있는 경우가 있는데, 원시 타입을 객체로 취급해야 할 때 사용합니다.
- 래퍼 클래스의 값을 변경할 수 없습니다. 값이 바뀌길 원한다면 새로운 값을 감싼 래퍼 클래스를 생성해야 합니다.
- 박싱은 원시 타입을 래퍼 클래스로 감싸는 과정을 의미하고, 언박싱은 래퍼 클래스를 기본형 데이터로 꺼내는 과정을 의미합니다.
- 꼬리질문
  - 오토박싱이라는 키워드에 대해 설명해주세요
  - JDK 1.5 부터는 박싱, 언박싱을 명시적으로 해주지 않아도 자동으로 해당 작업을 해주는 오토박싱, 오토언박싱이 가능합니다.
    - 오토박싱은 원시 타입의 데이터를 래퍼 클래스에 대입할 때 이루어집니다. 
    - 오토 언박싱은 래퍼 클래스의 값을 원시 타입으로 변환할 때 이루어집니다.
    - 오토박싱은 언뜻보면 원시 값을 편리하게 래퍼 클래스로 사용할 수 있어보이지만, 내부적으로는 객체 생성과 같은 비용이 나가는 동작이 포함되어있기 때문에, 의도하지 않은 오토박싱을 없애야 합니다.
</details>

---

<details>
    <summary><b>Java는 Call by Value인가요 Call by Reference인가요?</b></summary>

> 자바는 Call by Value입니다. 우선 기본형 타입을 전달할 때는 그 값을 복사해서 전달합니다.   
> 그리고 자바에서 래퍼런스 타입을 파라미터로 넘길 때, 레퍼런스 자체를 전달하는 것이 아니라 레퍼런스가 저장된 메모리 주소를 복사해서 전달합니다.  
> 그렇기 때문에, 메서드 내부에서 레퍼런스 타입의 파라미터를 재할당 한다고 해도, 메서드 밖의 원본에는 영향이 가지 않습니다.
> 이런 이유로, Call by Value입니다.

- Java는 모든 타입이 Call by Value로 동작합니다. 
  - C와 다르게 Java는 Reference Type을 전달할 때 레퍼런스 자체를 전달하는 것이 아니라, 레퍼런스가 저장된 메모리 주소를 복사해서 전달합니다.
  - 그렇기 때문에, 메서드 내부에서 reference type 파라미터에 객체를 재할당 한다고 해도, 원본에는 영향이 가지 않습니다.
</details>

---

<details>
    <summary><b>Java 의 접근제어자는 어떤 것이 있나요?</b></summary>

> Java의 접근 제어자에는 private, default, protected, public이 있습니다.  
> private은 멤버가 속한 클래스에서만 접근할 수 있게 하는 접근 제어자입니다.  
> default는 별다른 접근 제어자를 선언하지 않았을 때 적용되고, 클래스와 클래스가 속한 패키지 내부에서만 접근 가능합니다.  
> protected는 default 접근 제어자가 가능한 범위에 해당 클래스를 상속한 자식 클래스까지 접근을 허용합니다.  
> public은 프로젝트의 모든 클래스에서 접근 가능합니다.

- 접근 제어자란 클래스 멤버의 외부에서의 접근을 제어하는 키워드입니다. 
- 접근 제어자에는 private, default, protected, public 의 4가지가 존재합니다.
  - private 은 외부에서의 접근을 할 수 없도록 하는 접근 제어자입니다. 
  - default 접근 제어자는 Java에서 지원하는 기본 접근 제어자로, 별다른 접근 제어자를 선언하지 않으면 자동으로 default 접근 제어자가 적용됩니다. 같은 클래스 내부에서, 그리고 같은 패키지 내부의 다른 클래스에서 접근 가능합니다.
  - protected 은 default 접근 제어자의 적용 범위에서 상속받은 자식 클래스 까지 접근을 허용하는 접근제어자 입니다.
  - public 은 프로젝트 내부의 어디에서든 접근할 수 있는 접근 제어자입니다.
- 인터페이스의 메서드에 접근제어자를 붙여주지 않게 되면 접근 범위는 어떻게 되나요?
</details>

---

<details>
    <summary><b>클래스, 객체, 인스턴스를 비교해주세요.</b></summary> 

> 클래스란 서로 연관된 필드와 메서드로 이루어진 객체의 설계도라고 할 수 있습니다.  
> 객체는 클래스의 설계대로 구현될 대상을 의미합니다.  
> 인스턴스는 클래스를 통해서 구체화된 각각의 실체를 의미합니다.

- 클래스란 연관된 필드와 메서드로 이루어진 객체의 설계도라고 할 수 있습니다.
- 객체는 클래스의 설계대로 구현해야 할 대상을 의미합니다.
- 인스턴스는 클래스를 통해서 구체된화 각각의 실체를 의미합니다.
</details>

---

<details>
    <summary><b>static 키워드에 대해 설명해주세요.</b></summary> 

> static 멤버를 선언하면, 클래스가 로드되는 시점에 같이 초기화 되어서 인스턴스 생성 없이 사용할 수 있습니다.  
> 또한 static 멤버는 스태틱 영역에 생성되기 때문에, 모든 객체들이 공유할 수 있습니다. 그리고 처음 메모리에 할당되면 프로그램이 종료될 떄 까지 할당된 채로 존재합니다.

- 클래스에서 static 멤버를 선언하면, 해당 클래스가 Method 영역 메모리에 적재되는 시점에 같이 초기회되어 모든 객체가 공유할 수 있습니다.
- static 멤버는 처음 메모리에 적재되면 프로그램이 종료될 때 까지 할당된 채로 존재합니다.
</details>

<details>
    <summary><b>static 멤버와 non-static 멤버는 무슨 차이가 있나요?</b></summary>

> static 멤버는 클래스당 한번 생성됩니다. 그리고 Method 영역에 할당됩니다. 따라서 static 멤버는 인스턴스가 생성되지 않고도 사용할 수 있고, 모든 객체가 공유할 수 있습니다. 하지만 GC의 관리를 받을 수 없습니다.  
> non-static 멤버는 객체마다 각각 생성됩니다. 그리고 객체가 생성될 때 heap 영역에 할당됩니다. 객체가 사라지면 non-static 멤버도 함께 사라지고, GC의 관리를 받을 수 있습니다.

- 생성 시점
  - static 멤버는 클래스당 한번 생성됩니다. 
  - 하지만 non-static 멤버는 클래스의 인스턴스마다 생성됩니다. 
- 메모리 영역
  - static 멤버는 JVM 메모리의 Method 영역에 적재됩니다. 따라서 static 멤버는 인스턴스가 생성되기 전에도 사용할 수 있습니다. 대신 프로그램이 종료될 때 까지 존재합니다.
  - 하지만 non-static 멤버는 인스턴스화될 때 Heap 영역에 할당됩니다. 그래서 GC의 관리를 받을 수 있다는 장점이 있습니다. 객체가 사라지면 non static 멤버도 사라집니다.</p>
- 꼬리질문
  - 그럼 non-static 멤버는 메모리 공간의 어디에 저장되나요?
  - non-static inner 클래스와 static inner 클래스의 차이점은 무엇인가요?
    - non-static inner가 인스턴스화되기 위해서는 먼저 바깥 클래스를 인스턴스화되어야 하고, 이 과정에서 클래스 외부 참조가 생깁니다. 그렇기 때문에 외부 클래스가 더이상 사용되지 않아도 내부 클래스가 유지된다면 GC의 대상이 되지 않습니다  
    - static inner 클래스는 외부 참조가 없기 때문에, 내부 참조를 생성하기 위해 일회용으로 생성된 바깥 클래스는 GC의 대상이 되어 제거됩니다.
  - static 메서드는 오버라이딩될까요?
    - 되지 않습니다. static 메서드는 컴파일 시점에 어떤 타입의 메서드가 실행될지 정해집니다. 
    - 반면에 오버라이딩된 메서드는 런타임 시점에 어떤 타입의 메서드가 실행될 지 결정됩니다.
    - 메서드가 실행될 시점이 서로 다르기 때문에 static과 오버라이딩은 어울릴 수 없습니다.
</details>

<details>
    <summary><b>main 메서드는 왜 static 메서드인가요?</b></summary> 

> main 메서드는 프로그램의 시작점이기 때문에, main 메서드가 선언된 클래스가 인스턴스화되지 않고 실행되어야 합니다. 그렇기 때문에 main 메서드는 static이어야 합니다.

- main 메서드는 프로그램의 시작점입니다. main 메서드가 선언된 클래스가 인스턴스화되지 않고 실행되어야 하기 때문에 main 메서드는 static이어야 합니다.
</details>

<details>
    <summary><b>컴파일 시 static 이 붙은 변수는 어떻게 처리되나요?</b></summary>

> static 변수는 클래스 로딩 시점에 Method 영역에 초기화됩니다.

- static 변수는 클래스 로딩 시점에 Method 영역에 초기화됩니다.
</details>

---

<details>
    <summary><b>오버로딩과 오버라이딩을 비교해주세요.</b></summary> 

> 오버로딩은 메서드의 이름은 동일하지만, 파라미터의 종류와 개수를 다르게 하여 정의하는 방식입니다.  
> 그리고 오버라이딩은 부모 클래스 혹은 인터페이스의 메서드를 동일한 시그니처로 재정의하는 방식을 의미합니다.

- 오버로딩은 메서드의 이름은 동일하지만, 파라미터의 종류와 개수를 다르게 하여 정의하는 방식입니다.
- 그리고 오버라이딩은 부모 클래스 혹은 인터페이스의 시그니처가 동일한 메서드를 재정의하는 방식입니다.
  - 오버라이딩 한 메서드의 리턴 타입은 부모 클래스의 메서드 리턴 타입과 동일해야 하거나, 리턴 타입의 자식 클래스여야 합니다.
</details>

---

<details>
    <summary><b>인터페이스와 추상클래스를 비교해주세요.</b></summary> 

- 추상 클래스
  - 추상클래스는 abstract 키워드가 붙은 클래스를 의미합니다.  
  - 추상 메서드가 없어도 추상 클래스로 만들 수 있지만, 추상 메서드가 있다면 반드시 추상 클래스로 선언해야 합니다.  
  - 추상 메서드의 목적은 인스턴스를 생성하기 위함이 아니라, 상속을 위한 부모 클래스로 활용하기 위합입니다.
  - 추상클래스는 클래스들이 공통 멤버(필드, 메서드)들이 많아서 공통점들을 상위 클래스로 추상화하고 싶을 때 사용합니다. 
- 인터페이스
  - 인터페이스는 interface 키워드로 생성하고, 상수와 추상 메서드, 혹은 default 메서드만을 가지고 있습니다.
  - 인터페이스는 구체 클래스가 같은 동작을 한다는 것을 보장하기 위해 사용합니다. 혹은 다중 상속을 하고 싶을 때 사용합니다.
- 꼬리 질문
  - 추상 메서드?
  - 어느 상황에 추상 클래스를 사용하고, 어느 상황에 인터페이스를 사용할 것 같나요?(본인 생각)
</details>

<details>
    <summary><b>클래스는 왜 다중 상속을 허용하지 않을까요?</b></summary> 

- 자바는 클래스의 다중 상속 시 생기는 다이아몬드 문제를 언어적으로 막기 위해 다중 상속을 허용하지 않았습니다.  
  - 다이아몬드 문제란, 상속구조가 다이아몬드 형태로 이루어져 있을 때 부모 클래스 두 곳에서 모두 동일한 메서드를 오버라이딩했다면, 어느 쪽 메서드를 호출해야 할지 몰라 충돌이 발생하는 문제입니다.  
  - 인터페이스는 다중 상속을 지원합니다. 상위 여러 인터페이스를 다중 상속받아도 상위 인터페이스의 메서드는 구체화가 되어있지 않기 때문에, 다이아몬드 문제가 발생하지 않습니다.
  - 다만 default 메서드로 이루어져 있을 경우에는, 인터페이스를 구현하는 쪽에서 상위 인터페이스의 메서드를 호출하는 식이 아니라, 직접 메서드를 구현해야 합니다.
</details>

---

<details>
    <summary><b>Java의 Error, Exception 구조에 대해 설명해주세요.</b></summary>

- 우선 Error와 Exception은 Throwable 를 상속받고 있습니다.  
- Throwable 클래스는 getMessage와 printStackTrace 메서드가 있습니다.
- 따라서 에러와 예외는 공통적으로 발생한 오류 상황에 대한 메세지를 관리하고, 오류의 원인들을 연결해서 출력하는 기능을 갖고 있습니다.

- 꼬리 질문
  - Error와 Exception의 차이는 뭘까요?
    - Error는 프로그래머가 대처하기 어려운 오류를 의미합니다. 대표적으로 StackOverFlow와 OutOfMemory 에러가 있습니다.  
    - Exception은 프로그래머가 대처할 수 있고, 혹은 직접 발생시켜 프로그램의 흐름을 제어할 수 있는 오류를 의미합니다. 대표적으로 NPE가 있습니다.   
     
</details>

<details>
    <summary><b>CheckedException 과 UncheckedException 은 무슨 차이인가요?</b></summary> 

- CheckedException은 컴파일 시점에 해당 예외를 catch하는지 확인합니다.  
  - 해당 예외를 잡지 않으면 컴파일 에러가 발생하기 때문에, 반드시 예외를 해결하도록 강제합니다.  
- UncheckedException은 컴파일 시점에 해당 예외를 체크하지 않습니다.
  - 해당 예외를 잡아서 처리해도 되고, 잡지 않아도 됩니다.
  - 개발자의 실수, 혹은 사용자의 실수에 의해 예외가 발생할 경우 처리를 위임하는 방식으로 사용할 수 있습니다.  

- 꼬리 질문
  - 지원자님은 Checked와 Unchecked 중에 어떤 예외를 선호하시나요? 이유와 함께 설명해주세요 
</details>

<details>
    <summary><b>예외처리의 세 가지 방법을 설명해주세요.</b></summary>

- 첫 번째 방법은 예외를 복구하는 방법입니다. 예외가 발생하면 문제를 해결해서 정상적인 상태로 되돌려 놓는 방법으로, 예외가 발생해도 어플리케이션은 정상적으로 동작합니다.  
- 두 번째 방법은 예외를 회피하는 방법입니다. 예외를 처리하지 않고 호출한 쪽으로 예외를 전달하는 방식으로, 호출한 쪽에서 처리하는 것이 최선일 때 사용하는 것이 좋습니다.  
- 세 번째 방법은 예외를 전환하는 방법입니다. 예외를 처리하지 않지만 적절한 예외로 변환해서 던지는 방법입니다. 좀 더 명확한 의미로 예외를 발생시키기 위한 방법입니다.
</details>

---

<details>
    <summary><b>final 키워드는 왜 사용할까요? 어떤 이점이 있을까요?</b></summary> 

- final 키워드는 상태를 변경시킬 수 없게 만들기 위해 사용합니다.
  - final 변수를 선언할 경우, 한번 초기화된 경우 변수가 저장하는 값을 변경할 수 없습니다.
  - final 메서드를 선언할 경우, 하위 클래스가 해당 메서드를 오버라이딩 할 수 없습니다.
  - final 클래스를 선언할 경우, 해당 클래스는 상속 불가능한 클래스가 됩니다.
- 객체 세상에서 final을 사용하는 이유를 생각해보면, 변경 가능성을 최소화한다는 이점이 있습니다. 
  - final 키워드를 사용하면, 해당 변수는 상수로서 존재하기 때문에, 상태값을 추적할 필요가 사라집니다.
  - 이를 통해 코드의 사이드이펙트를 줄이고, 디버깅 시 이점을 줄 수 있다고 생각합니다.

- 꼬리 질문
  - 불변 객체의 장단점(이펙티브 자바 - 아이템 17)
</details>


<details>
    <summary><b>final, finally, finalize 에 대해 설명해주세요</b></summary> 

- final은 변수, 메서드, 클래스 등에 선언하여 변경되거나 오버라이딩, 상속될 수 없음을 명시하는 키워드입니다.
- finally는 try - catch 구문 동작 이후 꼭 실행되어야 할 동작을 작성하는 코드 구문입니다.
- finalize는 GC가 해당 객체가 더이상 참조되지 않는다고 판단할 때 호출하는 메서드입니다.
</details>

<details>
    <summary><b>final 키워드는 컴파일 과정에서 다르게 실행될까요?</b></summary> 

- final 변수를 참조하고 있는 java 파일이 컴파일되면 해당 참조를 상수로 변환하여 컴파일합니다.
</details>

---

<details>
    <summary><b>제네릭에 대해 설명해주세요.</b></summary> 

- 제네릭은 타입 안정성을 높여주고 형변환의 번거로움을 줄여주는 기능입니다.
  - 제네릭이 있기 전에는 컬렉션에서 객체를 꺼낼 때 마다 형변환을 해주어야 했고, 잘못된 타입을 넣었다면 형변환 시 오류가 발생했습니다.
  - 하지만 제네릭을 사용하게 되면서 컬렉션이 담을 수 있는 타입을 컴파일러에게 알려줘서, 형변환 체크를 컴파일 시점에 할 수 있게 되었습니다.
    ```java
    List numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
    int sum = 0;
    for (Object number : numbers) {
      sum += (int) number;
    }
    
    List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6); // 잘못된 타입이 들어왔다면 컴파일 시점에 이를 검사할 수 있음
    int sum = 0;
    for (Integer number : numbers) {
      sum += number; // 불필요한 형변환이 사라짐
    }
  ```

- 꼬리 질문
  - 와일드카드에 대해서 설명해주세요
</details>

---

<details>
    <summary><b>리플렉션이 무엇이고, 언제 활용 가능한지 설명해주세요.</b></summary> 

- 리플렉션은 메모리에 올라와있는 클래스에 대한 정보들을 가져오는 기능입니다.  
- 리플렉션 API는 Class 인스턴스를 통해 사용할 수 있습니다. 클래스 객체를 통해서 생성자, 메서드, 필드, 어노테이션 등의 정보를 가져올 수 있습니다.  
- 단순히 정보를 가져오는 것 뿐만 아니라, 클래스의 인스턴스를 만들고, 메서드를 실행하며, 필드의 값을 변경할 수도 있습니다.  
- 그리고 클래스의 요소들이 private로 감춰져 있다고 해도, 해당 요소의 접근 가능 여부를 변경하여 직접 접근할 수도 있습니다.  
- 작성 시점에는 어떤 클래스를 사용해야 할지 모르지만, 런타임 시점에서 클래스를 실행해야 할 경우에 사용합니다.

- 꼬리 질문
  - Spring 에서 리플렉션이 사용되는 예시를 설명해주세요
  - Spring의 DI에서 리플렉션이 사용됩니다.
</details>

<details>
    <summary><b>리플렉션의 장단점에 대해 설명해주세요.</b></summary> 

- 장점
  - 리플렉션은 클래스의 타입을 알지 못해도, 이를 런타임 시점에 동적으로 생성하고 조작하는 등의 유연한 프로그래밍이 가능합니다.  
    - 이런 장점을 활용하여 프레임워크, 라이브러리, 디버깅 및 테스트 도구 등을 설계합니다. 사용자가 어떤 클래스를 만들지 알 수 없기 때문입니다.  
- 단점
  - 런타임 시점에 클래스에 대한 정보를 가져오므로 성능 이슈가 있습니다.  
  - 또한 private로 감춰져 있는 필드, 메서드들을 그대로 갖고 올 수 있으므로, 내부가 노출되면서 추상화가 깨집니다.  
  - 이런 이유들로, 개발자를 위한 도구를 만드는 등 리플렉션을 사용해야만 하는 경우가 아니라면 사용하지 않는 것이 좋다고 생각합니다.
</details>

---

<details>
    <summary><b>자바의 직렬화와 역직렬화에 대해 설명해주세요.</b></summary> 
</details>

---

<details>
    <summary><b>자바의 Synchronized 키워드를 설명해주세요.</b></summary> 
</details>

<details>
    <summary><b>동기화와 비동기화의 차이를 설명해주세요.</b></summary> 
</details>

<details>
    <summary><b>동시성 문제가 무엇인가요? 자바에서 동시성 문제를 해결할 수 있는 방법이 있을까요?</b></summary> 
</details>

---

<details>
    <summary><b>자바의 어노테이션에 대해 설명해주세요.</b></summary> 
</details>

