<details>
    <summary><b>Java 의 장단점에 대해 설명해주세요.</b></summary> 

> 👉 자바의 장점은 JVM 위에서 프로그램이 실행되므로 운영체제에 독립적이고, 객체지향언어로써 기존 코드의 재사용이 편리하다는 장점이 있습니다. 또한 변경사항이 생기면 해당 클래스만 수정하면 되기 때문에, 유지 보수가 쉽고 빠릅니다. 단점으로는 C/C++ 같은 컴파일 언어 대비 비교적 실행속도가 느리다는 단점이 있습니다.  

- 장점
    - 운영체제에 독립적
        - JVM 위에서 동작하므로 플랫폼에 종속적이지 않음(운영체제가 달라져도 추가적인 작업 불필요)
    - 객체지향적인 언어
        - 기존 코드를 재사용 가능하고 모듈식 프로그램을 개발 가능
    - 동적 로딩을 지원
        - 애플리케이션 실행시점에 모든 객체가 생성되는 것이 아닌, 객체가 필요할 때 클래스를 동적으로 로딩
        - 변경사항이 생기면 해당 클래스만 수정하면 되기 때문에, 전체 애플리케이션 컴파일 불필요. 유지보수가 쉽고 빠름
- 단점
    - C/C++ 과 같은 컴파일 언어 대비 실행 속도가 비교적 느림
        - Java는 컴파일 후 바이트 코드가 생성되고 JVM에서 기계어로 번역되고 실행되는 과정을 거치므로 컴파일언어 대비 실행속도가 비교적 느림

</details>

---

<details>
    <summary><b>Java 의 데이터 타입에 대해 설명해주세요.</b></summary>

> 👉 자바의 자료형은 기본형과 참조형이 있습니다. 기본형 같은 경우 int, char 등 총 8개의 자료형이 있으며, 크기가 작고 고정적이므로 메모리의 스택 영역에 저장됩니다. 기본형을 제외한 나머지 자료형은 모두 참조형입니다. class, array, interface 등이 참조형에 해당하며 크기가 가변적이고 동적이므로, 동적으로 관리되는 메모리의 힙 영역에 저장됩니다.   

- 기본 데이터 타입
    - 기본형으로는 int, char, boolean 등이 있다.
        - 정수형: byte, short, int, long
        - 실수형: float, double
        - 논리형: boolean(true/false)
        - 문자형: char
    - 기본형은 크기가 작고 고정적이므로 메모리의 Stack 영역에 저장된다.
- 참조 데이터 타입
    - 기본형을 제외하고는 모두 참조형
    - new 키워드를 이용해 객체를 생성하고, 데이터가 생성된 주소를 참조하는 타입
        - String 과 배열은 new 키워드 없이 생성가능하지만 참조 데이터 타입이다.
    - 참조타입의 종류는 class, array, interface, Enumeration 등이 있음
    - 참조형 데이터는 크기가 가변적이고 동적이므로, 동적으로 관리되는 메모리의 Heap 영역에 저장됨
        - **_데이터는 Heap 영역에 저장되지만 메모리의 주소값은 Stack 영역에 저장된다._**
    - 데이터를 더 이상 참조하는 변수가 없을 때 가비지 컬렉션에 의해 삭제된다.

---

</details>

<details>
    <summary><b>Wrapper 클래스와 Boxing, Unboxing 에 대해서 설명해주세요.</b></summary>

> 👉 Wrapper 클래스란, 기본 자료형의 데이터를 객체로 포장해주는 클래스입니다. java.lang 패키지에 기본 자료형 8개와 매핑되는 래퍼 클래스가 있습니다. 산술 연산을 위해 정의된 클래스가 아니므로 인스턴스에 저장된 값이 불변이라는 특징이있습니다. 기본형 데이터를 참조형 데이터로 변환하는 것을 박싱, 참조형 데이터를 기본형 데이터로 변환하는 것을 언박싱이라고 합니다.

### Wrapper 클래스 
  - **기본 타입의 데이터를 객체로 포장해주는 클래스**
  - 기본 타입의 데이터를 객체로 취급해야하는 경우 사용한다.
    - 예) 매개변수로 객체를 요구할 때, 기본형 값이 아닌 개체로 저장해야할 때 등
  - java.lang 패키지에 기본 데이터 타입 8개와 매핑되는 Wrapper 클래스가 존재
  - Wrapper 클래스는 산술 연산을 위해 정의된 클래스가 아니므로, 인스턴스에 저장된 값을 변경할 수 없다.

### Boxing, Unboxing 

- Boxing 
  - **기본 타입의 데이터를 Wrapper 클래스의 인스턴스로 변환하는 과정**
- Unboxing
  - **Wrapper 클래스의 인스턴스에 저장된 값을 기본 타입의 변수에 할당하는 과정**

### AutoBoxing

- **JDK 1.5부터 박싱과 언박싱 과정이 자동으로 처리되는데 이를 autoboxing 이라 한다.**
- 오토박싱은 컴파일 시에 처리 코드가 자동으로 생성되어서 이루어진다.

```java
int n1 = 10; 
Integer obj1 = n1; // 오토박싱. Integer obj1 = Integer.valueOf(n1);
```

```java
Integer obj2 = Integer.valueOf("20");
int n2 = obj2; // 오토언박싱. int n2 = obj2.intValue(); 
```

- Wrapper 클래스와 기본 데이터의 연산도 가능하다. (Wrapper 클래스는 내부적으로 기본 데이터로 변경되어 처리되기 때문)
    ```java
    Integer obj3 = 30; // Integer obj3 = Integer.valueOf(30);
    int n3 = obj + 40; 
    ```

<br>

(참고) Java의 Wrapper class

기본 타입	| 래퍼 클래스
---|---
`byte`|`Byte`
`short`|`Short`
`int`|`Integer`
`long`|`Long`
`float`|`Float`
`double`|`Double`
`char`|`Character`
`boolean`|`Boolean`


</details>

---

<details>
    <summary><b>Java는 Call by Value인가요 Call by Reference인가요?</b></summary> 

<br /> 

> 👉 자바는 메서드 호출 시에 Call by Value 방식을 사용하고 있습니다. 데이터 타입이 기본형인 경우 원시값을 복사해서 인자로 전달하고, 참조형인 경우 주소값을 복사해서 인자로 전달합니다. 이 때문에 함수 안의 지역 변수가 변경되어도 외부 변수의 값은 변경되지 않는다는 특징이 있습니다.    

- Java 에서는 메서드를 호출 시 새롭게 지역 변수를 만들어서 값만 복사하고 할당하는 방식이므로, 항상 Call by Value 이다.
    - value 는 기본형 데이터 타입의 값 또는 객체의 주소값
    - 기본 자료형의 경우 변수의 값을 복사해서 인자로 전달
    - 참조 자료형의 경우 객체의 주소값을 복사해서 인자로 전달

---

- **Call by Value**
    - 함수 호출 시 ***인자로 전달되는 변수의 값을 복사하여 함수의 인자로 전달***하는 방식
        - 호출자의 변수와 수신자의 파라미터는 복사된 서로 다른 변수
    - 함수 안에서 지역변수가 변경되어도 외부 변수의 값은 변경되지 않는다.

- **Call By Reference**
    - 함수 호출 시 인자에 참조를 직접 전달하는 방식
        - **호출 쪽의 변수와 수신자의 파라미터는 완전히 동일한 변수**
    - 메서드 내에서 파라미터 변경 시 원본 변수도 변경

</details>

---

<details>
    <summary><b>Java 의 접근제어자는 어떤 것이 있나요?</b></summary> 

> 👉 접근 제어자는 클래스, 변수, 메서드 등 각 요소에 대한 접근 권한을 조절하는 방법입니다. 조건 없이 무조건 접근 가능한 public, 같은 패키지 내에 있거나 상속 받은 경우에만 접근 가능한 protected, 같은 패키지 내에서만 접근 가능한 default, 같은 클래스 내에서만 접근 가능한 private 이 있습니다. 

### 접근 제어자

- 접근 제어자
  - 개발할 때, 코드의 어떤 부분은 외부에서 사용할 수 있도록 공개하고 어떤 부분은 비공개로 해서 데이터를 보호해야함. 즉 `접근 제어자`는 각 요소에 접근 권한을 조절하는 방법
  - 클래스와 필드, 메서드 선언시 지정 가능 
- 접근 제어자 종류
  - `public` : 조건 없이 무조건 접근 가능
  - `protected` : 같은 패키지 내에 있거나 상속받은 경우에만 접근 가능
  - `default` : 같은 패키지 내에 있을 때만 접근 가능
  - `private` : 같은 클래스 내에서만 접근 가능

### 패키지 

- 패키지 
  - 클래스를 관리하는 방법이며, 물리적으로는 파일 시스템의 디렉터리를 의미
  - 애플리케이션을 개발할 때 클래스들을 분류하지 않으면 이름이 중복되거나, 어떤 클래스가 어떤 일을 하는지 혼동되는 일이 발생. 따라서 패키지가 필요.
  
</details>

---

<details>
    <summary><b>클래스, 객체, 인스턴스를 비교해주세요.</b></summary> 


 > 👉 객체는 소프트웨어 세계에 구현할 대상이고, 이를 구현하기 위한 설계도가 클래스입니다. 이 설계도에 따라 소프트웨어 세계에 구현된 실체가 인스턴스입니다.  


- 클래스
  - 객체를 만들어 내기 위한 `설계도`, 또는 `틀`
  - 연관관계가 있는 변수와 메서드의 집합 
- 객체
  - 소프트웨어 세계에 구현할 `대상`
  - OOP 관점에서 클래스의 타입으로 변수가 선언되었을 때를 `객체`라고한다.
  - 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖음 
- 인스턴스
  - 설계도를 바탕으로 소프트웨어 세계에 구현된 실체
  - 객체가 메모리에 할당되어 실제 사용될 때를 인스턴스라고 부른다.

```java
public class Animal { // 클래스
    ...
}

public class Main {
	
    public static void main(String[] args) {
	    
        Animal cat, dog; // 객체
        
        // 인스턴스화
        cat = new Animal(); // cat은 Animal 클래스의 '인스턴스'(객체를 메모리에 할당)
        dog = new Animal(); // dog은 Animal 클래스의 '인스턴스'(객체를 메모리에 할당)
    }
}
```

Q. 클래스 vs 객체

- 클래스는 설계도, 객체는 설계도를 따라 구현한 모든 대상을 의미

Q. 객체 vs 인스턴스

- 클래스의 타입으로 변수가 선언될 때를 객체, 객체가 메모리에 할당되어 실제 사용할 때를 인스턴스라고 한다.
- 객체는 현실세계에 가깝고, 인스턴스는 소프트웨어 세계에 가깝다. 

※ Reference
- http://cerulean85.tistory.com/149

</details>

---

<details>
    <summary><b>static 키워드에 대해 설명해주세요.</b></summary> 

> 👉 
> - 자바에서 static 키워드를 사용하는 것은 클래스가 로드될 때 메모리에 단 한 번만 할당되어 프로그램이 종료될 때 메모리에서 해제됨을 의미합니다. 단 가비지 컬렉션에 의해 직접적으로 관리되지 않으므로 시스템 퍼포먼스를 고려하여 사용할 필요가 있습니다.
> - static 은 변수나 메서드, 특정 코드블럭 앞에 선언할 수 있으며, 이 중 static 멤버는 클래스당 하나만 생성되며, 같은 클래스의 모든 인스턴스가 공유한다는 특징을 가집니다.

</details>

<details>
    <summary><b>static 멤버와 non-static 멤버는 무슨 차이가 있나요?</b></summary>

> 👉 `non-static` 멤버는 객체마다 별도로 존재하고 객체간 공유되지 않습니다. 객체가 생성될 때 같이 생성되고 삭제 시 같이 삭제됩니다. 반면에 `static` 멤버는 클래스 당 하나만 생성되고 같은 클래스의 모든 객체에 의해 공유됩니다. 클래스 로딩 시에 멤버가 생성되며, 프로그램 종료 시에 삭제됩니다.

- `non-static` 멤버
  - 공간적 특성
    - 멤버가 객체마다 별도로 존재
    - `인스턴스 멤버` 라고 부른다.
  - 시간적 특성
    - 객체와 생명 주기가 동일하다.
  - 공유의 특성
    - 객체 간 공유되지 않는다. 
    - 멤버는 객체 내에서 각각의 공간을 차지

- `static` 멤버
  - 공간적 특성
    - 멤버가 클래스당 하나만 생성된다.
    - `클래스 멤버`라고 부른다.
  - 시간적 특성
    - **_클래스 로딩 시에 멤버가 생성된다._**
    - 객체의 생성 여부와 상관없이 사용 가능.
    - 프로그램이 종료될 때 삭제된다.
  - 공유의 특성
    - 동일한 클래스의 모든 객체에 의해 공유된다.

_※ 클래스의 `멤버`란?_
- 속성을 표현하는 `필드`와 기능을 표현하는 `메서드`를 일컬어 '멤버'라고 한다. 

_※ 인스턴스의 메서드는 힙 메모리에 만들어지지 않는다._

- 메서드 코드는 실행 시작 시점에 클래스 로더에 의해 `코드 영역`에 만들어지고 이후 다시 메모리에 만들어지지 않는다.
- 인스턴스 메서드는 코드 영역에 생성된 내용을 사용한다.
- 인스턴스 변수만 힙 메모리에 생성된다. 

</details>

<details>
    <summary><b>main 메서드는 왜 static 메서드인가요?</b></summary> 

> 👉 static 멤버는 프로그램 시작 시 메모리에 로드되어 인스턴스를 생성하지 않고 사용이 가능합니다. JVM은 인스턴스를 생성하지 않은 채 클래스의 main 메서드를 호출해야하기 때문에 main 메서드는 static 이어야 합니다. 

- `static` 키워드
  - static 멤버는 클래스 로딩(프로그램 시작) 시에 메모리에 로드되므로, 인스턴스 생성없이 호출 가능하다.
- JVM 이 main 메서드를 실행하는 과정 
  - 컴파일을 실행하면 컴파일러가 .java 파일을 .class 바이트 코드로 변환
  - 클래스 로더가 .class 파일을 메모리 영역에 로드
  - 메모리의 Runtime Data Area 중 메서드 영역(=Class Area, Static Area)에 클래스 변수들이 저장되는 데, static 멤버도 여기에 포함
  - JVM은 메모리의 메서드 영역에 로드된 main()을 실행

</details>

<details>
    <summary><b>자바 프로그램 실행 시 static 이 붙은 변수는 어떻게 처리되나요?</b></summary>

> 👉 먼저 static 변수를 호출하게 되면 클래스로더가 해당 클래스를 메모리의 Runtime Data Area 에 로드합니다. 클래스가 로드되면서 static 변수는 코드 영역에 저장되고, 초기화 됩니다. 마지막으로 초기화가 완료된 후의 static 변수를 사용하게 됩니다. 

- static 변수 호출 
- 클래스 로더가 해당 클래스 파일을 가져와서 JVM의 메모리에 로드 (동적 로딩)
- 이 때 static 변수를 메모리의 Runtime Data Area의 코드 영역에 저장하고 초기화.
- static 변수 사용

📄 **Ref**

- [클래스는 언제 메모리에 로딩 & 초기화 되는가](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EC%96%B8%EC%A0%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90-%EB%A1%9C%EB%94%A9-%EC%B4%88%EA%B8%B0%ED%99%94-%EB%90%98%EB%8A%94%EA%B0%80-%E2%9D%93)

</details>

---

<details>
    <summary><b>오버로딩과 오버라이딩을 비교해주세요.</b></summary> 

> 👉 
> - 오버로딩을 메서드를 확장하기 위한 기능입니다. 메서드의 이름은 같지만 매개변수의 자료형이나 개수가 다른 경우가 오버로딩에 해당합니다. 
> - 오버라이딩은 기존의 메서드를 덮어쓰기 위해서 사용합니다. 부모 클래스의 메서드 시그니처만 가져와 기능을 재정의하는 것을 의미합니다.

- 오버로딩(Overloading)
  - 메서드의 이름은 같지만 매개변수의 자료형이나 개수가 다른 경우 
  - 오버로딩 조건
    - 메서드의 이름은 같아야 한다.
    - 매개변수의 타입 또는 개수가 달라야한다.
  - **_매개변수의 개수와 타입이 같고 리턴타입만 다른 경우는 오버로딩이 불가능_** 
- 오버라이딩(Overriding) 
  - 부모 클래스의 메소드 시그니처를 복제해서 자식 클래스에서 새롭게 구현
  - 부모 클래스의 기능은 무시하고, 자식 클래스에서 덮어씀
  - **_Overriding을 제대로 구현하려면 접근 제어자, 리턴 타입, 메소드 시그니처(메소드 이름 + 매개변수 타입과 개수)가 모두 동일해야한다._** 

</details>

---

<details>
    <summary><b>인터페이스와 추상클래스를 비교해주세요.</b></summary> 

> 👉 추상 클래스와 인터페이스는 인스턴스를 생성할 수 없고, 상속한 클래스가 메서드를 구현해야한다는 공통점이 있습니다. 둘의 차이점으로는 추상 클래스는 필드와 일반 메서드를 가질 수 있으나 인터페이스는 가질 수 없다는 구조적인 차이가 있습니다. 또, 추상 클래스는 상속을 위한 부모 클래스로 활용하기 위한 클래스로써, 클래스 간의 연관관계를 구축하는 것에 초점을 둡니다. 그러나 인터페이스는 구현한 객체가 같은 동작을 한다는 것을 보장하기 위해 사용된다는 점에서 사용 목적에 대한 차이가 있습니다.

### 추상 클래스

- 개념 
  - abstract 키워드로 선언된 클래스 
- 문법
    - `abstract` 으로 선언된 메서드가 하나라도 있으면 그 클래스는 클래스는 반드시 `abstract class` 으로 선언되어야함
    - 추상 메서드가 0개여도 된다. 
- 목적
  - 인터페이스와 달리 _**클래스 간의 연관관계를 구축**_ 하는 것에 초점을 둔다.
  - 상속을 위한 부모 클래스로 활용하기 위한 클래스
    
### 인터페이스

- 개념 
  - 추상 메서드와 상수만을 포함하고, interface 키워드를 사용하여 선언
- 문법
  - 내부의 모든 메서드는 `public abstract` (추상 메서드)
    - 추상 메서드 말고 `static`, `default`, `private` 을 붙여 구체적인 메서드를 가질 수 있음 
  - 내부의 모든 필드는 `public static final` 상수
  - 클래스에 다중 구현 지원 / **_인터페이스 끼리는 다중 상속 지원_**
- 목적
  - 클래스와 별도로 **_구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용하는 것에 초점을 둔다._**  

### 👉 추상 클래스와 인터페이스 비교

- 공통점
  - 추상 클래스와 인터페이스는 인스턴스 생성 불가
  - 상속한 클래스가 메서드를 구현하도록 책임 위임
- 차이점
  - 구조적 차이 
    - 추상 클래스는 추상 메서드 뿐만 아니라 필드, 메서드 선언 가능하지만 인터페이스는 상수와 추상 메서드만 선언 가능 (Java8 부터는 )
  - 목적의 차이
    - 추상 클래스는 관련성이 높은 클래스 간의 코드 재사용과 확장이 목적(연관관계 구축)
    - 인터페이스는 관련성이 없는 클래스들의 기능이 같은 동작을 한다는 것을 보장하는 것이 목적 

**추상 클래스와 인터페이스 예시**

<img width="749" alt="image" src="https://user-images.githubusercontent.com/65555299/229523228-33992943-65a7-46e0-bb48-7d8f7d8204d9.png">

(사진 출처: [인파님 블로그](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-vs-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0))





※ Ref

- [인터페이스 vs 추상 클래스 차이점 완벽 이해하기](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-vs-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)
- http://alecture.blogspot.com/2011/05/abstract-class-interface.html

</details>

<details>
    <summary><b>클래스는 왜 다중 상속을 허용하지 않을까요?</b></summary>

> 👉 
> 자식 클래스가 어느 부모 클래스의 메서드를 사용해야할지 결정할 수 없는 메서드 충돌 문제가 발생하기 때문입니다. 부모 클래스들이 자신의 부모 클래스의 메서드를 각각 오버라이딩하여 구현한다고 했을 때, 자식 클래스 입장에서는 어느 부모 클래스의 메서드를 사용할지 결정할 수가 없는 상태가 됩니다. 따라서 자바에서는 원천적으로 하나의 클래스만 상속하도록 강제하고 있습니다.

<img width="616" alt="image" src="https://user-images.githubusercontent.com/65555299/229527757-3359f00e-c10c-4e7c-a1ec-b113e28e5dc8.png">

**Q. 인터페이스는 다중 상속이 가능한 이유?**
- 인터페이스는 실제로 구현은 하지 않고 메서드에 대한 정의만 하며, 메서드에 대한 실제 구현은 인터페이스를 구현한 객체가 하기 때문.

※ Ref

- [JAVA-다중상속을-허용하지-않는-이유는-뭘까](https://selfish-developer.com/entry/JAVA-%EB%8B%A4%EC%A4%91%EC%83%81%EC%86%8D%EC%9D%84-%ED%97%88%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EC%9D%B4%EC%9C%A0%EB%8A%94-%EB%AD%98%EA%B9%8C)


</details>

---

<details>
    <summary><b>Java의 Error, Exception 구조에 대해 설명해주세요.</b></summary>

> 👉 모든 객체의 최상의 부모인 Object를 최상위 예외 클래스 Throwable 상속하며, 이 Throwable 을 Exception과 Error 클래스가 상속합니다. 여기서 Error 는 메모리 부족과 같은 애플리케이션에서 복구 불가능한 시스템 예외를 나타냅니다. Exception 은 다시 체크 예외와 언체크 예외로 나눠지는데, Exception의 자식 클래스 중 RuntimeException을 제외한 예외와 Exception을 묶어 체크 예외라 하며, RuntimeException과 그 하위 예외를 언체크 에외라 합니다. 이 중 체크예외는 컴파일러가 체크하는 예외로서, 반드시 예외처리를 해주어야한다는 특징이 있습니다.  

### Exception 

![image](https://user-images.githubusercontent.com/65555299/229536903-8c321347-a4af-4f37-a65c-ffdf6b9cce33.png)

- 구조 
  - 모든 객체의 최상의 부모인 `Object`를 최상위 예외 클래스 `Throwable`이 상속 
  - `Exception` 과 `Error` 클래스가 `Throwable` 을 상속
  - 이 때 Exception 의 자식 예외 중 RuntimeException 을 제외한 자식 클래스와 Exception 예외를 합쳐 `체크 예외`라 하며, *컴파일러가 체크*하는 예외이다.
  - RuntimeException 과 하위 예외를 `언체크 예외`(혹은 런타임 예외)라 한다.
- `Error` : 메모리 부족, 심각한 시스템 오류와 같이 _애플리케이션에서 복구 불가능한 시스템 예외_
  - JVM 내에서 발생하는 에러로서 프로그램 내에서 처리 불가능 
  - 애플리케이션 개발자는 이 예외를 잡으려 해서는 안 됨
  - `Error` 역시 언체크 예외 

※ Ref

- 인프런 김영한님 강의 스프링 DB 2편 


</details>

<details>
    <summary><b>CheckedException 과 UncheckedException 은 무슨 차이인가요?</b></summary> 

> 👉 체크 예외는 컴파일러를 통해 예외 처리가 강제되어 개발자의 실수를 방지할 수 있지만, 언체크 예외는 예외 처리를 무시할 수 있으므로 실수로 예외처리를 누락할 수 있다는 차이가 있습니다. 실제 개발하면서 느꼈던 차이점으로는 체크 예외는 신경쓰고 싶지 않은 예외까지 참조해야 하고, 언체크 예외는 신경쓰고 싶지 않은 예외의 의존관계를 참조하지 않아도 되는 것이 큰 차이로 느껴졌습니다. (~~~)

- 체크 예외
  - 문법 
    - 예외를 잡아서 처리하지 않으면 throws 에 던지는 예외를 선언해야함
  - 장단점
    - 장점: 개발자가 실수로 예외를 누락하지 않아도 컴파일러를 통해 예외 처리를 강제함
    - 단점: 
      - 반드시 모든 체크예외를 잡거나 던져야하므로 번거로움
      - 신경쓰고 싶지 않은 예외까지 참조해야한다.
        > throws를 통해 체크 예외를 넘겨받은 객체 역시 본인이 처리할 수 없으면 throws 를 통해 체크 예외를 던져야한다. 즉, 체크 예외가 발생한 곳 부터 최종적으로 예외를 처리하는 객체까지 중간에 놓인 모든 객체가 해당 예외에 대한 의존성을 갖는다. <br> 👉 _**발생하는 체크 예외가 변경되면 throws XXXExcetpion 코드를 모두 수정해야하는 어려움이 생긴다.**_ 
- 언체크 에외 
  - 문법
    - 예외를 잡아서 처리하지 않아도 throws 생략 가능
  - 장단점
    - 장점: 신경쓰지 않을 언체크 예외는 무시 가능 👉 신경 쓰고 싶지 않은 예외의 의존관계를 참조하지 않아도 된다.
    - 단점: 개발자의 실수로 예외 처리를 누락할 수 있음.


</details>

<details>
    <summary><b>예외처리의 세 가지 방법을 설명해주세요.</b></summary> 

> 👉 예외를 처리하는 방법에는 예외 복구, 예외 처리 회피, 예외 전환이 있습니다.
> 예외 복구는 try-catch 문을 이용하여 발생한 예외를 catch 문에서 처리하는 방법이며
> 예외 처리 회피는 예외가 발생한 곳에서 직접 예외를 처리하지 않고, throws를 통해 호출한 쪽으로 예외 처리의 책임을 위임하는 방법입니다. 마지막으로 예외 전환은 catch 문으로 예외를 잡고, 다른 예외를 발생시켜 catch문 블럭 밖으로 처리의 책임을 위임하는 방법입니다. 

### 예외 처리 3가지 방법
1. 예외 복구  
   - try-catch 문을 이용하여 발생한 예외를 catch 문에서 처리
2. 예외 처리 회피
   - 예외가 발생한 곳에서 직접 예외를 처리하지 않고, throws를 통해 호출한 쪽으로 예외 처리의 책임을 위임하는 방법
3. 예외 전환
   - catch 문으로 예외를 잡고, 다른 예외를 발생시켜 catch문 블럭 밖으로 처리의 책임을 위임하는 방법입니다.

※ Ref 

- [인파 - Exception-Handling-예외를-처리하는-3가지-기법](https://inpa.tistory.com/entry/JAVA-%E2%98%95-Exception-Handling-%EC%98%88%EC%99%B8%EB%A5%BC-%EC%B2%98%EB%A6%AC%ED%95%98%EB%8A%94-3%EA%B0%80%EC%A7%80-%EA%B8%B0%EB%B2%95)

</details>

---

<details>
    <summary><b>final 키워드는 왜 사용할까요? 어떤 이점이 있을까요?</b></summary>

> 👉 final 키워드는 변수 또는 메서드, 클래스가 변경 불가능하다, 읽기 전용이다를 명시적으로 나타내기 위해서 사용합니다. 즉, 변경을 제한함으로써 실수와 버그를 줄이기 위해 사용합니다. 예를 들어 로컬 변수에 final 키워드를 선언함으로써 '이 변수는 절대 변경되어서는 안 되는 값입니다.' 라는 정보를 다른 개발자에게 줄 수 있겠습니다. 다만 무조건 적으로 선언하는 것이 아닌, 가독성 등을 고려한 팀의 합의에 따라 작성해야할 필요가 있겠습니다. 개인적으로는 DTO 등 불변 객체를 만들 때 많이 사용하고 있습니다. 

※ Ref

https://blog.lulab.net/programming-java/java-final-when-should-i-use-it/#fn:3


</details>


<details>
    <summary><b>final, finally, finalize 에 대해 설명해주세요</b></summary>

> 👉 먼저 final 키워드는 변수 또는 메서드 또는 클래스가 변경 불가능하도록 만듭니다. 변수에 적용 시 기본형 변수의 경우 값의 변경이 불가능하며, 참조형 변수의 경우 참조 변수가 힙 메모리 내의 다른 객체를 참조할 수 없도록 만듭니다. 메서드 적용시 오버라이딩이 불가능하며, 클래스에 적용 시에는 해당 클래스를 상속할 수 없게 됩니다. finally 의 경우 try-catch 블록이 종료 될 때 항상 실행될 코드 블럭을 정의하기 위해 사용합니다. finalize 메서드는 가비지 컬렉션이 더 이상 참조되지 않은 객체를 힙 메모리에서 삭제하는 것을 결정하는 시점에 호출됩니다.  

### `final` 키워드

- 개념: 변수 또는 메서드, 클래스가 *변경 불가능*하도록 만든다.
- 변수에 적용 시 
  - 기본형 변수: 해당 변수의 값이 변경 불가능하다.
  - 참조형 변수: 참조 변수가 힙 메모리 내의 다른 객체를 참조하도록 변경 불가능하다.
- 메서드에 적용 시
  - 해당 메서드를 오버라이딩할 수 없다. 
- 클래스에 적용 시
  - 해당 클래스를 상속할 수 없다.

### `finally` 코드 블럭
- 개념: try-catch 블록이 종료될 때 항상 실행될 코드 블럭을 정의하기 위해 사용

### `finalize()` 메서드
- 개념: 가비지 컬렉션이 더 이상 참조되지 않는 객체를 힙 메모리에서 삭제하겠다고 결정하는 시점에 호출된다. 

</details>

<details>
    <summary><b>final 키워드는 컴파일 과정에서 다르게 실행될까요?</b></summary>

> 👉 final 변수의 경우 static 키워드와 같이 사용되는가에 따라 실행과정이 달라집니다. static으로 선언된 변수, 즉 클래스 변수는 초기화 될 때 method area의 Class Variable에 값이 저장됩니다. 이 때 final 로 선언된 변수는 상수로 치환되어 Runtime Constant Pool 에 값이 복사됩니다. 그리고 해당 변수를 사용 시 Constant Pool 에서 값을 읽어들입니다. non-static final 변수의 경우 힙 메모리에 인스턴스가 생성됨에 따라 같이 생성됩니다.   

※ Ref

- https://www.holaxprogramming.com/2013/07/16/java-jvm-runtime-data-area/
- [그래서-static-변수는-어디에-저장되는가](https://velog.io/@this-is-spear/%EA%B7%B8%EB%9E%98%EC%84%9C-static-%EB%B3%80%EC%88%98%EB%8A%94-%EC%96%B4%EB%94%94%EC%97%90-%EC%A0%80%EC%9E%A5%EB%90%98%EB%8A%94%EA%B0%80)
- https://www.baeldung.com/java-compile-time-constants

</details>

---

<details>
    <summary><b>제네릭에 대해 설명해주세요.</b></summary> 

> 👉 제네릭이란 데이터 타입을 매개변수로 지정하는 것을 의미하며, 타입 매개변수는(실행 시 인자로 전달하는 타입을 변수로 지정하는 것) 클래스, 인터페이스, 메서드 에 사용가능합니다. 컴파일러의 타입 검사를 통해 타입의 안정성을 보장받을 수 있으며, 불필요한 타입 캐스팅을 없애줌으로써 성능 향상을 가져옵니다.

- 제네릭 타입의 객체는 생성 불가
- static 멤버에 제네릭 타입이 올수 없음
  -  static 멤버는 클래스가 동일하게 공유하는 변수로서 객체가 생성되기도 전에 이미 자료 타입이 정해져 있어야 하기 때문.

</details>

---

<details>
    <summary><b>리플렉션이 무엇이고, 언제 활용 가능한지 설명해주세요.</b></summary> 

> 👉 리플렉션이란, 런타임에 동적으로 특정 클래스를 인스턴화 함으로써 그 클래스의 정보에 접근할 수 있게 하는 자바 API 입니다. 주로 프레임워크나 라이브러리에서 사용됩니다. 이는 사용자가 어떤 클래스를 만들어 사용할지 프레임워크나 라이브러리는 알 수 없기 때문에, 런타임에 리플렉션 API 를 통해 사용자가 요청한 기능을 수행하게 됩니다.    

- 구체적인 클래스 타입을 알지 못해도 그 클래스의 정보(메소드, 타입, 변수, ...)에 접근할 수 있게 해주는 자바 기법 
- 런타임에 동적으로 특정 클래스를 객체화하여 정보를 분석 및 추출 가능
- 애플리케이션 개발보다는 프레임워크나 라이브러리에서 많이 사용
  - 스프링 어노테이션
  - 롬복
</details>

<details>
    <summary><b>리플렉션의 장단점에 대해 설명해주세요.</b></summary>

> 👉 먼저 장점으로는, 리플렉션을 사용하면 런타임 시점에 사용할 인스턴스를 선택하고 동작시킬 수 있으므로 유연한 프로그래밍이 가능해집니다.
> 
> 단 컴파일 시점에 오류를 확인할 수 없다는 점, 접근제어자로 캡슐화된 필드와 메서드에 접근 가능해진다는 단점이 있습니다. 

</details>

---

<details>
    <summary><b>자바의 직렬화와 역직렬화에 대해 설명해주세요.</b></summary>

> 👉
> 자바 직렬화란, 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 변환하는 기술을 말합니다.   
> 자바 역직렬화란, 직렬화된 바이트 형태의 데이터를 다시 객체로 변환하는 기술입니다.

### 직렬화

- 정의  
  - 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 변환하는 기술 (예: 객체 -> JSON)
  - (시스템 관점) **_JVM의 메모리에 적재(힙 또는 스택)되어 있는 객체 데이터를 바이트 형태로 변환하는 기술_**
  
- 조건
  - 데이터 타입이 기본형(primitive type)이어햐 한다. 
  - `java.io.Serializable` 인터페이스를 상속하는 객체이어야 한다.  
  
- 장점 
  - 자바 직렬화는 자바 시스템에서 개발에 최적화 되어있음
  - 복잡한 데이터 구조를 갖는 클래스의 객체라도, 직렬화의 기본 조건만 지키면 간단하게 직렬화가능함. 역직렬화도 마찬가지. 👉 개발자 입장에서 편하다.
  
- 방법
  - `java.io.ObjectOutputStream` 객체를 이용
  ```java
  public class Member implements Serializable {
  
    private String name;
    private String email;
    private int age;

    public Member(String name, String email, int age) {
        this.name = name;
        this.email = email;
        this.age = age;
    }
  
    // Getter 생략
    @Override
    public String toString() {
        return String.format("Member", name, email, age);
    }
  }
  ```
  ```java
  Member member = new Member("김배민", "deliverykim@baemin.com", 25);
  byte[] serializedMember;
  
  try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
      try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {
          oos.writeObject(member);
          // serializedMember -> 직렬화된 member 객체 
          serializedMember = baos.toByteArray();
      }
  }
  
  // 바이트 배열로 생성된 직렬화 데이터를 base64로 변환
  System.out.println(Base64.getEncoder().encodeToString(serializedMember));
  ```

- 자바의 직렬화랑 문자열 형태의 직렬화는 다르다
  - 문자열 형태의 직렬화: 객체 ➡️ CSV, JSON
  - 자바 직렬화: 객체 ➡️ 바이트 형태의 데이터 
  
### 역직렬화 
- 정의 
  - 바이트로 변환된 데이터를 다시 객체로 변환하는 기술(예: JSON -> 객체)
  - (시스템 관점) 직렬화된 바이트 형태의 데이터를 다시 객체로 변환해서 JVM 메모리에 적재하는 기술 
- 조건
  - 직렬화 대상이 된 객체의 클래스가 클래스패스에 존재해야 하며, import 되어 있어야 한다. 
    - **_직렬화와 역직렬화를 진행하는 시스템이 서로 다를 수 있다는 것을 반드시 고려해야 한다. (같은 시스템 내부더라도 소스 버전이 다를 수 있다.)_** 
  - 자바 직렬화 대상 객체는 동일한 `serialVersionUid`를 갖고 있어야 한다. 
    - `private static final long serialVersionUid = 1L;`
- 방법

  ```java
  // 직렬화 예제에서 생성된 base64 데이터 
  String base64Member = "...생략";
  byte[] serializedMember = Base64.getDecoder().decode(base64Member);
  
  try (ByteArrayInputStream bais = new ByteArrayInputStream(serializedMember)) {
      try (ObjectInputStream ois = new ObjectInputStream(bais)) {
          // 역직렬화된 Member 객체를 읽어온다.
          Object objectMember = ois.readObject();
          Member member = (Member) objectMember;
          System.out.println(member);
      }
  }
  ```

**※ Ref**
- https://techblog.woowahan.com/2550/

</details>

<details>
    <summary><b>자바의 직렬화는 언제, 어디서 사용되나요?</b></summary>

> 👉 자바의 직렬화는 JVM의 메모리에서만 상주하는 객체 데이터를 영속화(Persistence)할 필요가 있을 때 사용합니다. 시스템이 종료되더라도 없어지지 않으므로 영속화된 데이터이기 때문에 네트워크로 전송도 가능합니다. 이러한 특성때문에, 자바 직렬화는 서블릿 세션이나 캐시 등에 사용됩니다.

### 🆀 자바에서도 CSV, JSON을 사용하면 되지, 자바 직렬화를 써야하는 이유가 있나요?

> 👉 네 사실 이부분은 저도 정답이 없다고 생각하며, 목적에 따라 선택하면 된다고 생각합니다. 자바 직렬화의 경우, 클래스가 복잡한 데이터 구조를 갖는다고 해도 기본조건(primitive type, Serializable 구현)만 지키면 직렬화, 역직렬화가 모두 가능하므로 개발자 입장에서 더 편리하게 사용가능합니다. 따라서 자바 시스템 간의 데이터 교환이 주목적이면 자바 직렬화를 사용하고, 외부로 데이터를 내보내서 저장 등을 할 필요가 있을 때는 호환성이 좋은 CSV나 JSON을 사용하도록 고려하면 되겠습니다. 

</details>

---

<details>
    <summary><b>자바의 Synchronized 키워드를 설명해주세요.</b></summary> 

> 👉 자바의 synchronized 키워드는 하나의 자원에 여러 스레드가 동시에 접근하여 사용할 때 발생할 수 있는 오류를 방지하기 위한 키워드입니다. 현재 데이터를 사용하고 있는 스레드를 제외한 다른 스레드는 데이터에 접근할 수 없게 막는 기술입니다. 메서드나 블럭단위에 지정할 수 있으며 메서드 단위로 지정할 경우 메서드 전체에 lock 이 걸리므로 블럭단위로 지정하는 것이 성능상 유리한 면이 있습니다.    

</details>

<details>
    <summary><b>동기화와 비동기화의 차이를 설명해주세요.</b></summary>

> 👉두 방식의 차이점은 ***호출하는 함수가 호출되는 함수의 작업 완료 여부를 신경쓰는지에 대한 여부***에 있습니다. `동기` 방식은 함수 A가 B를 호출한 뒤, 함수 B의 작업 완료 여부를 계속 확인하면서 신경 쓰는 방식입니다. `비동기` 방식은 함수 A가 B를 호출하고 나서, 함수 B의 작업 완료 여부는 신경쓰지 않습니다. B의 작업 완료 여부는 오로지 B만 신경쓰며, 작업이 완료될 경우 콜백함수를 통해 결과를 전달하는 방식이 비동기 방식입니다.

💡 동기와 비동기는 ***순서와 결과처리의 관점***이 핵심 

### Sync(동기)
- **_함수 A가 B를 호출한 뒤, 함수 B의 결과값이 나오면 해당 결과값을 바로 처리하는 방식_**
- Java 에서 `Synchronized` 키워드 사용
  - 자바에서 멀티 스레드 접근 제한 키워드
  - 메서드, 블럭 단위 적용 가능
    - 단, ***메서드 단위로 적용할 경우 메서드 전체에 lock이 걸리므로 블럭을 활용***하는 것이 좋다. (임계 영역은 작을 수록 좋다.)
      
### Async(비동기)
- _**함수 A가 B를 호출하고나서, 함수 B의 작업 완료여부에는 신경쓰지 않는다. 결과가 나오면 처리할 수도 있고 안 할 수도 있다.**_ 
- Callback 함수를 통해 결과 확인
- ex. Thread

### 🆀 Blocking vs Non-Blocking

👉 처리되어야 하는 (하나의) 작업이 전체적인 작업 `흐름`을 막느냐 안 막느냐에 대한 관점

👉 `제어권`이 누구한테 있느냐가 관심사

- **Blocking**
  - 자신의 작업을 진행하다가 다른 주체의 작업이 시작되면 다른 작업이 **_끝날때까지 기다렸다가_** 자신의 작업을 시작하는 것
- **Non-Blocking**
  - 다른 주체의 작업에 관련없이 자신의 작업을 하는 것

**※ Ref**

- [[10분 테코톡] 🐰 멍토의 Blocking vs Non-Blocking, Sync vs Async](https://www.youtube.com/watch?v=oEIoqGd-Sns)
- [인파 - 동기비동기-블로킹논블로킹-개념-정리](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC#%EB%B8%94%EB%A1%9C%ED%82%B9__%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9)

</details>

<details>
    <summary><b>동시성 문제가 무엇인가요? 자바에서 동시성 문제를 해결할 수 있는 방법이 있을까요?</b></summary> 

> 👉 여러 쓰레드가 동시에 같은 인스턴스의 필드 값을 변경하면서 발생하는 문제를 동시성 문제라고 합니다. 예를 들어, 한 쓰레드에서 필드를 조회하는 도중에 다른 쓰레드가 필드값을 변경하면, 원래의 스레드는 조회만 했을 뿐인데 값이 변경되는 결과를 얻게됩니다. synchronized, volatile, atomic 등을 활용하여 해결할 수 있으며, 쓰레드 별로 변수 값을 다르게 가져가고자 할 때는 Thread Local의 사용 또한 고려해볼 수 있습니다.  

### 동시성 문제

- _**여러 쓰레드가 동시에 같은 인스턴스의 필드 값을 변경하면서 발생하는 문제**_
- 이런 동시성 문제는 여러 쓰레드가 같은 인스턴스의 필드에 접근해야하기 때문에 트래픽이 적은 상황에서는 잘 발생하지 않고, 트래픽이 점점 많아질 수록 자주 발생
  - 스프링 빈처럼 싱글톤 객체의 필드를 변경하여 사용할 때 이러한 동시성 문제를 조심해야 한다. 
- _**동시성 문제는 지역 변수에서는 발생하지 않는다.**_
  - 지역 변수는 쓰레드마다 각각 다른 스택 메모리에 할당되기 때문.
- 싱글톤 객체의 필드를 사용하면서 동시성 문제를 해결하는 방법 👉`쓰레드 로컬`
- concurrent 자료구조를 사용하여 해결

**※ 쓰레드(Thread)란?**

- 프로세스 실행의 단위
- 하나의 프로세스는 여러개의 쓰레드로 구성 가능
  - 일반적으로 한 프로그램은 하나의 스레드를 가지고 있지만, 프로그램 환경에 따라 둘 이상의 쓰레드를 동시에 실행할 수 있다.
- 하나의 프로세스를 구성하는 쓰레드 들은 프로세스에 할당된 메모리, 자원 등을 공유한다.

참고: [goodgid - what is thread](https://goodgid.github.io/What-is-Thread/) 

</details>

<details>
    <summary><b>Thread Local에 대해 설명해주세요.</b></summary> 

> 👉 Thread Local은 싱글톤 객체의 필드를 사용하면서 발생하는 동시성 문제를 해결하는 방법으로, 각 쓰레드마다 접근할 수 있는 별도의 저장소를 제공합니다. 이를 통해 같은 인스턴스의 쓰레드 로컬 필드(`Thread<T> threadVariable`)에 접근해도 동시성 문제가 발생하지 않습니다. 

### Thread Local 

- 해당 쓰레드만 접근할 수 있는 특별한 저장소를 의미
- 쓰레드 로컬을 사용하면 각 쓰레드마다 별도의 내부 저장소를 제공  👉 **_같은 인스턴스의 쓰레드 로컬 필드에 접근해도 문제 없다._**
- 자바는 언어차원에서 쓰레드 로컬을 지원하기 위해 `java.lang.ThreadLocal` 클래스를 제공한다.
- 주의점
  - 요청이 끝나고 `ThreadLocal.remove()`를 통해서 꼭 제거 해야한다.
  - 제거하지 않았을 경우, 쓰레드 풀에 의해 다른 사용자가 기존 사용자가 사용했던 쓰레드를 사용하는 경우 예상치 못한 값을 사용하게 된다.
- 동작 원리 

  ![image](https://user-images.githubusercontent.com/65555299/230367260-d5c2d2d0-4d76-441d-8136-f8977d1630bf.png)
  ![image](https://user-images.githubusercontent.com/65555299/230367329-9af15207-63d7-4739-b479-f48d2a50698a.png)
  ![image](https://user-images.githubusercontent.com/65555299/230367358-084c4cc3-7132-49c9-b25a-5aa47f21c505.png)

  (자료 출처 - 영한님 스프링 고급편)


</details>


---

<details>
    <summary><b>자바의 어노테이션에 대해 설명해주세요.</b></summary> 

> 👉 어노테이션은 자바 소스코드에 주석문처럼 추가하는 부가적인 정보로 메타데이터라고도 합니다. 주로 컴파일러에게 정보를 알려주거나, 실행할 때 별도의 처리가 필요할 때 사용합니다. @interface 키워드를 이용하여 사용자 정의 어노테이션을 선언할 수도 있습니다.

### 어노테이션

- 정의
  - 실행하고는 상관없이 자바 소스코드에 주석문처럼 추가하는 부가적인 정보
  - 서로 다른 이름으로 구성된 정보를 가지는 하나의 단위이며, 이것을 메타데이터(metadata)라고도 함
  
- 언제 사용하나?
  - 컴파일러에게 정보를 알려줄 때
  - 컴파일할 때와 설치(deployment)시의 작업을 지정할 때
  - 실행할 때 별도의 처리가 필요할 때
  
- **_어노테이션은 상속 불가능하다._**

- 자바 언어가 제공하는 어노테이션은 3개
  - @Override
  - @Deprecated
  - @SuppressWarnings
  
- `메타 어노테이션(어노테이션을 선언하기 위한 어노테이션)`은 4개 
  - @Target: 어노테이션 적용 대상 지정
  - @Retention: 어노테이션 정보 유지 기간 선언
  - @Documented: '어노테이션에 대한 정보가 JavaDocs(API) 문서에 포함된다는 것' 을 선언
  - @Inherited: 모든 자식 클래스에서 부모 클래스의 어노테이션을 사용 가능하다는 것을 선언
  
- 사용자 정의 어노테이션
  - `@interface` 키워드를 통해서 한다.
  ```java
  import java.lang.annotation.Retention;   
  import java.lang.annotation.ElementType;   
  import java.lang.annotation.RetentionPolicy;   
  import java.lang.annotation.Target;
     
  @Target(ElementType.Method)
  @Retention(RetentionPolicy.RUNTIME)
  public @interface UserAnnotation{
        public int number();
        public String text() default "This is first annotation"; 
  }
  ```


</details>

---

<details>
    <summary><b>자바 8에 추가된 기능들에 대해 간단히 설명해주세요.</b></summary> 

> 👉 Java8 의 변경점으로 대표적인 것들은 
> <br> 메서드를 하나의 식으로 표현하는 익명함수인 람다 표현식, 
> <br> 추상메서드를 하나만 갖는 함수형 인터페이스, 
> <br> 컬렉션 데이터 타입의 데이터를 내부 반복을 통해 정렬, 필터링 등이 가능한 스트림, 
> <br> null이 올 수 있는 값을 감싸는 래퍼클래스인 옵셔널, 
> <br> 기존 소스 코드와의 하위 호환성을 위한 인터페이스의 디폴트 메서드 등이 있습니다. 

### Java8에 추가된 기능들 

- Lambda 표현식
- 함수형 인터페이스
- Stream
- Optional
- 인터페이스의 default 메서드 
- 날짜 관련 클래스들 추가
- 병렬 배열 정렬
- StringJoiner 추가 

</details>

<details>
    <summary><b>Stream에 대해 설명해주세요.</b></summary>

> 👉  스트림 API는 배열이나 컬렉션처럼 ***데이터 그룹을 간단하고 효율적으로 처리할 목적***으로 JDK 8부터 지원하는 API 입니다. 스트림은 ***원본 데이터를 변경하지 않고 데이터 가공***이 가능하며, 배열이나 컬렉션 데이터와 달리 ***작업 후 스트림 데이터가 자동으로 소멸***된다는 특징이 있습니다. 마지막으로 스트림은 ***중간 연산이 최종 연산이 수행될 때가 되서야 수행***된다는 지연 연산의 특징을 갖고 있습니다.


### Stream

- Java8 에 추가된 API
- 컬렉션 타입의 데이터를 Stream 메서드로 내부 반복을 통해 정렬, 필터링이 가능 
- 특징
  - _**parallel 메서드 제공을 통해 병렬 처리가 가능**_
  - **원본 데이터를 변경하지 않음(Immutable)**
    - 원본 데이터로부터 읽기만 할 뿐, 원본 데이터 자체를 변경하지 않는다.
  - 작업을 내부 반복으로 처리하므로 불필요한 코드를 줄일 수 있습니다.
  - 최종 연산 이후 stream이 닫히므로 **일회용**이다. 
    - **배열과 컬렉션 데이터는 메모리에 저장되지만 스트림 데이터는 작업 후 자동으로 소멸됨**
- 구조
  - `Stream 생성`
  - `중간연산`: 데이터를 가공하는 과정
    - 필터링: filter, ditinct
    - 변환: map, flatMap
    - 제한: limit, skit
    - 정렬: sorted
    - 연산결과확인: peek
  - `최종연산`: Stream 안의 데이터를 모아 반환하는 역할을 한다.   
    - 출력: forEach
    - 소모: reduce
    - 검색: findFirst, findAny
    - 검사: anyMatch, allMatch, noneMatch
    - 통계: count, min, max
    - 연산: sum, savage
    - 수집: collect

### ParallelStream

> 추가 예정

</details>

<details>
    <summary><b>Stream과 반복문 for문의 성능차이가 있을까요?</b></summary>

> 👉 일반적으로 for문이 stream에 비해 빠릅니다. for문은 오래된 기술로, JIT 컴파일러에 의해 최적화가 잘되어있습니다. 또한 stream은 for문에 비해 오버헤드가 발생하기 때문에, for문이 성능상 더 좋습니다. 그럼에도 불구하고, 저는 stream이 가독성이 더 좋아 개발 시에는 stream을 주로 사용하는 편입니다. 

### Stream vs for 반복문

- _**for문이 stream 보다 빠르다.**_
  - for문은 40년동안 JIT 컴파일러에 의해 최적화 되어있다. 
  - stream은 for문에 비해 오버헤드 발생
    - stream 사용을 위해서는 boxing이 필요하지만, for문은 인덱스에 바로 접근하여 오버헤드 발생하지 않음


- _**그래도 stream을 사용하는 이유?**_
  - stream은 for문에 비해 **_가독성이 좋다._**

※ Ref
- [Java Lambda Expression과 성능](https://brunch.co.kr/@heracul/3)
- [Java Stream API는 왜 for-loop보다 느릴까?](https://sigridjin.medium.com/java-stream-api%EB%8A%94-%EC%99%9C-for-loop%EB%B3%B4%EB%8B%A4-%EB%8A%90%EB%A6%B4%EA%B9%8C-50dec4b9974b)

</details>

<details>
    <summary><b>Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해주세요.</b></summary>

> 👉 함수형 인터페이스란 추상 메서드를 하나만 갖는 인터페이스를 의미합니다. 익명 클래스 또는 람다식으로 인스턴스 생성이 가능하며, 스트림에서는 주로 함수형 인터페이스 `Consumer<T>, Function<T, R>, Predicate<T>, Supplier<T>`을 람다식으로 선언해서 사용합니다.    

**※ 함수형 인터페이스**

- 정의
  - 추상 메서드를 딱 하나만 갖는 인터페이스
  - `@FunctionalInterface` 어노테이션을 갖는 인터페이스
- 예시
  ```java
  @FunctionalInterface
  public interface RunSomething { // 추상메서드가 단 1개만 있으므로 함수형 인터페이스 맞다.
      void doIt();
  
      static void printName(){
          System.out.println("catsbi");
      }
      
      default void printAge(){
          System.out.println("33");
      }
  }
  
  // 함수형 인터페이스는 익명 내부 클래스로 구현해서 사용 가능
  RunSomething runSomething = new RunSomething() {

			@Override
			public void doIt() {
				System.out.println("do something");
			}
		};

  runSomething.doIt();
  
  // 익명 내부 클래스 to 람다식
  RunSomething runSomething = () -> System.out.println("do something");
  ```

</details>

<details>
    <summary><b>Lambda에 대해 설명해주세요.</b></summary> 

> 👉 람다식이란 함수를 하나의 식으로 표현한 것으로, 함수형 인터페이스의 인스턴스를 선언할 때 사용가능합니다. 따라서, 변수처럼 취급이 가능하고 인자로 전달 가능한 특징이 있습니다. 기존에 익명 클래스로 구현하던 코드를 줄일 수 있고, 개발자의 의도가 명확히 드러난다는 점에서 가독성을 높일 수 있습니다. 단, 익명함수로써 사용된 람다식은 재사용이 불가능하다는 단점 등이 있습니다. 개인적으로는 스트림 API를 활용시 자주 사용하고 있습니다. 

</details>

<details>
    <summary><b>익명 클래스(Anonymous Inner Class)와 Lambda의 차이점을 알고계신가요?</b></summary> 

> 👉 익명 클래스와 람다식의 가장 큰 차이점은 추상 메서드가 여러 개인 인터페이스를 구현할 수 있는가에 대한 여부입니다. 우선 익명 클래스는 추상 클래스 또는 추상 메서드가 여러 개인 인터페이스를 상속하여 인스턴스를 생성할 수 있습니다. 반면 람다식은 추상 메서드가 하나인 인터페이스, 즉 함수형 인터페이스만 구현이 가능합니다. 또한 익명 클래스의 this 는 클래스의 인스턴스 자기 자신을 가리키지만, 람다식의 this는 선언된 클래스를 가리킨다는 차이점 등도 있습니다. 
> 

※ 익명 클래스

코드 내부에 이름이 존재하지 않는 클래스

</details>

<details>
    <summary><b>람다식에서, 외부 변수를 사용할 때 final 키워드를 붙여서 사용하는 이유가 무엇일까요? final을 안 붙여도 되지 않을까요?</b></summary>

> 👉
>  만약 참조하고자 하는 지역 변수가 final 혹은 effectively final 이 아니라면, 멀티쓰레드 환경에서 람다 캡쳐링 시 외부 지역 변수가 복사될 때, 전달되는 값이 항상 최신 값임을 보장할 수 없습니다. 따라서 외부 지역 변수는 final 혹은 effectively-final 이어야 합니다. 추가로 외부 변수 중 인스턴스 변수나 클래스 변수는 쓰레드간 공유가 가능하기 때문에 final 키워드를 사용하지 않아도 참조 시 최신값임을 보장할 수 있습니다. 

- **_‘람다식에서 참조하는 외부 지역 변수는 final 혹은 effectively final 이어야한다.’_**
  - 람다식에서 사용되는 외부 지역 변수는 복사본이다.
- 외부 변수에는 인스턴스 변수, 클래스 변수, 지역 변수가 있고 이 중 인스턴스 변수나 클래스 변수는 final 이 아니어도 사용가능하다.

### 람다식에서 사용되는 외부 지역변수는 복사본이다.

람다식에서 사용되는 외부 지역변수가 복사본인 이유 
- 지역 변수는 스택 영역에 생성되고, 선언된 block 이 끝나면 stack 에서 제거된다. 
  - 메서드 내에서 지역변수를 참조하는 람다식(람다 캡쳐링)이 있는 경우, 추후에 다시 사용할 수도 있으므로 참조했던 지역변수를 복사해야한다. (복사한 지역변수는 스레드의 스택에 저장)
- 지역 변수를 관리하는 쓰레드와 람다식이 실행되는 쓰레드가 다를 수 잇다. 

**※ Effectively final**
- 초기화 된 이후 값이 한 번도 변경되지 않은 상태

```java
public String composeNames(List<Book> books) {
	String seperator = ","; // 람다식의 매개변수가 아니다. -> 자유 변수

	return books.stream()
            .map(book-> book.getAuthor())
            .collect(Collectors.joining(seperator)); // Variable used in lambda expression should be final or effectively final 에러 발
	
	separator = ":"; // final 키워드가 없더라도 final 처럼 쓰지 않으면 문제가 된다.
}
```

※ Ref

- https://vagabond95.me/posts/lambda-with-final/
- https://steady-coding.tistory.com/306

</details>


<details>
    <summary><b>Optional에 대해 설명해주세요. Optional을 사용하면 무슨 이점이 있을까요?</b></summary> 

> 👉 옵셔널은 null이 올 수 있는 값을 감싸는 Wrapper 클래스입니다. 이 덕분에 Optional 타입의 객체를 사용하게 되면 그 자체만으로 다른 개발자 역시 아! 이 안의 value가 null일 수 있어! 라고 명시적으로 변수에 대한 null 가능성을 표현할 수 있습니다. 또 null 체크를 하지 않아도 되는 등의 이점이 있습니다. 마지막으로 NullPointerException 이 발생할 수 있는 값을 직접 다루지 않아도 된다는 장점이 있습니다.

</details>

<details>
    <summary><b>Optional을 사용하면서 주의해야할 점이 있을까요?</b></summary>

> 👉 Optional은 설계된 의도, 즉 메서드의 리턴타입으로만 사용하는 것이 좋고 이외의 경우는 사용을 지양하는 편이 좋습니다. 예를 들어 메서드의 파라미터로 사용된 경우를 생각해보겠습니다. 파라미터로 전달된 옵셔널 객체의 값을 사용하기 위해서 먼저 파라미터 자체가 null인지 검사하고, null이 아니라면 isPresent() 등 value가 존재하는지를 확인하는 과정을 거쳐야만 합니다. 이는 Optional을 사용하기 전에 단순히 null 체크만 해주는 것보다도 코드가 복잡해져버립니다. 또한 Optional 자체가 래퍼클래스 이다보니 남용하면 그만큼 메모리와 실제 객체에 접근하는 시간이 많이 소요될 것입니다. 따라서 설계된 의도인 반환타입으로만 사용할 것을 지키는 것이 좋다고 생각합니다.   

</details>

---

<details>
    <summary><b>Object 클래스의 equals()와 hashcode()는 무슨 역할을 하나요?</b></summary> 

<br>

> 👉 equals()는 2개의 객체가 동일한지 비교하기 위해 사용합니다. 내부적으로 == 연산자를 이용하여 두 객체의 참조변수값을 기준으로 동일한지 판단합니다. hashcode()는 힙 메모리에 저장된 인스턴스의 주소값을 가지고 해시코드를 만들어 반환하는 메서드입니다. 필드값을 기준으로 동등성을 비교하기 위해 equals()를 오버라이딩를 하여 사용할 때, hashcode()를 같이 오버라이딩하지 않는다면 hash값을 사용하는 컬렉션을 사용할 때 문제가 발생하므로, equals와 hashcode는 항상 같이 오버라이딩해서 사용하는 것이 좋습니다.  

### equals()

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```
- 2개의 객체가 동일한지 비교하기 위해 사용한다.
- (구현) 2개의 객체가 참조하는 것이 동일한지 확인
  - ~~판단 기준은 `해시코드값`~~ (더 찾아봐야함)
- java.lang.Object에 정의됨

### hashcode()

- 메모리에 생성된 인스턴스의 주솟값을 가지고 일련번호를 만들어 반환하는 메서드
  - 해시 코드는 인스턴스가 메모리에 생성되는 주솟값을 기초로 만들어지는 만큼 **_서로 다른 인스턴스는 해시 코드값이 같을 수 없다._**
  - 32 bit JVM에서 서로 다른 두 객체는 결코 같은 해시코드를 가질 수 없었지만, 64 bit JVM에서는 8byte 주소값으로 해시코드(4byte)를 만들기 때문에 **_해시코드가 중복될 수 있다._** 
  - String 객체의 경우 value를 가지고 
- java.lang.Object에 정의됨
- Object 명세에는 equals()를 오버라이딩하면 hashcode()를 오버라이딩하라고 안내되어있다.

### `== 연산자`

- 비교하는 값이 
  - 기본 타입: 값을 비교
  - 참조 타입: 주소값을 비교


※ Reference

- https://mangkyu.tistory.com/101
- https://tecoble.techcourse.co.kr/post/2020-07-29-equals-and-hashCode/
- https://sas-study.tistory.com/402
- https://sanseongko.github.io/java-evshash


</details>

<details>
    <summary><b>equals()와 hashcode()는 언제 재정의해야할까요? 또, 왜 같이 오버라이딩 하는게 좋을까요?</b></summary> 

<br>

> 👉 equals와 hashcode 오버라이딩은 객체를 비교할 때 주소값으로 비교하는 것이 아닌, 필드값을 기준으로 두 객체가 동등함을 보장하고 싶을 때 사용합니다. 예를 들어 id 필드값을 갖는 Member 클래스가 있다고 가정해보겠습니다. 그리고 같은 id를 갖는 두 객체를 만들고 equals를 통해 비교하면 두 객체는 주소값이 다르므로 false를 리턴합니다. 그런데 개발자 입장에서는 같은 id를 갖는 객체는 같은 데이터로 취급하고 싶은 상황입니다. 이럴 때 equals를 사용하여 동등성 비교 시 true를 얻을 수 있도록 오버라이딩을 합니다.   

> 👉 equals와 hashcode를 같이 오버라이딩 하는 이유는 hash값을 사용하는 컬렉션(HashSet, HashMap, HashTable) 을 사용할 때 문제가 발생하기 때문입니다. 예를 들어 HashSet 구현체에 필드값이 같은 동등한 객체는 중복되지 않게 하나씩만 저장해야하는 경우, equals를 오버라이딩 하였더라도 hashcode를 오버라이딩 하지 않으면 논리적으로 다른 객체로 인식되어 중복 저장되게 됩니다. 따라서 안전하게 동등성을 보장하기 위해서는 equals와 hashcode를 같이 오버라이딩 하는 것이 좋습니다.


**hash 값을 사용하는 컬렉션이 논리적으로 같은지 비교할 때의 과정**
<img width="633" alt="image" src="https://user-images.githubusercontent.com/65555299/230924895-074214ea-dc30-4dc1-b59b-50a8598d441b.png">



</details>

<details>
    <summary><b>서로 다른 인스턴스가 같은 hashcode값을 가질 수 있을까요?</b></summary> 

<br>

> 👉 서로 다른 인스턴스가 같은 hashcode 값을 가질 수 있습니다. 예를 들어 String 객체의 경우 hashcode를 계산할 때 value를 기준으로 계산하는데, 낮은 확률이지만 문자열 내용이 달라도 같은 hashcode를 가질 수 있습니다. 또 동등성 비교를 위해 hashcode를 오버라이딩 하는 경우에도 같은 hashcode를 가질 수 있습니다. 단 이와 같은 경우를 제외하면 일반적으로 다른 인스턴스의 경우 hashcode를 갖게됩니다. 

- 32 bit JVM 에서는 해시코드 충돌 없지만, 64 bit JVM에서는 해시코드 충돌 가능

**※ Reference**
- https://leedo.me/36

</details>


---

<details>
    <summary><b>String 클래스는 final로 선언되어있습니다. 왜 그런걸까요?</b></summary>

<br>


> 👉 String이 불변이 아니라면 String 객체를 공유할 수 없기 때문입니다. String이 가변이라고 하면, 객체를 두 개이상의 참조변수가 참조할 경우, 한 참조변수를 사용하여 String 객체의 리터럴을 변경하면 다른 참조변수 역시 변경된 값을 참조하게 되는 문제가 있습니다. 이 외에도 보안상 String이 가변일 경우 사용자가 특정 파일에 대한 액세스를 얻은 후 PATH를 변경할 수 있게되고 이것은 자친 심각한 오류를 야기할 수 있습니다.  이러한 이유들로 String 객체는 final, 불변이어야합니다.

---

**※ Reference**
- https://www.mimul.com/blog/why-string-class-has-made-immutable-or-final-java/

</details>


<details>
    <summary><b>String을 new 또는 "" 로 생성했을 때의 차이점을 설명해주세요.</b></summary> 

<br>

> 👉 문자열 리터럴과 new 키워드로 생성할 때의 String 객체 생성 방식이 다릅니다. 문자열 리터럴로 String 객체를 생성할 경우, 힙 메모리의 문자열 상수풀에 같은 값을 갖는 객체가 있는지 확인하고 있으면 그 객체의 참조값을, 없으면 객체를 문자열 상수풀에 새로 생성해서 그 참조값을 리턴합니다. 따라서 == 비교시에 true를 리턴합니다. new 키워드를 이용하여 생성할 경우 문자열 상수풀이 아닌 힙메모리에 객체를 생성하므로, == 비교 시 false를 리턴합니다.

## 문자열을 생성하는 3가지 방법

### 1. 문자열 리터럴로 생성하는 경우

- String literal로 객체를 생성하면, 
  - 힙 영역의 문자열 상수 풀(String Constant Pool)에 같은 값을 가지는 객체가 있는지 확인한다.
  - 같은 값을 가지는 객체가 있으면 그 객체의 참조값을, 없으면 String Pool에 객체를 생성하고 그 참조값을 리턴한다.
- _**새로운 리터럴을 할당하면 String Pool에 존재하는 객체의 참조값을 리턴하거나, 새롭게 객체를 String Pool에 만들어서 참조값 리턴.**_ 

👉 **_같은 리터럴로 생성한 String 객체의 == 값이 같다(참조값이 같으므로)._**

### 2. new 키워드로 생성하는 경우

- new 키워드와 String() 생성자로 객체를 생성하는 경우 `String Pool`이 아닌 `힙 영역`에 객체를 생성하고 그 참조값을 리턴

👉 **_같은 값이지만 new 키워드로 생성한 String 객체의 == 값이 다르다(참조값이 다르므로)._**

```java
String a = "aaa";
String b = "aaa";
String c = new String("aaa");
String d = new String("aaa");
```
![image](https://user-images.githubusercontent.com/65555299/230854054-797dcdde-bef2-4c3c-a33b-ae3d1685d293.png)


### 3. `intern()`으로 문자열 생성

- "문자열 리터럴이 생성될 때마다 JVM은 해당 문자열이 문자열 상수 풀에 존재하는지 확인합니다. 문자열 상수 풀에 해당 문자열이 존재하지 않으면, 해당 문자열을 문자열 상수 풀에 저장하고 존재하면 저장하지 않습니다."를 수행하는 메서드
- `intern()` 으로 생성하면 문자열 리터럴로 생성한 것과 같은 결과

```java
public static void main(String args[]) {
  String str1 = "Hello";
  String str2 = new String("Hello").intern();
  String str3 = new String("Hello");

  System.out.println(str1 == str2);
  System.out.println(str1 == str3);
}
```

![image](https://user-images.githubusercontent.com/65555299/230855009-0315ad29-659d-4354-8b29-605c3d4eb995.png)


### String Constant Pool

- Java 버전이 올라감에 따라 Method -> Heap 으로 이동
  - Java 6 이전
    - PermGen 영역에 String Pool 존재
    - PermGen 은 메타 클래스 데이터 등 Method 영역에 존재
    - PermGen 은 사이즈가 고정(32MB ~ 96MB) 👉 String을 많이 사용하면 OutOfMemory 에러 발생
  - Java 7
    - String Pool이 기존의 PermGen에서 Heap으로 이동
    - 고정된 String Pool 사이즈 때문에 생기던 문제(OOM) 해결
  - Java 8 
    - PermGen이 Metaspace 로 변경됨(고정 크기 -> 동적 크기)

- 장점
  - 문자열 상수 풀에 같은 문자열 객체가 존재하는 경우 객체를 생성하지 않으므로 메모리 공간 절약
  - 문자열 상수 풀은 문자열 캐싱을 사용하므로, JVM은 문자열이 문자열 상수 풀에 존재하는지 빠르게 확인 가능 

※ Reference

- https://sabarada.tistory.com/137
- https://www.baeldung.com/java-string-pool
- https://dololak.tistory.com/718
- https://developer-talk.tistory.com/475



</details>

<details>
    <summary><b>String, StringBuilder, StringBuffer 를 각각 비교해주세요.</b></summary>

<br>

>  👉 먼저 String은 불변 문자열이며, 새로운 값을 할당할 때마다 String 객체가 생성된다는 특징이 있습니다. 그러나 이로인해, 문자열 연산시 새로운 문자열 객체를 생성하고 기존의 객체는 버려지게 됩니다. 이 같은 문제를 해결하기 위해 StringBuilder 와 StringBuffer가 추가 되었고 이 둘은 변경 가능한 문자열입니다. 문자열 연산 등으로 기존 객체의 공간이 부족하게 되면 버퍼크기를 늘리며 유연하게 동작한다는 특징이 있습니다. StringBuffer는 StringBuilder와 다르게 주요 메서드에 synchronized 키워드를 사용하여 Thread Safe 하다는 특징이 있습니다.

- String이 final이 아니라면 Constant Pool 입장에서 String인지 String의 Sub Class 인지 알 길이 없다.  

<br>

### String

- 새로운 값을 할당할 때마다 String 객체가 생성된다.
- 문자열은 불변
- String + String + ... + string
  - 문자열 연산 시, 연산 하고 새 String 객체를 만들어 참조 
    - JDK 1.5부터 String은 StringBuilder로 변환되기 때문에, 이러한 연산은 최적화 되었다.
  - String 객체 각각의 주솟값이 Stack에 쌓이고, 가비지 컬렉터가 호출되기 전까지 String 객체가 힙 메모리에 쌓인다.
  
### StringBuilder Vs StringBuffer
 
- memory에 append하는 방식으로 클래스에 대한 객체를 직접 생성하지 않는다.
- StringBuilder와 StringBuffer는 문자열 연산 등으로 기존 객체의 공간이 부족하게 되는 경우 기존의 버퍼크기를 늘리며 유연한게 동작

- `StringBuilder`
  - 변경 가능한 문자열 
  - **_Thead Safe 하지 않다._**
  - 단일 스레드 환경에서는 StringBuffer보다 StringBuilder를 사용하는 것이 성능상 좋다.(StringBuffer는 동기화 처리를 해야하므로)

- `StringBuffer`
  - 변경 가능한 문자열
  - **_Thread Safe 하다(동기화)._**
  - 각 메서드별로 synchronized 키워드로 선언

**※ JDK 1.5 부터 String 의 `+`연산은 컴파일시에 StringBuilder를 사용하여 성능 최적화가 이루어진다.**

- 단, String이 항상 StringBuilder로 변환되는 것은 아니다. (_concat() 메서드 사용시 StringBuilder로 변환되지 않는다_.)
- 한 줄로 선언한 경우 최적화되지만, 여러 줄로 선언한 경우는 연산 시 StringBuilder객체를 매번 생성하기 때문에 성능저하는 여전하다.

```java
//컴파일 전 소스파일
String str2 = "";
        str2 += 0;
        str2 += 1;
        str2 += 2;
		
// 컴파일 이후, 디컴파일한 소스파일
String str2 = "";
    str2 = (new StringBuilder()).append(s1).append("0").toString();
    str2 = (new StringBuilder()).append(s1).append("1").toString();
    str2 = (new StringBuilder()).append(s1).append("2").toString();
```


※ Reference

- [String은 항상 StringBuilder로 변환될까?](https://siyoon210.tistory.com/160)
- [String, StringBuilder, StringBuffer의 차이](https://12bme.tistory.com/42)
</details>

---

<details>
    <summary><b>컬렉션 프레임워크에 대해 설명해주세요.</b></summary>

_👉 "컬렉션은 여러 자료구조 알고리즘을 미리 구현하여 데이터를 효율적으로 처리할 수 있도록 제공하는 자바 API입니다. List, Set, Queue, Map 인터페이스가 컬렉션을 상속하며, 이를 구현하는 클래스를 제공하여 일관된 API를 사용할 수 있다는 장점이 있습니다. List, Set, Queue는 Iterable 인터페이스를 상속하는 Collection을 상속하며, Map 의 경우 key-value 구조로 다른 인터페이스들과 구조가 달라 Iterable을 상속 하지 않습니다."_

### 컬렉션 프레임워크

- 여러 가지 자료구조 알고리즘을 미리 구현하여 데이터를 효율적으로 처리할 수 있도록 제공하는 자바 API이다.
- List, Set, Queue, Map 인터페이스가 Collection을 상속한다. 
  - 이를 구현하는 클래스를 제공하여 일관된 API를 사용할 수 있다.

![image](https://user-images.githubusercontent.com/65555299/230928993-9a3ff0e8-a191-427f-9fad-09ea6342e214.png)
![image](https://user-images.githubusercontent.com/65555299/230942240-96a725e6-de59-43ec-8354-515a1dab2a7e.png)

※ Reference

- https://www.nextree.co.kr/p6506/
- https://hudi.blog/java-collection-framework-1/

</details>

---

<details>
    <summary><b>List 인터페이스의 구현체에 대해 설명해주세요.</b></summary>

- 다른 인터페이스와 달리 List 인터페이스는 배열처럼 '순서'가 있다.
- java.util 패키지에서는 ArrayList, LinkedList, Vector, Stack이 있다.
  - ArrayList와 Vector는 배열처럼 데이터가 저장될 때마다 인덱스 부여
  - LinkedList는 데이터가 저장될 때 이전에 저장된 데이터와 이후에 저장된 데이터의 정보를 포함
- `ArrayList`
  - 배열과 거의 유사(동적배열을 사용하기 위해 사용)
  - 데이터 저장은 배열처럼 메모리에 연속적으로 하고, 데이터 접근은 인덱스를 통해 접근
  - 데이터 삽입 시 오른쪽의 데이터를 다음 인덱스로 이동한 후 삽입
  - 데이터 삭제 시 오른쪽 데이터를 다음 이전 인덱스로 이동
  - **_동기화 처리를 지원하지 않는다._**
  - 장단점
    - 장점: 검색 속도가 빠르다.
    - 단점: 데이터 추가, 삭제 시 많은 부하가 생긴다.
- `Vector`
  - ArrayList처럼 ***가변 크기 배열에 데이터를 저장***하며, 데이터를 처리하기 위한 메서드도 같다.  
  - **_동기화 처리를 지원한다._**
  - Stack은 Vector를 상속하므로 동기화 처리 지원  
- `LinkedList`
  - LinkedList는 ArrayList처럼 데이터를 순서대로 저장되지 않고 임의의 위치에 저장됨(비연속)
  - 데이터들을 하나의 그룹으로 처리하기 위해 **_데이터를 저장할 때 다음 데이터의 주소를 추가로 저장_**

</details>

<details>
    <summary><b>Array와 ArrayList는 어떤 차이점이 있을까요?</b></summary>

<br>

 _👉 "Array는 메모리에 한 번 할당되면 크기를 변경할 수 없지만, ArrayList는 크기가 가변이라는 차이점이 있습니다. Array는 기본 타입, 참조 타입 모두 저장 가능하지만 ArrayList는 참조 타입만 저장 가능합니다. 데이터 추가 삭제시에 ArrayList는 주변 데이터를 이동해야하기 때문에 성능면에서 Array가 유리합니다."_

<br>

- `Array`
  - 크기 고정
  - Primitive Type, Reference Type 모두 저장가능
- `ArrayList`
  - 크기 가변 
  - Reference Type만 저장 가능
    - 제네릭 타입을 사용하기 때문에 타입 안정성 보장
  - 데이터 추가 삭제시 주변 데이터를 이동해야하기 때문에 Array 보다 성능면에서 불리
  - 기본 용량은 10
    - `private static final int DEFAULT_CAPACITY = 10;`
  - element를 add하려고 할때, capacity가 배열의 길이와 같아지면 일반적으로 기존의 용량 + 기존 용량/2 만큼 크기가 늘어난 배열에 기존의 배열을 copy해서 return

</details>

<details>
    <summary><b>ArrayList는 내부적으로 어떻게 구현되어있나요?</b></summary> 

<br>

- 동적 배열로 구현
- 데이터 삽입 시 오른쪽의 데이터들을 다음 인덱스로 이동한 후 삽입
- 삭제 시 데이터를 삭제한 후 오른쪽의 데이터를 이전 인덱스로 이동

<br>

**🆀 배열로 구현되어있으면 크기가 꽉 찬 경우 일반 배열처럼 예외가 발생할텐데 ArrayList 는 어떻게 무한히 데이터를 받을 수 있을까요?**


- element를 add 할 때, 저장된 데이터 개수가 배열의 용량과 같아지면 grow() 메서드를 호출
- grow() 메서드는 기존 용량 + 기존 용량 / 2 만큼 크기가 늘어난 배열에 기존의 배열을 copy 해서 리턴 (기존 용량의 1.5배)
  - 벡터는 기존 용량의 2배

```java
private Object[] grow(int minCapacity) {
    int oldCapacity = elementData.length;
    if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        int newCapacity = ArraysSupport.newLength(
			oldCapacity,
                        minCapacity - oldCapacity, /* minimum growth */
                        oldCapacity >> 1           /* preferred growth */
        );
        return elementData = Arrays.copyOf(elementData, newCapacity);
    } else {
        return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];
    }
}
```

- https://f-lab.kr/blog/java-backend-interview-1

</details>


<details>
    <summary><b>ArrayList 와 LinkedList를 비교해주세요.</b></summary> 

_👉 "ArrayList는 메모리에 연속으로 저장되므로 메모리 공간이 많이 확보되어야 하지만, LinkedList는 데이터를 메모리에 비연속적으로 저장되므로 메모리를 좀 더 효율적으로 사용합니다. 그러나 LinkedList는 데이터와 함께 노드에 대한 위치 정보까지 저장하므로 ArrayList에 비해 메모리를 더 많이 사용합니다."_ 

_👉 "ArrayList는 데이터 삽입, 삭제 시 주변의 데이터를 이동해야하므로 부하가 많은 반면에, LinkedList는 노드들의 위치 정보만 변경하면 되므로 성능면에서 유리합니다."_ 

---

- `ArrayList`
  - 데이터가 순서대로 저장(연속)
  - 데이터 검색면에서는 LinkedList 보다 유리
  - 무작위 접근(Random Access) 가능 
- `LinkedList`
  - 데이터가 연속적으로 저장되지 않고 임의의 위치에 저장(비연속) 
  - 메모리 효율면에서 연속적인 공간이 필요없으므로, ArrayList보다 유리
  - 무작위 접근 불가능. 순차접근(Sequential Access)만 가능
  - 삽입, 삭제 시 시간이 O(1) + 탐색시간 포함하면 O(n)

</details>

---


<details>   
    <summary><b>Map 인터페이스의 구현체에 대해 설명해주세요.</b></summary>

### HashMap

- Entry<K, V>의 배열로 저장되며, 배열의 index는 내부 해쉬 함술르 통해 계산된다.
- 데이터 순서가 의미없음: 내부 hash값에 따라 Key 순서가 정해지므로 특정 규칙없이 출력된다.
- Key와 Value에 null 허용
- 비동기 처리
- 시간복잡도: `O(1)`

### LinkedHashMap

- HashMap을 상속받으며,
- 입력 순서대로 출력된다.
- 비동기 처리
- 시간 복잡도: O(n)

### TreeMap

- 내부적으로 레드-블랙 트리로 저장됨
- Key값이 기본적으로 오름차순 정렬되어서 출력
- 키값에 대한 Comparator 구현으로 정렬 방법 지정 가능

### Hashtable

- 데이터를 처리하는 모든 메서드에 동기처리: get(), put(), remove()
- Key와 Value에 null을 허용하지 않는다.

### ConCurrentHashMap

- Key와 Value에 null을 허용하지 않는다.
- 서로 다른 스레드가 같은 해시 버킷에 접근할 때만 해당 블록이 잠기게 된다.
  - Entry(Node) 배열 원소별로 동기 처리

※ Reference

- https://pplenty.tistory.com/17
- https://tecoble.techcourse.co.kr/post/2021-11-26-hashmap-hashtable-concurrenthashmap/


</details>

<details>
    <summary><b>HashTable에 대해 설명해주세요.</b></summary> 

## 해시 테이블(HashTable)

- key, value로 값을 저장하는 자료구조
- Key값의 hashcode를 배열의 고유한 index를 설정
- 실제값이 저장되는 장소를 버킷이라 한다.
- Key값으로 데이터르 찾을 때 해시 함수를 1번만 수행하면 되므로 저장/삭제/조회 속도가 빠름
  - 평균 시간 복잡도: `O(1)`

</details>

<details>
    <summary><b>HashMap과 HashTable을 비교해주세요.</b></summary>
<br>

- HashMap
  - 비동기 처리
  - key, value 로 null을 허용 한다.

- Hashtable
  - 데이터를 처리하는 모든 메서드에 동기처리: get(), put(), remove()
  - key, value 로 null을 허용 안 함


※ Reference
- https://d2.naver.com/helloworld/831311

</details>

<details>
    <summary><b>HashMap과 ConcurrentHashMap은 어떤 차이가 있나요?</b></summary> 

<br>

- HashMap
  - 비동기 처리
  - key, value 로 null값 지원
- ConcurrentHashMap
  - 동기 처리
    - 서로 다른 스레드가 같은 해시 버킷에 접근할 때 동기처리 -> Hashtable보다 성능적으로 우세
  - key, value로 null값 지정 불가능

</details>

--- 

<details>
    <summary><b>Set 인터페이스의 구현체에 대해 설명해주세요.</b></summary>

# Set

- List와 다르게 저장되는 데이터의 순서가 의미없다.
- 해시코드를 이용하여 데이터를 저장하므로 데이터가 저장된 순서를 알 수 없다.
- 해시코드는 데이터를 구분하는 값으로 사용되므로 중복될 수 없다.
- 해시코드는 Object클래스의 hashCode()의 반환값을 사용
- 해시코드를 사용하여 데이터를 처리하므로 컬렉션 중에서 가장 빠르게 검색한다.

### 객체 비교

데이터가 같은지 다른지 비교할 때 hashCode() 와 equals()를 이용한다.

1. Object클래스의 hashCode() 메서드의 반환값으로 비교
2. hashCode()값이 다르면 Object클래스의 equals()메서드를 실행하여 한 번 더 판단.

## 구현체 종류

### HashSet

- 내부적으로 HashMap 인스턴스를 사용하여 요소를 저장
- 저장 순서를 유지하지 않는 데이터의 집합이다.
- 해시 알고리즘(hash algorithm)을 사용하여 검색 속도가 매우 빠르다.

### LinkedHashSet

- 저장 순서를 유지하는 HashSet
- 내부적으로 LinkedHashMap으로 구현

### TreeSet

- Tree와 Set의 특성을 동시에 가진다. 저장되는 데이터 순서 보장되지 않으며, 트리 구조로 저장됨
- 이진 탐색 트리 중 성능을 향상 시킨 Red-Black Tree로 구현되어있다.
- Comparator 구현으로 정렬 방법을 지정 가능
- 내부적으로 TreeMap으로 구현


</details>

<details>
    <summary><b>List와 Set을 비교해주세요.</b></summary>

- List 인터페이스
  - 데이터간 순서 유지
  - 데이터 중복 허용
- Set 인터페이스
  - 데이터간 순서 유지되지 않음
  - 데이터 중복을 허용하지 않음

### 🆀 해시 테이블을 이용하여 Set이 구현된 이유
- Key가 중복되지 않고 데이터 순서가 랜덤이라는 해시테이블이 특징이 Set의 특징과 일치
- 해시테이블에 데이터가 얼마나 많든간에 키를 검색할 때의 시간복잡도는 `O(1)`


**※ Reference**

- [기술 면접에서 list와 set의 차이를 물어보는 이유](https://www.youtube.com/watch?v=CMgpTGs_N_w)

</details>

--- 

<details>
    <summary><b>Java의 컴파일(실행) 과정을 설명해주세요.</b></summary> 

<br>

🗣️ 
_"javac컴파일러를 이용하여 자바 소스파일을 컴파일 하면 바이트 코드, 즉 실행파일이 만들어집니다. 
이후 JVM에 의해 실행될 때, 가장 먼저 클래스로더가 동작하여 실행에 필요한 실행파일을 찾고, 해당 파일의 유효성 검사를 진행합니다. 이후 JVM의 실행엔진에 의해 실행파일은 기계어로 변환되는데, 인터프리터가 코드를 한 줄씩 읽고 기계어를 변환합니다. 이 때 반복되는 코드가 있으면 JIT컴파일러에 의해 해당부분이 전부 네이티브 코드로 변환되고, 이후 인터프리터는 변환된 코드를 바로 사용합니다. 이후에는 OS에 의해 실행됩니다"_


<br>

1. 컴파일
   - 자바 소스파일을 javac 컴파일러를 이용하여 바이트 코드(.class 파일)로 컴파일.

2. 클래스 로딩 & 유효성 검사
   - 프로그램 실행시 클래스로더가 가장 먼저 동작하며, 실행에 필요한 실행 파일(.class 파일)을 찾아준다.
   - Byte code verifier 가 준비된 실행파일의 유효성을 검사
     - 유효하지 않으면 JVM단에서 에러가 발생하여 실행되지 않음
3. 기계어로 변환
   - JVM의 실행엔진(인터프리터, JIT컴파일러)에 의해 기계어로 변환
   - 인터프리터를 통해 바이트 코드를 한 줄씩 기계어로 변환하다가, 반복되는 코드가 있으면 JIT컴파일러를 이용하여 해당 코드를 네이티브 코드로 변환.
   - 인터프리터는 네이티브 코드로 변환된 코드를 바로 사용.
4. 운영체제에 의해 실행

</details>

<details>
    <summary><b>JDK, JRE, JVM에 대해 설명해주세요.</b></summary> 

<br>


🗣️ 먼저 JVM이란, 플랫폼에 종속받지 않고 CPU가 Java를 실행할 수 있게 하는 가상 컴퓨터입니다. 바이트 코드를 OS에 특화된 기계어로 변환하고, 실행하며 따라서 JVM은 플랫폼에 종속적이라는 특징이 있습니다. JRE는 자바 애플리케이션을 실행할 수 있도록 구성된 배포판입니다. JVM과 자바 클래스 라이브러리를 포함합니다. JDK는 JRE와 개발에 필요한 도구인 javac컴파일러, javadoc 등을 필요하여 자바 애플리케이션을 개발할 수 있는 환경을 제공합니다. 


<br>

![image](https://user-images.githubusercontent.com/65555299/231639514-91894f15-939d-41c3-9793-2890818bea44.png)

### JVM(Java Virtual Machine)

- **_플랫폼(OS)에 종속받지 않고 CPU가 Java를 인식, 실행할 수 있게 하는 가상 컴퓨터_**
- Java 바이트 코드(.class 파일)를 OS에 특화된 기계어로 `변환`(인터프리터와 JIT컴파일러) `실행`한다.
- Java 바이트 코드가 실행될 수 있는 `가상 환경`을 제공
- 바이트 코드를 실행하는 표준(JVM 자체는 표준)이자 구현체(특정 밴더가 구현한 JVM)다.
  - JVM 밴더: 오라클, 아마존, Azul...
- **_JVM은 특정 플랫폼에 종속적_**
  - 바이트 코드를 특정 OS에 맞게 변환해야하므로

  > JVM, JRE, and JDK are platform dependent because the configuration of each OS is different from each other. However, Java is platform independent.


### JRE(Java Runtime Environment)

> JRE is the implementation of Java Virtual Machine (JVM)
- 자바 애플리케이션을 실행할 수 있도록 구성된 배포판. `JVM + Java Class Library`로 구성
- JVM과 핵심 라이브러리 및 자바 런타임 환경에서 사용하는 프로퍼티 세팅이나 리소스 파일을 가지고 있다. (JVM + 라이브러리)
- 개발 관련 도구는 포함하지 않는다.(개발 관련 도구는 JDK에서 제공)

### JDK(Java Development Kit)
- _**JRE + 개발에 필요한 툴(javac 컴파일러, javadoc, ...)**_

</details>

<details>
    <summary><b>JVM의 메모리 구조에 대해 설명해주세요.</b></summary>

- `메소드 영역`
  - 클래스 레벨의 정보(클래스 이름, 부모 클래스 이름, 메소드, 변수) 코드 저장.
  - **모든 쓰레드에서 사용하는 공유 자원**이다.
  - JVM 구동 시작 시 생성, 종료 시 까지 유지
  - ~~Runtime Constant Pool~~
  - (Java8 부터는 static 변수가 힙 영역에 저장)
- `힙 영역`
  - new 연산자를 통해 생성된 객체(=인스턴스. 인스턴스 변수 포함)를 저장.
  - **모든 쓰레드에서 사용하는 공유자원**이다.
  - 객체가 더 이상 쓰이지 않거나 null 선언 시 GC가 청소
- `스택 영역`
  - 쓰레드마다 런타임 스택을 만들고, 메소드 호출을 스택 프레임이라 부르는 블럭을 쌓는다.
  - 쓰레드를 종료하면 런타임 스택도 사라진다.
  - **_스택, PC레지스터, 네이티브 메소드 스택은 특정 쓰레드에 종속되는 자원_**. 쓰레드간 공유하지 않는다.
- PC(Program Counter) 레지스터
  - 쓰레드마다 쓰레드 내 현재 실행할 스택 프레임을 가리키는 포인터가 생성된다.
- 네이티브 메소드 스택
  - 네이티브 메소드 호출할 때 생기는 메서드 스택
  - https://javapapers.com/core-java/java-jvm-run-time-data-areas/#Program_Counter_PC_Register


</details>

---