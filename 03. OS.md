## Process & Thread

<details>
    <summary><b>Process 개념</b></summary>

## 정리
### 프로세스란?
- 실행중인 프로그램
- 컴퓨터 작업의 단위
### 구조
- Stack
  - 함수를 호출할 때의 임시 데이터 저장 장소
  - 함수 매개변수, 복귀 주소, 지역 변수
  - 프로그램 실행중 동적으로 변한다.
- Heap
  - 프로그램 실행 중 동적으로 할당되는 메모리
  - 프로그램 실행중 동적으로 변한다.
- Data
  - 전역 변수, static 변수, 초기화 되지 않는 변수
  - 프로그램 실행중에 크기가 고정됨
- Code
  - 실행 코드
  - 프로그램 실행중에 크기가 고정됨
### 프로그램 vs 프로세스
- 프로그램은 작업을 실행할 파일로 실행 파일로 불린다. `프로그램`이 메모리에 적재된 것이 `프로세스`이다.
### 프로세스의 주소 공간을 구분한 이유가 있을까요?
- Stack vs Data
  - 역할을 나누기 위해 분배하였다. 스택 영역은 흐름을 관리하고, 데이터 영역은 전역 변수, static 변수를 관리한다.
  - 또한 멀티 스레드의 경우 스택 영역은 각각 가지지만 데이터 영역은 공유한다. 이를 통해 메모리를 절약할 수 있다.
### 데몬 프로세스
- 서비스의 요청에 대해 응답하기 위해 백그라운드에서 실행중인 프로세스
## 예상 질문
- 프로세스란?
- 프로세스의 주소 공간은?
- 주소 공간이 여러 개로 나누어진 이유는?
## 참조
- https://velog.io/@klm03025/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84
</details>

<details>
    <summary><b>Multi Process</b></summary>

## 정리
### Multi Process 란?
- 하나의 프로그램을 여러 개의 프로세스로 구성하여 프로세스가 병렬적으로 작업을 처리하는 것
- 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 끼치지 않는다는 장점이 있다.
- 비교적 많은 메모리를 차지한다.
- 예) 크롬 브라우저, 크롬 브라우저에서 탭은 프로세스에 의해 동작한다. 따라서 하나의 탭이 오류가 나도 다른 탭에 영향을 미치지 않는다.
## 예상 질문
- 
## 참조
-
</details>

<details>
    <summary><b>PCB(Process Control Block)</b></summary>

## 정리
### PCB 란?
- 프로세스와 연관된 정보들을 가지고 있는 저장소 역할을 수행한다. 
- 프로세스 정보
  - 프로세스 상태: 현재 프로세스의 상태(new, running, waiting, ready, halted)
  - 프로그램 카운터: 해당 프로세스가 다음에 실행할 명령어의 주소
  - CPU 레지스터: 컴퓨터 구조에 따라 가지는 레지스터들
  - CPU 스케쥴링 정보: 프로세스의 우선순위, 스케줄 큐의 포인터, 다른 스케줄의 매개변수 등 스케줄링 관련 정보
  - 메모리 관리 정보
  - 회계정보: CPU 사용 시간, 경과된 시간 등등
  - 입출력 상태 정보: 프로세스에 할당된 입출력 장치들, 열린 파일 목록
## 예상 질문
- PCB 에 프로세스 정보를 저장하는 이유는?
## 참조
-
</details>

<details>
    <summary><b>Context, Context Switch</b></summary>

## 정리
### Context Switch 란?
- 이전의 Task 의 상태를 PCB 에 보관하고 새로운 Task 의 보관된 상태를 복구하는 작업
- Context Switch 를 하는 동안 다른 작업을 할 수 없기 때문에 순수한 오버헤드가 된다.
### Process vs Thread 비용
- 비용은 프로세스가 더 많이 든다.
- 스레드는 Stack 영역만 변경을 진행하고, 프로세스는 모든 영역을 변경해야 하기 때문이다.
### 발생 시기
- 인터럽트 발생
- 실행중인 CPU 사용 허가 시간을 모두 소모할 경우
- I/O 입출력을 위해 대기할 경우
## 예상 질문
- Context Switching 이란?
- 언제 발생할까요?
## 참조
- https://gona.tistory.com/6
</details>

<details>
    <summary><b>Thread 개념</b></summary>

## 정리
### Thread 란?
- 프로세스의 실행 흐름의 단위
- 스레드는 프로세스 내에서 Stack 을 할당받고 Code, Data, Heap 영역은 공유한다.
- 스레드마다 PC 레지스터를 할당
  - Context Switching 시 이용
### 스택
- 스택을 독립적으로 할당받으므로 독립적인 함수 호출이 가능하다. 이는 독립적으로 실행 흐름을 가져갈 수 있는 것을 의미한다.
## 예상 질문
- 스레드에 대해 설명해주세요
- 스택을 독립적으로 할당하는 이유
- PC 레지스터를 독립적으로 할당하는 이유
## 참조
-
</details>

<details>
    <summary><b>Multi Thread</b></summary>

## 정리
### Multi Thread 란?
- 하나의 프로세스를 여러 개의 스레드로 구성하여 자원을 공유하면서 작업을 수행하는 것
- 장점
  - 적은 메모리 공간을 차지하고 Context Switching 이 비교적 빠르다.
- 단점
  - 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다.
  - 동기화 문제 존재
## 예상 질문
- 
## 참조
-
</details>

<details>
    <summary><b>Multi Process Vs. Multi Thread</b></summary>

## 정리
- 기본적으로 멀티 스레드를 쓰는 것이 좋다. 
- 멀티 프로세스로 할 경우 자원을 할당하는 시스템 콜이 있으므로 멀티 스레드로 할 경우 자원을 효율적으로 관리할 수 있다.
- Context Switching 시 멀티 스레드는 stack 만 변경하기 때문에 효율적이다.
> 시스템 콜: OS 가 제공하는 인터페이스
## 예상 질문
- 
## 참조
-
</details>

<details>
    <summary><b>IPC(Inter Process Communication)</b></summary>

## 정리
### IPC 란?
- 프로세스 간의 통신을 의미
- 프로세스는 서로 독립되어 있으므로 서로 같의 데이터를 공유할 때 이용하게 된다.
## 예상 질문
- 
## 참조
- 
</details>

<details>
    <summary><b>공유 메모리와 메시지 전달 모델</b></summary>

## 정리
### 공유 메모리
- 프로세스끼리 특정 공통의 메모리 영역을 공유하며 상호간 통신하는 방법
#### 장단점
- 장점
  - 커널의 관여 없이 메모리를 직접 사용하여 IPC 속도가 빠르다.
  - 프로그램 레벨에서 통신 기능을 제공하여, 자유로운 통신이 가능하다.
- 단점
  - 메시지 전달 방식이 아니기 때문에 데이터를 읽어야 하는 시점을 알 수 없다.
  - 데이터를 읽기 위한 별도의 동기화 기술이 필요하다.
### 메시지 전달
- 커널 메모리 영역에 메시지 전달을 위한 채널을 만들어서 협력하는 프로세스들 사이에 메시지 형태로 정보를 송수신하는 방법
#### 장단점
- 장점
  - 커널에서 데이터를 주고 받는 것을 컨트롤할 수 있어 별도의 동기화 로직이 없어도 된다.
- 단점
  - 커널을 통해서 데이터를 주고 받기 때문에 공유 메모리 모델에 비해 느리다.
## 예상 질문
- 
## 참조
- https://steady-coding.tistory.com/508
</details>

<details>
    <summary><b>Multi Process/Thread 환경의 동기화 문제해결. Mutex, Semaphore</b></summary>

## 정리
### Mutex
- 자원에 대한 접근을 동기화하기 위해 사용되는 상호배제 기술
- 임계 영역을 생성하여 하나의 쓰레드만 접근이 가능하게 한다.
- 해당 쓰레드가 임계 영역을 나갈 때만 락이 해제된다.
### Semaphore
- Mutex 와 마찬가지로 상호배제 기술이다.
- 락을 걸지 않은 쓰레드도 Signal 을 보내 락을 해제할 수 있다.
## 예상 질문
- 
## 참조
- https://mangkyu.tistory.com/104
</details>

<details>
    <summary><b>Deadlock</b></summary>

## 정리
### Deadlock 이란?
- 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태
### 발생 조건
- 상호 배제
  - 자원은 한번에 하나의 프로세스만이 사용할 수 있어야 한다.
- 점유 대기
  - 하나 이상의 자원을 점유하고 있으면서 다른 작업이 점유한 자원을 추가로 얻기 위해서는 대기해야 한다.
- 비선점
  - 다른 작업이 점유한 자원을 도중에 강제로 빼앗을 수 없다.
- 순환 대기
  - 프로세스가 서로의 자원을 대기하는 모습이 순환하여 이루어지는 경우
### 해결 방법
- 4가지 조건 중 하나 이상을 해결하는 것
- 교착 상태가 발생하는 것을 탐지하고 회복시키는 탐지와 회복 방법
## 예상 질문
- 
## 참조
- https://jwprogramming.tistory.com/12
</details>

---

## Memory

<details>
    <summary><b>Paging</b></summary>

## 정리
### 동적 메모리 할당
- 최악 적합이 가장 느리고 일반적으로 최초 적합이 가장 빠르다.
#### 최초 적합
- 처음 발견한 가용공간에 할당한다.
#### 최적 적합
- 사용 가능한 공간 중에서 가장 작은 곳에 할당한다.
#### 최악 적합
- 가장 큰 공간에 할당한다.
### 메모리 단편화
- 메모리의 빈 공간이 여러 개의 작은 조각으로 나뉘는 것
- 메모리의 가용 공간을 줄이거나 읽기 및 쓰기 속도를 늦추는 문제 발생
- 외부 단편화와 내부 단편화가 존재
#### 외부 단편화
- 프로세스가 메모리에 적재되고 제거되는 일이 반복되면서 남아있는 프로세스 공간 사이에 작은 잉여 공간이 생기는 현상
#### 내부 단편화
- 프로세스가 할당 받은 메모리 공간 중 사용하지 않고 남은 부분이 발생하는 현상
### 페이징이란?
- 프로세스가 요구하는 메모리 공간을 고정 크기로 분리하고 배치하는 방법
- 내부 단편화를 야기할 수 있다.
### 보호 및 공유
- 페이지 테이블을 두어서 프레임 번호와 유효-무효 여부를 적재한다.
  - 이를 통해 해당 페이지가 실제 적재되었는지 아닌지 판단하다.
- 공통의 코드라면 페이지를 공유할 수 있다.
  - 이를 통해 메모리 관리를 효율적으로 할 수 있다.
### TLB
- 페이지 테이블이 메인 메모리에 있을 경우 CPU 에 의한 메인 메모리의 접근을 줄이기 위해 나온 개념이다.
- 하드웨어적으로 페이지 테이블의 캐쉬 역할을 수행한다.
### MMU (Memory Management Unit)
- CPU 코어 안에 탑재되어 가상 메모리를 물리 메모리로 변환해주는 장치
- TLB 를 이용하여 변환한다.
  - 이곳을 먼저 확인하고 없으면 페이지 테이블을 확인한다.
- 장점
  - 모든 프로세스마다 같은 주소를 사용할 수 있게 한다.
  - 서로 떨어진 데이터를 연속적으로 표현할 수 있다.
## 예상 질문
- 
## 참조
-
</details>

<details>
    <summary><b>Segmentation</b></summary>

## 정리
### 세그멘테이션이란?
- 프로세스가 요구하는 메모리 공간을 서로 다른 크기를 가진 세크먼트로 분할하여 배치하는 방법
- 외부 단편화를 야기할 수 있다.
## 예상 질문
- 
## 참조
-
</details>

<details>
    <summary><b>가상 메모리</b></summary>

## 정리
### 가상 메모리란?
- 프로세스가 요구하는 메모리 전체를 할당하지 않고도 프로세스 작업을 수행하기 위해 도입된 개념
- 프로세스가 요구하는 전체 메모리 중 당장 필요한 부분을 실제 메모리에, 필요없는 부분을 가상 메모리에 할당하는 식으로 동작
### 장단점
- 장점
  - 물리 메모리의 크기에 제약을 받지 않을 수 있다.
  - 응답 시간이 일정하면서 CPU 이용률과 처리율이 높아진다.
- 단점
  - 속도가 느리다.
### Page vs Frame
- 페이지는 Logical 메모리를 동일한 크기로 나눈 것이다.
- 프레임은 Physical 메모리를 동일한 크기로 나눈 것이다.
### 가상 메모리가 가능한 이유
- 요구 페이징
  - 프로세스가 요구하는 모든 메모리를 물리 메모리에 올리지 않고 필요한 페이지만 적재하는 것
### 만약 필요한 페이지가 없을 경우
- Page Fault
  - 물리 메모리에 없는 페이지에 접근하는 것
- 처리 과정
  1. CPU 가 특정 페이지에 접근하여 메모리 참조가 유효인지 무효 상태인지 파악
  2. 만약 무효한 페이지라면 프로세스는 중단한다. 
  3. 만약 유효한 참조인데 페이지가 아직 메모리에 없다면 적재한다.
     - 빈공간을 찾고 보조저장장치에서 페이지를 불러온다.
  4. 트랩에 의해 중단되었던 명령어를 다시 수행한다.
### Thrashing
- 페이지 폴트율이 높은 상황
- 메모리에 다양한 프로세스들이 올라와서 페이지 교체가 빈번하게 일어나면 메모리의 유효 공간은 줄어들고, CPU 의 가동시간이 올라가게 된다.
- 해결 방법
  - Working Set
    - 대부분의 프로세스가 일정한 페이지만 집중적으로 참조한다는 특성을 이용한다.
    - 일정 시간동안 참조되는 페이지 개수를 확인하고 해당 페이지들이 들어갈 메모리 공간(프레임)이 확보되면 그 때 메모리에 올리는 방법
  - Page Fault Frequency
    - Page Fault 의 횟수에 상한과 하한을 두는 방식이다.
    - 상한을 넘으면 지급하는 프레임 개수를 늘린다.
    - 하한을 넘으면 지금하는 프레임 개수를 줄인다.
## 예상 질문
- 페이지 크기가 커짐에 따라 장단점
## 참조
- https://jhnyang.tistory.com/290
</details>

<details>
    <summary><b>페이지 교체 알고리즘. LRU, LFU</b></summary>

## 정리
### 페이지 교체 알고리즘
- 프로그램 실행 시 모든 항목이 물리 메모리에 올라오지 않고, 프로세스 동작에 필요한 페이지만 요청하게 된다.
- 페이지 부재를 방지하기 위해 원하는 페이지를 보조저장장치에서 가져오는 작업을 수행한다.
#### 종류
- LIFO
  - 가장 오래된 페이지를 교체한다.
- OPT
  - 앞으로 사용되지 않을 것 같은 페이지를 교체한다.
- LRU
  - 가장 오랫동안 사용되지 않은 페이지를 교체한다.
  - count 를 세거나 stack 형식으로 구현
- LFU
  - 가장 사용 빈도가 적은 페이지를 교체한다.
## 예상 질문
- 
## 참조
-
</details>
