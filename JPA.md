### 동적쿼리 vs 정적쿼리

- 정적 쿼리 : 어떤 파라미터가 들어와도 쿼리의 형태가 동일한 경우
- 동적 쿼리 : 어떤 파라미터에 따라 쿼리의 형태가 달라지는 경우
    - 조건을 주냐 안주냐로 쿼리의 형태가 달라지는 경우 (if문)

# JDBC 등장 배경

- 데이터베이스마다 사용법이 다른 문제
    - 데이터베이스가 변경되면 애플리케이션의 코드도 모두 변경되어야 한다.
    - 데이터베이스마다 사용방법을 익혀야 한다.

## JDBC란

- 자바에서 데이터베이스에 접속할 수 있도록 지원하는 자바 API
    - 데이터베이스 연결, 요청 등을 추상화하여 표준 인터페이스로 제공
    - 인터페이스를 각각의 DB 벤더에서 자신의 DB에 맞도록 구현해서 라이브러리로 제공 = JDBC 드라이버
- 데이터베이스에서 자료를 쿼리하거나 업데이트하는 방법을 제공한다.
- 추상화하기는 했지만 모든 것을 공통화하지는 못했기 때문에 데이터베이스마다 사용하는 방법이 다른 것이 존재한다.
    - 데이터베이스가 변경되면 JDBC 코드는 변경하지 않아도 SQL을 사용하는 데이터베이스에 맞도록 변경해야 한다.

## SQL Mapper

- JDBC를 더욱 편리하게 사용하도록 도와준다.
    - SQL 응답 결과를 객체로 편리하게 변환해준다.
    - JDBC 반복 코드를 제거해준다.
- 여전히 SQL을 개발자가 직접 작성해야 한다.
    - 하지만 SQL만 작성해주면 다른 번거로운 작업은 SQL Mapper가 모두 해결해준다.
- 대표예시 : JDBC Template, MyBatis

### MyBatis

- 기본적으로 JdbcTemplate이 제공하는 대부분의 기능을 제공한다.
- SQL을 XML로 작성할 수 있고, 동적 쿼리를 보다 편리하게 작성할 수 있다는 것이 장점이다.
    - SQL 쿼리를 다른 파일에 작성하여 프로그램 코드와 분리할 수 있다.
- MyBatis를 사용하기 위해서는 매핑 XML을 호출해주는 매퍼 인터페이스가 필요하다.
    - @Mapper 애노테이션을 사용하면 해당 인터페이스가 MyBatis에서 사용하는 인터페이스임을 인식한다.
        - 프록시 기술을 사용하여 애플리케이션 로딩 시점에 Mapper 인터페이스의 구현체를 만든다.
    - 사용할 SQL이 작성된 XML은 resources 아래에 두면 자동으로 인식된다.
- [@Mapper vs @Repository](https://pamyferret.tistory.com/69)
- 스프링의 MyBatis는 별다른 설정정보 없이도 MyBatis를 사용할 수 있도록 지원하며, 안정성 있는 기술을 제공하여 사용자가 인터페이스만 작성하여도 편하게 데이터베이스에 접근할 수 있도록 한다.
- 마찬가지로 프록시를 사용하여 커넥션을 가져오고 사용한다.
    - 커넥션을 생성해서 반환해주는 것이 스프링에 의해 자동으로 만들어지고 스프링 컨테이너 내에서 관리된다. = 싱글톤
    - 매퍼 인터페이스 구현체도 마찬가지로 스프링 컨테이너 내에서 관리된다.

`Connection` : JDBC에서 제공하는 커넥션 인터페이스

`DriverManager` : JDBC 드라이브 매니저, 해당 데이터베이스에 맞는 커넥션을 가져오는 역할을 한다.

→ 즉, 해당 데이터베이스에 맞는 커넥션 구현체를 형성해서 반환한다.

- 라이브러리에 있는 드라이버 목록을 자동으로 인식하여 드라이버들에게 가져올 수 있는 커넥션을 획득한다.
- 사용자가 전달한 데이터베이스 정보를 기반으로 가능한 커넥션 구현체를 찾아서 제공한다.

## 커넥션 풀

- 데이터베이스에 연결하기 위해서는 커넥션을 항상 가져야 한다.
- 커넥션을 얻기 위한 과정은?
    - DB 드라이버를 통해 커넥션을 조회하고, 가능하다면 TP/IP 커넥션을 연결한다. → 연결을 위한 네트워크 통신 동작이 발생한다.
    - 커넥션이 연결되면 사용자가 전달한 데이터베이스 정보를 DB에 전달한다.
    - ID, PW를 통해 내부 인증을 완료하고, 내부에 DB 세션을 생성하고, 커넥션이 성공적으로 생성 완료되었다는 응답을 보낸다.
    - 그러면 DB 드라이버는 커넥션 객체를 생성하여 클라이언트에게 반환한다.
- 위의 과정을 매번 수행하면 너무 시간도 리소스도 많이 소모된다. 그래서 이를 해결하기 위해 커넥션을 미리 생성해두고 사용하는 커넥션 풀 방식을 사용.
    - 생성해놓은 커넥션을 재활용하는 방식
    - 애플리케이션 실행 시점에 필요한 만큼의 커넥션을 미리 생성하여 풀에 보관한다.
    - 사용이 완료된 커넥션은 절대 종료하지 않고 살아있는 상태로 커넥션 풀에 반환해야 한다.
    - 일정한 갯수만큼만 커넥션을 유지하기 때문에 DB에 무한정 연결이 생성되는 것을 막아 DB를 보호하는 효과도 있다.
- 적절한 커넥션 풀 숫자는 서비스의 특징과 애플리케이션 서버 스펙, DB 서버 스펙에 따라 다르기 때문에 성능 테스트를 통해서 정해야 한다.
- 대표적인 커넥션 풀 오픈소스는 HikariCP 등등 여러개가 있는데, 스프링부트 2.0 부터는 hikariCP를 기본 커넥션 풀로 제공한다.
    - 성능과 사용의 편리함, 안정성 측면에서 이미 검증이 되었기 때문
    - 스프링부트를 사용하게 되면 JDBC 라이브러리를 받아올 때 HikariCP를 자동으로 가져온다.
- 커넥션 풀에서 커넥션을 생성하는 작업은 애플리케이션의 실행 속도에 영향을 주지 않기 위해 별도의 쓰레드에서 작동한다.
    - 커넥션 풀에 커넥션을 채우는 것이 상대적으로 오래걸린다. → TCP/IP 통신을 통해 커넥션을 가져오기 때문에.
    - 그래서 별도의 스레드를 사용하여 커넥션 풀을 채워야 애플리케이션 실행 시간에 영향을 주지 않는 것이다.
- 커넥션 풀을 사용하게 되면 커넥션 close를 했을때 커넥션이 종료되는 것이 아니라 살아 있는 상태에서 반환이 되는 것이다.
    - HikariCP는 커넥션 프록시를 사용하여 전달하고, 실제 커넥션과 연결하여 사용하도록 한다.
        - 프록시가 실제 커넥션을 가지고 있음

## DataSource

- DriverManager를 사용하면 항상 새로운 커넥션을 생성해서 반환한다. → 커넥션 풀을 사용하지 않음
- 커넥션 풀을 사용하게 되어 변경하면 애플리케이션의 로직이 변경됨.
    - 의존관계가 DriverManager에서 HiakriCp로 변경되는 것이다.
    - **그래서 커넥션을 획득하는 방법 자체를 추상화해버림. = DataSource 인터페이스**
    - 구현은 Driver에게 맡기고 사용자는 인터페이스를 통해 해당하는 드라이버의 구현체를 받아서 사용만 하는 방식으로 변경
- DataSource 인터페이스에만 의존하도록 애플리케이션 로직을 변경하면 새로운 커넥션을 획득하고 싶은 경우에는 DriverManager 사용, 아니면 HikariCP 커넥션 풀 구현체를 사용하도록 하면 된다.
    - 즉, 애플리케이션의 로직 변경이 일어나지 않게 되었다는 것이 포인트
- 하지만 DriverManger는 DataSource 인터페이스를 사용하지 않기 때문에 인터페이스가 아닌 DriverManager를 직접 사용해야 한다.
    - 결국 커넥션 풀 방식을 변경하려면 애플리케이션 로직을 모두 변경해야 한다.
    - 이를 해결하기 위해 스프링은 DataSource를 사용하는 DriverManagerDataSource라는 구현체를 제공하고 있다.

### JDBCTemplate

- JDBC의 반복되는 코드를 해결하기 위한 기술이다.
    - 템플릿 콜백 패턴 사용
    - 템플릿 : 기본적인 틀은 제공하면서 원하는 것만 변경해서 사용할 수 있도록 해주는 것
- 커넥션을 받아오고, SQL을 실행하고 예외를 전달하는 것까지 모두 처리해준다.
- SQL과 파라미터만 전달하면 원하는 쿼리를 바로 적용할 수 있다.
    - SELECT 하는 경우 원하는 객체의 형태로 받아오기 위해서는 Mapper가 필요하다.
        - RowMapper는 데이터베이스의 반환 결과인 ResultSet을 원하는 객체로 변환해준다.
        - resultSet을 반복적으로 조회하여 객체로 변환하는 과정을 자동으로 수행해준다.
- JdbcTemplate은 편리함을 제공해주기는 하지만 동적 쿼리 작성이 어렵다는 문제가 있다.
    - 값에 따라 변경되는 쿼리문을 동작하기가 힘들다.
- queryForObject() : 단건 조회를 위한 메소드
- query() : 다건 조회를 위한 메소드
- 두 메소드 모두 원하는 객체 형태로 받아오기 위해서는 RowMapper가 필요하다.

### NamedParameterJdbcTemplate

- 기존의 JdbcTemplate는 쿼리에 제공하는 파라미터가 순서대로 바인딩된다.
    - 쿼리의 순서가 바뀌거나 순서가 제대로 지켜지지 않는 경우 문제가 발생하는데, 이것을 발견하기가 매우 어렵다는 것이 문제이다.
    - 그래서 NamedParameterJdbcTemplate를 통해 이름을 지정해서 파라미터를 바인딩할 수 있도록 지원한다.
- 파라미터는 Map의 형태로 (key, value) 형태로 전달해야 한다.

### SimpleJdbcInsert

- insert query sql을 직접 작성하지 않아도 되도록 편리한 기능을 제공한다.
- 생성 시점에 데이터베이스 테이블의 메타 데이터를 조회하기 때문에 어떤 테이블에 어떤 컬럼이 있는지 확인할 수 있다.
- sQL을 전달하지 않고 파라미터 값만 SqlParameterSource 형태로 전달해주면 된다.