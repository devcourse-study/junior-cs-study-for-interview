
<details>
    <summary><b>관계형 데이터베이스</b></summary> 

# 관계형 데이터베이스란?

관계형 데이터베이스란, 데이터를 하나 이상의 행과 열로 이루어진 테이블(또는 '관계')에 저장하고 테이블간 데이터의 고유값(Primary Key)을 참조하여 서로 종속되는 관계를 표현하는 데이터 베이스 구조를 말한다.

## 관계형 데이터베이스는 왜 사용할까

### 관계형 데이터베이스의 이점

- RDB는 테이블 구조를 사용하므로 직관적인 데이터 표현 방법을 제공
- 조인 기능을 활용하여 여러 데이터간의 관계를 쉽게 이해하고, 관련된 데이터에 쉽게 접근할 수 있다.
- 데이터의 `무결성`을 보장하고, `중복을 최소화`할 수 있다.

### 단점

- 기존에 작성된 스키마 변경이 어렵다.
    - 이미 생성된 테이블에서 컬럼의 확장이 어렵다.
    - 새로 추가된 컬럼에 대해서 기존 데이터들에게 기본값이나 null을 할당해야한다.

**※ Reference**

- https://cloud.google.com/learn/what-is-a-relational-database?hl=ko#section-2


</details> 

<details>
    <summary><b>Key의 종류</b></summary> 


# Key

![image](https://user-images.githubusercontent.com/65555299/233393071-618e8537-73e9-4125-a514-75801dc2d188.png)


### 슈퍼키(Super Key)

- `유일성`의 특성을 만족하는 속성 또는 속성들의 집합
- 유일성(uniqueness): 하나의 릴레이션에서 키로 지정된 속성 값이 튜플마다 다를 때 `유일성`을 만족한다.

### 후보키(Candidate Key)

- `유일성`과 `최소성`을 만족하는 속성 또는 속성들의 집합
- 최소성(minimality):
    - 꼭 필요한 최소한의 속성들로 `유일성`을 만족시킬 수 있는지를 나타내는 특성
    - 하나의 속성으로 구성된 키는 당연히 최소성을 만족
- 속성 2개로 이루어진 속성 집합이 `유일성`을 만족하지만, 속성 1개로도 유일성을 만족한다면 해당 속성 집합은 `최소성`을 만족시키지 못하는 것이다.
    - (고객아이디, 고객이름) 은 `유일성`은 만족하나, (고객아이디) 만으로 `유일성`을 만족하므로 (고객아이디, 고객이름) 는 `최소성`을 만족시키지 못함. 따라서 후보키가 될 수 없다.


### 기본키(Primary Key)

- **_후보키 중 선택한 main key로써, 각 row를 유일하게 구분하는 컬럼 또는 컬럼 집합_**
- **_기본키는 널 값을 가질 수 없고, 중복된 값을 가질 수 없다._**
- 기본키는 테이블 당 1개만 지정해야 한다.
- 기본키를 선택하는 기준
    - 널 값을 가질 수 있는 속성이 포함된 후보키는 기본키로 부적합하다.
    - 값이 자주 변경될 수 있는 속성이 포함된 후보키는 기본키로 부적합하다.
        - 값이 변경되면 변경될 때마다 기본키의 값으로 적합한지 확인해야한다.
    - 단순한 후보키를 기본키로 선택한다.
        - 자릿수가 적은 정수나 단순 문자열이 단순한 후보키


### 대체키(Alternate Key)

- 기본키로 선택되지 못한 후보키들

### 외래키(Foreign Key)

- **_다른 테이블의 기본키를 그대로 참조하는 컬럼_**
- _참조되는 릴레이션의 기본키가 아닌 다른 속성을 외래키가 참조한다면 어떻게 될까?_
    - 기본키가 아닌 속성은 튜플을 유일하게 구별하기 어렵기 때문에 참조되는 릴레이션에서 관련있는 튜플을 검색 못할 수도 있다.

### Composite Key

<img width="300" alt="image" src="https://user-images.githubusercontent.com/65555299/233396526-bc7febd2-7d18-43dc-8aac-38fa78aae516.png">

- 테이블에서 튜플을 식별할 수 있는 두 개 이상의 컬럼으로 구성된 후보키를 말한다.

</details> 

---

<details>
    <summary><b>인덱스 개념, 필요성</b></summary>

# 인덱스

**개요**

<img src="https://velog.velcdn.com/images/balparang/post/4ebf9e54-df43-4442-8b22-a4e1e40cb512/image.png" width="400">

위 같은 테이블에서 age가 20인 행을 찾기 위해서 컴퓨터는 모든 row를 순차적으로 탐색할 것이다. 행이 많아진다면 이런 방식은 많은 시간이 소요될 수 밖에 없다.

<img src="https://velog.velcdn.com/images/balparang/post/68a3af2b-f8d9-43c2-8dea-a8145a848b40/image.png" width="400">

따라서 컬럼을 복제해서 정렬해둔 다음에 이분 탐색으로 빠르게 행을 찾아 나간다.

### 인덱스

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcBQD97%2FbtqKRtpm2pl%2Frmo7jTbiiE9tsSQsUg0JPK%2Fimg.png">

- 인덱스
  - 자료를 쉽고 빠르게 찾을 수 있도록 만든 데이터 구조. 책의 색인을 통해 원하는 정보를 빠르게 찾는 것처럼 인덱스도 그와 같은 역할
- 데이터베이스의 Index
  - _**추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조**_
  - 원하는 데이터를 빨리 찾기 위해 **_투플의 키 값에 대한 물리적 위치_** 를 기록해둔 자료구조이다.

### Index를 사용하는 이유

- Table에 데이터를 지속적으로 저장하게 되면 내부적으로 순서 없이 쌓이게 된다.
- 특정 조건을 만족하는 데이터를 찾고자 WHERE절을 사용한다면 Table의 ***튜플을 처음부터 끝까지 모두 접근하여 검색조건과 일치하는지 비교하는 과정(=`Table Full Scan`)*** 이 필요하다.
- 특정 컬럼에 대한 Index를 생성해 놓은 경우 해당 속성에 대하여 `search-key`가 정렬되어 저장되어 있기 때문에 조건 검색(SELECT ~ WHERE) 속도가 굉장히 빠르다.

## Index 구조

- 인덱스는 B Tree, B+Tree, Hash, Bitmap 등으로 구현 가능
  - 일반적인 RDBMS는 B+Tree를 주로 사용
- 인덱스를 생성하면 **_특정 컬럼의 값을 기준으로 정렬하여 물리적 위치와 함께 별도 파일에 저장_** 된다.
  - 리프 노드에는 해당 데이터의 저장 위치에 대응하는 rowID(RID, Row Identify, 테이블의 행에 대한 논리적 위치)를 가지고 있어 찾고자 하는 행을 바로 찾을 수 있다.
- 인덱스에 저장되는 속성 값을 `search-key`값이라고 하고, 실제 데이터의 물리적 위치를 저장한 값을 `pointer` 라고 한다.
- **_인덱스는 순서대로 정렬된 `search-key`값과 `pointer`값만 저장하기 때문에 table 보다 적은 공간을 차지한다._**

### Index의 관리

DBMS는 index를 항상 정렬된 상태를 최신으로 유지해야 원하는 값을 빠르게 탐색 가능. 따라서 `INSERT`, `UPDATE`, `DELETE`문이 수행된다면 다음과 같은 연산이 추가적으로 필요하고 그에 따라 오버헤드가 발생한다.

- `INSERT`: 새로운 데이터에 대한 인덱스를 추가한다.
- `UPDATE`: 기존의 인덱스를 `사용하지 않음`으로 처리하고, 갱신된 데이터에 대해 인덱스를 추가한다.
- `DELETE`: 삭제하는 데이터의 인덱스를 `사용하지 않음`으로 처리


## 인덱스의 장단점

### 장점

- **_최대 장점은 검색 속도 향상(`SELECT~WHERE~`)이다._**
  - 데이터 검색 시 모든 튜플을 순차적으로 검색, 비교하는 `Table Full Scan`을 하지 않고 인덱스에 정렬된 데이터를 통해 빠르게 원하는 튜플에 접근 가능
- SELECT문 외에도 UPDATE문이나 DELETE문의 성능도 함께 향상된다. 해당 연산을 수행하려면 해당 대상을 조회해야만 작업을 할 수 있기 때문
  ```sql
  // 'haero'라는 이름을 업데이트 해주기 위해서는 'haero'를 조회해야 한다.
  UPDATE USER SET NAME = `haero77` WHERE NAME = 'haero';
  ```

### 단점 2가지

1. 추가 저장 공간 필요
  - Index를 생성하면 Index 자료구조를 위한 공간이 추가적으로 필요.
  - 보통 테이블 크기의 10% 공간을 차지.
2. 느린 데이터 변경 작업
  - 검색이 아닌 데이터 변경 작업, 즉 `INSERT`, `UPDATE`, `DELETE`가 자주 발생하면 성능이 나빠질 수 있다.
  - 보통 B+Tree 구조의 경우 데이터를 변경할 때마다 트리 구조가 변경될 수 있다. 즉, **_인덱스를 재구성하기 위한 오버헤드가 발생_** 한다.

<br>

# 기타

### 인덱스는 언제 사용하면 좋을까?

- `INSERT`, `UPDATE`, `DELETE가` **_자주 발생하지 않는 컬럼_**
  - 삽입, 수정, 삭제가 빈번한 속성에 인덱스를 걸면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과 발생
  - `UPDATE`와 `DELETE`는 기존의 인덱스를 삭제하지 않고 `사용하지 않음` 처리를 한다.
    - 어떤 테이블에 `UPDATE`, `DELETE`가 자주 발생한다면 실제 데이터는 10만 건이지만, 인덱스는 100만 건이 넘어가므로 SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능 하락 가능성 있음.
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼

### 기본키는 인덱스가 필요없다.

Primary Key의 경우 자동으로 정렬이 되어있기 때문에 굳이 인덱스를 만들 필요 없다. 이것을 `클러스터형 인덱스`라고 한다.

---

**※ Reference**

- [index가 뭔지 설명해보세요 (개발면접시간) - 코딩애플](https://www.youtube.com/watch?v=iNvYsGKelYs)
- [[Database] 인덱스(index)란? - 망나니 개발자](https://mangkyu.tistory.com/96)
- [[MySQL] B-Tree로 인덱스(Index)에 대해 쉽고 완벽하게 이해하기 - 망나니개발자](https://mangkyu.tistory.com/286)

---

### 추가적으로 공부해 볼 것

- 왜 JOIN절에 인덱스를 사용하는 것이 좋을까?
- 인덱스 Random Access

---

</details> 

<details>
    <summary><b>인덱스를 어느 column에 사용할까</b></summary> 

## ⭐️⭐️ 인덱스를 어느 컬럼에 사용하는 것이 좋을까?

- 인덱스는 `WHERE` 절에서 ***자주 조회되고, 수정 빈도가 낮으며, 카디널리티는 높고, 선택도가 낮은 컬럼***을 선택해서 설정하는 것이 가장 좋다.

| 기준                 | 적합성                          |
|--------------------|------------------------------|
| 카디널리티(Cardinality) | 높을수록 적합(데이터 중복이 적을수록 적합)     |
| 선택도(Selectivity)   | 낮을수록 적합                      |
| 조회 활용도             | 높을수록 적합(WHERE절에서 많이 사용되면 적합) |
| 수정 빈도              | 낮을 수록 적합                     |

> 💡 `카디널리티`란?
>   - ***데이터가 중복되지 않는 정도***를 뜻한다. 데이터가 중복되지 않을수록 카디널리티가 높다.
>   - 예) 주민등록번호는 중복되는 값이 없으므로 카디널리티가 높다.
>   - 예) 성별의 경우 [Male/Female] 값이 중복되어 카디널리티가 낮다.

> 💡 `선택도`란?
>   - ***데이터에서 특정 값을 잘 골라낼 수 있는 정도***를 뜻한다.
>   - 선택도가 1이면 모든 데이터가 unique함을 의미한다.

### Index를 효과적으로 사용하는 방법

- SELECT WHERE 절에 자주 사용되는 컬럼에 대해 인덱스르 생성하는 것이 좋다.
  - 인덱스는 `SELECT~ WHERE~` 절에서 검색 성능을 향상시키기 위해서 사용한다. 따라서 조회가 발생하지 않으면 인덱스를 사용할 필요가 없다.
- 데이터 수정 빈도가 낮을수록 적합하다.
  - `INSERT`, `UPDATE`, `DELETE` 작업 시 데이터에 변화가 생기므로 인덱스를 재구성하는 오버헤드가 발생한다.
- 데이터 중복이 적은 컬럼에 사용하자
  - 데이터 중복이 많은 컬럼은 인덱스 효과가 별로 없다.
  - 성별의 경우 종류가 Male, Female 두 가지 밖에 없으므로 인덱스를 생성하지 않는 것이 좋다.
  - `선택도(Selectivity)`가 낮을 때 유리(보통 5~10% 이내).
    - ~~🤔 데이터가 이미 잘 골라진다면 인덱스를 사용해서 얻는 효과가 미미하므로?~~
- 데이터의 양이 많을 수록 인덱스로 인한 성능향상이 더 크다.
  - 데이터가 10개 밖에 되지 않으면 `Full Table Scan` 시간이 얼마 걸리지 않는다. 이런 경우 굳이 인덱스를 사용할 필요가 없다.
  - 데이터의 양이 적다면 index의 혜택보단 손해가 더 클 수 있다.
- Join 조건으로 자주 사용되는 컬럼의 경우
- 한 테이블에 인덱스가 너무 많으면 데이터 수정 시 소요되는 시간이 너무 길어질 수 있다. (테이블 당 4~5개 정도 권)

</details> 

<details>
    <summary><b>인덱스의 자료구조</b></summary> 

# 인덱스의 자료구조

## Hash Table

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FRpMoO%2FbtqKMzdg9TX%2FXYkGt2kqE0hr9rqhHx3o3K%2Fimg.png)

- `해시 테이블`: `Key-Value` 구조로 데이터를 저장하고 빠른 데이터 검색이 필요할 때 유용하다.
- 해시 테이블 기반의 DB 인덱스는 컬럼의 값을 Key로, 데이터의 위치를 Value로 사용하여 컬럼의 값으로 생성된 해시를 통해 인덱스를 구현

### Hash Index가 DB의 Index 구조로 적합하지 않은 이유

- Hash Index는 데이터 검색시 시간복잡도가 O(1)이므로, 데이터 검색 시 속도가 빠르다.
- 단, ***Hash Index의 경우 등호(`=`)연산에만 특화되었으므로, DB 인덱스에서 사용하기에는 제한적***이다.
- _**데이터가 조금이라도 달라지면 Hash Function은 다른 Hash값을 생성하므로, 부등호 연산(>, <)이 자주 사용되는 DB 검색에선는 Hash Index 가 적합하지 않다.**_
- 예) "나는"으로 시작하는 모든 데이터를 검색하기 위한 쿼리문은 인덱스의 혜택을 전혀 받지 못한다. 따라서 일반적으로 DBMS는 `B+Tree` 자료구조를 이용한다.

# B+Tree Index

### BST

<img src="https://velog.velcdn.com/images/balparang/post/dccce2c7-d551-4c48-b6a1-9a935b0e3f25/image.png" width="500">

### B Tree (B 트리)

<img src="https://velog.velcdn.com/images/balparang/post/0ae593cc-1541-479c-81fc-7a139c8fa418/image.png" width="500">

- BST 구조에서 노드마다 데이터를 2개 이상 저장하여 검색 속도를 강화
- BST 에서는 2번의 이동으로 1~7 이동 가능했지만 B-Tree를 이용하여 두 번의 이동으로 1~13 검색이 가능해졌다.

## B+Tree

<img src="https://velog.velcdn.com/images/balparang/post/12b5d094-5a4c-4d53-a149-bb990ffc5243/image.png" width="500">

<img src="https://velog.velcdn.com/images/balparang/post/0c36112b-1c74-4f73-b1d9-5f8515ce9192/image.png" width="500">

- DB의 인덱스를 위해 **_자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조._**

> 참고) B+Tree의 B는 Balance!

### B+Tree가 DB Index를 위한 자료구조로 적합한 이유

1. **_항상 정렬된 상태를 유지하여 부등호 연산에 유리하다._**
2. 데이터 탐색뿐 아니라, 삽입/수정/삭제 시에도 항상 O(logN)의 시간 복잡도를 갖는다.

<img src="https://velog.velcdn.com/images/balparang/post/ed1f3105-d35f-4c6a-8995-391a71cbbe4d/image.png">

`박현지`보다 작은 값들을 가리키는 포인터를 저장 & `박현지`보다 크거나 같은 값들을 가리키는 포인터를 저장

### B+Tree 실제 구조

<img src="https://velog.velcdn.com/images/balparang/post/364b227f-7c26-43f5-808e-405938ee0f80/image.png">

- 리프노드만 데이터를 갖는다. 리프노드가 아닌 노드는 데이터가 아니라 어디로 이동해야할지 가이드(=포인터)만 갖는다.
- 리프노드에는 데이터들이 `search-key`를 기준으로 정렬되어있다.
- _**리프노드는 LinkedList로 연결되어 범위 검색이 쉬워진다.**_
  - B-Tree 의 경우 범위를 벗어나는 데이터를 검색할 경우 상위 노드로 이동해서 데이터가 있는 노드로 이동해야한다.
  - B+Tree는 데이터 노드의 범위를 벗어나는 데이터를 검색할 경우 상위 노드로 이동하지 않고 다음 데이터 노드로 이동하면 된다.
- 부등호가 있는 `SELECT WHERE` 절 동작 예시
  - `SELECT * FROM STUDENT WHERE 이름 >= '배준석';` 실행
  - 루트노드 `박현지` 로 이동
  - `배준석`이 비교대상 `박현지`보다 크므로 오른쪽 포인터 타고 뎁스가 1인 노드로 이동
  - `배준석`이 비교대상 `정재헌`보다 작으므로 왼쪽 포인터 타고 리프노드로 이동
  - 이름이 `배준석` 이상인 데이터를 SELECT

---

**※ Reference**

- [index가 뭔지 설명해보세요 (개발면접시간) - 코딩애플](https://www.youtube.com/watch?v=iNvYsGKelYs)
- [[Database] 인덱스(index)란? - 망나니 개발자](https://mangkyu.tistory.com/96)
- [[MySQL] B-Tree로 인덱스(Index)에 대해 쉽고 완벽하게 이해하기 - 망나니개발자](https://mangkyu.tistory.com/286)

</details> 

<details>
    <summary><b>인덱스는 왜 hash table이 아니라 b+tree로 구현되었을까</b></summary>


### 🆀 데이터를 검색을 할 때 해시 테이블의 시간복잡도는 O(1)이고 B+Tree는 O(logN)으로 더 느린데 왜 인덱스는 해시 테이블이 아니라 B+Tree로 구현되었을까요?

- Hash Index의 경우 등호연산에만 특화되어있다.
- 조금이라도 다른 데이터에 대해서 다른 해시값을 가지므로, 부등호 연산이 많은 DB검색에는 적합하지 않다.
- B+Tree 의 경우 데이터가 저장되는 리프노드가 LinkedList로 연결되어있다. 따라서 범위 검색시 다음 리프노드로 바로 이동할 수 있다.
  - 즉, 부등호 연산이 많은 DB검색에 적합하다.


</details> 

---

<details>
    <summary><b>Join</b></summary> 

# 조인

- 조인(Join): 두 테이블의 공통 컬럼을 기준으로 컬럼 값이 같은 튜플을 수평으로 결합하는 연산
- 두 테이블을 카티전 프로덕트 연산 후 셀렉션 연산을 한 것으로 정의할 수 있다.

- 기본 조인 연산
  - 세타조인
  - 동등조인
  - 자연조인
- 확장된 조인 연산
  - 세미조인
  - 외부조인

## 조인 종류

### 세타조인

- 조인에 참여하는 두 릴레이션의 속성값을 비교하여 조건을 만족하는 투플만 반환
- 세타조인의 '조건': {=, !=, <=, >=, <, >} 중 하나

### 동등조인(=내부조인. inner join)

- 세타조인에서 `=` 연산자를 사용한 조인
- 주로 한 테이블의 기본키와 다른 테이블의 외래키가 같을 때를 조건으로 조인 연산을 수행

### 자연조인

- 동등조인(내부조인)에서 조인에 참여한 속성이 두 번 나오지 않도록 두 번째 속성을 제거한 결과를 반환

### 외부조인

- 자연조인 시 자연 조인에 실패한 투플을 모두 보여주되 _**값이 없는 속성에는 널 값을 채워 반환**_.

### 세미조인

- 자연조인을 한 후 두 릴레이션 중 한쪽 릴레이션의 결과만 반환
- 기호에서 닫힌 쪽 릴레이션의 투플만 반환
  - R ⋉ S: R쪽 릴레이션의 투플만 반환

</details>

<details>
    <summary><b>inner join Vs. left outer join</b></summary> 

- Join 이란 두 개 이상의 테이블을 서로 연결하여 하나의 결과를 만들어 보여주는 것
- inner join 은 두 테이블에 모두 있는 내용만 join되는 방식
- left outer join 은 왼쪽 테이블의 모든 행에 대해서 join 진행
  - 왼쪽 테이블에만 있고 오른쪽 테이블에는 없는 튜플에 대해서는 컬럼값을 null로 표현

<img src="https://velog.velcdn.com/images/balparang/post/51006d45-4ceb-4bce-b974-fbd6c80541fa/image.png" width="500">

</details>

---

<details>
    <summary><b>정규화</b></summary> 

# 정규화

## 정규화란?

- DB설계 과정에서, 잘못 설계된 테이블에 대해 삽입, 삭제, 수정 작업을 하면 이상현상이 발생한다. 이상현상은 DB의 일관성을 훼손하여 `데이터의 무결성`을 깨뜨리는데, 이를 해결하기위해 `함수 종속성`을 파악하여 몇 가지 규칙에 따라 테이블을 분해해야한다. 이와 같이 잘못 설계된 테이블을 수정하여 정상으로 만드는 과정을 정규화라 한다.


## 기본 정규형과 정규화 과정

### 정규화 개념

- 함수 종속성을 이용하여 **릴레이션을 연관성이 있는 속성들로만 구성되도록 분해**해서, 이상 현상이 발생하지 않는 올바른 릴레이션으로 만들어나가는 과정을 `정규화`라고 한다.
- 정규화의 기본 목표는 관련이 없는 함수 종속성은 별개의 릴레이션으로 표현하는 것이다.

- 기본 정규형: 제 1, 2, 3 정규형 + 보이스 코드 정규형
- 고급 정규형: 제 4, 5 정규형

### 제 1정규형

- **_릴레이션의 모든 속성 값이 원자값을 가지면 제1 정규형이라고 한다._**
- 모든 속성이 원자값을 가지도록 여러개의 튜플로 분리

### 제2 정규형

- **_릴레이션이 제1 정규형이고, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속일 때 제2 정규형이라고 한다._**
- PK가 복합키(Composite Primary Key)로 구성된 경우 2차 정규화를 고려해볼 수 있다.
- 릴레이션의 키가 복합키일 때, 복합키의 일부분이 다른 속성이 결정자인지 여부를 판단하는 것
- 릴레이션의 부분 함수 종속을 제거하고 모든 속성이 기본키에 완전 함수 종속되도록 한다.

<img src="https://velog.velcdn.com/images/balparang/post/95407aaf-9b30-457b-ab6e-be9dabe4e88a/image.png">

- 제2 정규형에 속하더라도, 이상현상이 발생할 수 있다.
  - 함수 종속성이 여러개면 삽입 이상, 갱신 이상, 삭제 이상 발생 가능하다.
    - bronze 등급을 추가하고 싶은데 개체 무결성 제약조건을 위배한다.

### 제3 정규형

- **_릴레이션이 제2 정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않으면 제3 정규형에 속한다._**
- 릴레이션에서 이행적 함수 종속을 제거해서, 모든 속성이 기본키에 이행적 함수 종속이 되지 않도록 릴레이션을 분해한다.
- PK에 의존하지 않고, 일반 컬럼에 의존하는 컬럼을 분리한다.

> 💡 `이행적 함수 종속`이란? <br><br>
> <img src="https://velog.velcdn.com/images/balparang/post/4860d6af-e29d-479b-8381-e6a84cae070d/image.png" >
> <br>
> 3개의 속성 집합 X, Y, Z에 대해 X가 Y의 결정자이고 Y가 Z의 결정자인 경우를 이행적 함수 종속 되었다고 한다.


### 보이스/코드(BCNF) 정규형

- **_릴레이션의 함수 종속 관계에서 모든 결정자가 후보키이면 보이스/코드 정규형에 속한다._**

![](https://velog.velcdn.com/images/balparang/post/57db6451-5d36-4f15-aec6-41a41c314e64/image.png)

- 모든 속성이 원자값을 가진다 -> 제1 정규형
- 기본키가 아닌 속성이 기본키(복합키)에 완전 함수 종속된다. -> 제2 정규형
- 기본키가 아닌 속성이 기본키에 이행적 함수 종속되지 않는다. -> 제3 정규형

![](https://velog.velcdn.com/images/balparang/post/06cd5b0b-cfb7-4413-8f10-771d40db42b7/image.png)

- 결정자 `담당강사번호`는 후보키가 아니다.

### 무손실 분해

릴레이션을 분해할 때 `무손실 분해` 규칙을 지키며 분해해야 한다.

**무손실 분해란?**

- 분해된 릴레이션들을 자연 조인하여 분해 전의 릴레이션으로 다시 복원할 수 있어야한다는 규칙
- 릴레이션이 의미상 동등한 릴레이션들로 분해되어야 하고, 릴레이션을 분해했을 때 정보 손실이 발생하지 않아야한다.
- 분해된 릴레이션의 관계를 유지하기 위해 분해된 릴레이션에 공통 속성을 한 개 이상 둔다.
  - 공통 속성은 분해된 릴레이션을 다시 원래의 릴레이션으로 복원할 때 조인 속성으로 사용한다.

---

※ Reference

- [제 1-2-3 정규화 & 역정규화 기법 💯 정리](https://inpa.tistory.com/entry/DB-%F0%9F%93%9A-%EC%A0%9C-1-2-3-%EC%A0%95%EA%B7%9C%ED%99%94-%EC%97%AD%EC%A0%95%EA%B7%9C%ED%99%94#%EC%97%AD%EC%A0%95%EA%B7%9C%ED%99%94)
- 데이터베이스 개론 2판 - 김연희 저
- https://dodo000.tistory.com/21

---

## 🗣️ 면접질문

### Q. 정규화란?

- 테이블이 잘못 설계되면 삽입, 수정, 삭제 연산 시 `이상현상`이 발생
- 속성간의 함수 종속성을 파악하여 테이블을 분리하여 `이상현상`을 제거해나가는 과정

### Q. 정규화 장단점

- 장점: 이상현상이 없음. 즉 데이터 불일치나 중요한 정보가 연쇄적으로 삭제되는 일을 방지
- 단점: 정규화를 너무 심하게 하면 조인 성능 문제

### Q. 역정규화를 하는 이유?

역정규화란 정규화를 통해 분리되었던 릴레이션에서 중복을 허용하고 다시 통합하거나 분할하여 구조를 재조정하는 과정입니다. 정규화된 릴레이션은 하나의 릴레이션을 분해하기 때문에 원하는 자료가 하나의 릴레이션에 존재하지 않아 외래키를 이용해 참조해야하는 상황이 잦아집니다. 이는 데이터베이스에 저장된 자료를 검색하는 시간을 증가시키며 성능을 저하시킬 수 있습니다. 따라서 데이터베이스의 물리적 설계 과정에서 성능을 향상시키기 위해 역정규화를 실행합니다. 역정규화의 종류로는 릴레이션 역정규화, 속성 역정규화가 있습니다.

</details>

<details>
    <summary><b>이상현상</b></summary>

## 이상 현상

- 테이블에 투플을 삽입할 때 부득이하게 널 값이 입력되거나, 삭제 시 연쇄삭제 현상이 발생하거나, 수정 시 일관성이 훼손되는 현상


_학생수강 테이블_

| 학생번호 | 학생 이름 | 학과   | 주소       | 강좌이름   | 강의실     |
|------|-------|------|----------|--------|---------|
| 501  | 박지성   | 컴퓨터과 | 영국 맨체스타  | 데이터베이스 | 공학관 110 |
| 401  | 김연아   | 체육학과 | 대한민국 서울  | 데이터베이스 | 공학관 110 |
| 402  | 장미란   | 체육학과 | 대한민국 강원도 | 스포츠경영학 | 체육관 103 |
| 502  | 추신수   | 컴퓨터과 | 미국 클리블랜드 | 자료구조   | 공학관 111 |
| 501  | 박지성   | 컴퓨터과 | 영국 맨체스타  | 자료구조   | 공학과 111 |

### 이상 현상 종류

- **삽입 이상**
  - 새로운 투플 삽입 시 특정 속성에 해당하는 값이 없어 널 값을 입력해야하는 현상
  - 집계함수는 NULL값을 제외하고 연산하므로, 집계함수 사용시 의도와 다른 결과를 만들 수 있다.

| 학생번호 | 학생 이름 | 학과   | 주소      | 강좌이름 | 강의실  |
|------|-------|------|---------|------|------|
| ...  | ...   | ... | ... | ... | ... |
| 403  | 박세리   | 체육학과 | 대한민국 대전 | NULL | NULL |


- **갱신 이상**
  - 투플 수정 시 중복된 데이터의 일부만 수정되어 데이터의 불일치 문제가 일어나는 현상

| 학생번호 | 학생 이름 | 학과   | 주소      | 강좌이름   | 강의실     |
|------|-------|------|---------|--------|---------|
| 501  | 박지성   | 컴퓨터과 | 영국 맨체스타 | 데이터베이스 | 공학관 110 |
| 501  | 박지성   | 컴퓨터과 | 대한민국 서울 | 자료구조   | 공학과 111 |


- **삭제 이상**
  - 투플 삭제 시 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 현상.

    | 학생번호 | 학생 이름 | 학과   | 주소       | 강좌이름   | 강의실     |
            |------|-------|------|--------|--------|---------|
    | 402  | 장미란   | 체육학과 | 대한민국 강원도 | 스포츠경영학 | 체육관 103 |
    - 장미란 학생이 스포츠경영학 과목을 취소해서 투플을 삭제했는데 학생이름, 학과, 주소 정보까지 사라진다.



</details>

<details>
    <summary><b>함수 종속</b></summary>


## 함수 종속성


## 함수 종속

- 정규화를 수행하려면 먼저 릴레이션을 구성하는 속성들 간의 관련성을 판단할 수 있어야한다.
- 정규화 과정에서 고려해야하는 속성들 간의 관련성을 `함수적 종속성`(이하 함수 종속성) 이라고 한다.
- 일반적으로 **릴레이션에 함수적 종속성이 하나 존재하도록 정규화**를 통해 릴레이션을 분해한다.


### 함수적으로 종속되어있다

- 릴레이션을 구성하는 속성들의 부분집합을 X, Y라 할 때, 릴레이션 내의 모든 튜플에서 하나의 X값에 대한 Y값이 항상 하나면 `X가 Y를 함수적으로 결정한다` 또는 `Y가 X에 함수적으로 종속되어있다` 라고 한다. 이렇게 함수적으로 종속하는 성질을 `함수 종속성`이라고 한다.

### 완전 함수 종속과 부분 함수 종속

![](https://velog.velcdn.com/images/balparang/post/53ceb145-0c8a-444c-b53d-96e73ea0f5f0/image.png)

_당첨여부는 {고객아이디, 이벤트번호}에 완전 함수 종속 되어있고, 고객이름은 {고객아이디, 이벤트 번호}에 부분 함수 종속되어있다._

- 완전 함수 종속
  - 속성 집합 Y가 속성 집합 X에 함수적으로 종속되어 있지만, 속성 집합 X 전체에 종속된 것이지 일부분에 종속된 것이 아님을 의미
- 부분 함수 종속
  - 속성 집합 Y가 속성 집합 X 전체가 아닌 일부분으로 함수적으로 종속됨을 의미
  - `결정자`가 여러 개의 속성들로 구성되어있어야 한다.

</details>

---

<details>
    <summary><b>View</b></summary> 


# 뷰

## 뷰의 개념

- 다른 테이블을 기반으로 만들어진 가상 테이블
- 일반 테이블과 달리 데이터를 실제로 저장하고 있지 않다.
- 기본 테이블(물리적인 테이블)을 통해 뷰를 만들거나, 이미 만들어진 뷰를 통해 새로운 뷰를 만들 수 있다.

### 뷰를 통한 기본 테이블의 변화는 제한적이다.

- 검색 연산은 모든 뷰에 수행할 수 있다.
  - 뷰에 대한 SELECT 문이 내부적으로 기본 테이블에 대한 SELECT 문으로 변환
- 뷰에 대해 삽입, 수정, 삭제 연산을 하면 기본 테이블이 변한다.
- ***어떤 튜플을 어떻게 변경해야 할지 명확히 제시하지 못하는 뷰는 변경이 불가능***하다.
  - 기본키를 구성하는 속성이 포함되지 않은 뷰
  - 집계 함수로 새로 계산된 내용을 포함하고 있는 뷰

## 뷰의 장단점

### 장점

1. 질의문을 좀 더 쉽게 작성할 수 있다.
  - 뷰를 미리 만들어 놓으면 사용자가 WHERE 절 없이 뷰를 검색해도 특정 조건을 만족하는 데이터를 바로 검색 가능
2. 데이터의 보안 유지에 도움이 된다.
  - 뷰를 미리 만들어 사용자가 자신에게 제공된 뷰를 통해서만 데이터에 접근 가능하도록 권한을 설정. 데이터를 사용자로부터 보호 가능.
3. 데이터를 좀 더 편리하게 관리 가능.
  - 사용자는 제공된 뷰에 포함되지 않은 기본테이블을 신경 쓸 필요 없다.
  - 제공된 뷰와 관련 없는 다른 테이블의 변화에도 영향을 받지 않는다.

### 단점
- 삽입, 수정, 삭제 연산 시 기본 테이블이 변경될 수 있으므로 주의 해서 사용

## 기타

### 뷰를 삭제하더라도 기본 테이블은 영향을 받지 않는다.

- 뷰를 통해 데이터를 삭제할 때 테이블에 영향이 가는 것이지, 뷰 자체를 삭제한다고 해서 테이블이 영향 받지는 않는다.

</details>

---

<details>
    <summary><b>트랜잭션</b></summary> 


# 트랜잭션

## 트랜잭션이란?

- **_DBMS에서 데이터를 다루는 논리적인 작업 단위_**
- DB의 `무결성`을 유지하며 DB의 상태를 변화시키는 기능 수행
- 트랜잭션이 필요한 이유
  - DB에서 데이터를 다룰 때 장애가 일어나는 경우, 트랜잭션은 ***장애 발생 시 데이터를 복구하는 작업의 단위가 된다.***
  - DB에서 **_여러 작업이 동시에 같은 데이터를 다룰 때, 트랜잭션은 이 작업을 서로 분리하는 단위가 된다._**
- 예) _은행 시스템에서 A에게 100만원을 출금해서 B에게 입금할 때 장애가 생겨 B에게 100만원이 입금이 되지 않았다._
  - 이런 상황은 전산시스템의 치명적인 오류
  - 이처럼 예상치 못하게 데이터 부정합이 발생하는 경우 다시 원상복귀시켜야한다.
  - 출금을 했으면 입금을 마치든지, 아니면 아예 없던 일이 되어야한다.


### 트랜잭션 상태

![](https://blog.kakaocdn.net/dn/bbYMDH/btrbOsjZF2N/le9kHXH4DkZIb67wbfoFw0/img.png)

- 활동(Active)
  - 트랜잭션이 수행되기 시작하여 현재 수행 중인 상태를 활동 상태라고한다.
- 부분완료(Partially Committed)
  - 트랜잭션 수행은 완료되었지만 트랜잭션 수행 결과를 DB에 반영하지 않은 상태
- 완료(Committed)
  - `부분완료` 상태에서 DBMS가 최종적으로 변경내용을 DB에 기록하면 `완료(committed)`상태가 된다.
- 실패(Failed)
  - 트랜잭션을 중간에 중단했거나, 부분완료 상태에서 변경 내용을 DB에 저장하지 못한 상태.
- 철회(Aborted)
  - 트랜잭션을 수행하는데 실패하여, rollback 연산을 수행한 상태
  - 트랜잭션이 `철회` 상태가 되면 트랜잭션이 수행되기 전의 상태로 원상복구한다.

---

**※ Reference**

- [MySQL로 배우는 데이터베이스 개론과 실습](http://www.yes24.com/Product/Goods/77724190)

---

## 🗣️ 면접 대비

### Q. 트랜잭션이란?

- 트랜잭션이란 데이터베이스 내에서 수행되는 작업의 최소 단위
- 데이터베이스의 무결성을 유지하며 DB의 상태를 변화시키는 기능 수행
  - `무결성`: 데이터베이스에 저장된 데이터의 정확성을 지키는 것
- 트랜잭션은 하나 이상의 쿼리를 포함해야하고, ACID라고 불리는 원자성, 일관성, 고립성, 지속성 4가지 규칙을 만족해야한다.

### Q. ACID 원칙?

### Q. COMMIT과 ROLLBACK에 대해 설명해보세요.

- 데이터베이스는 `COMMIT` 과 `ROLLBACK` 명령어를 통해 데이터 무결성을 보장한다.
- `COMMIT`이란 트랜잭션 작업을 완료했다고 확정하는 명령어이다.
  - 트랜잭션 작업 내용을 실제 DB에 저장하고, DB가 변경된다.
- `ROLLBACK`은 작업 중 문제가 발생했을 때, 트랜잭션 처리과정에서 발생한 변경 사항을 취소하고, 이전 `COMMIT`의 상태로 되돌린다.

### Q. ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?

### Q. 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?

### Q. DeadLock이 뭔지 설명해주세요.

- DeadLock이란 여러 트랜잭션들이 각각 자신의 데이터에 대하여 락을 획득한 상태에서, 상대방 데이터 대하여 접근하고자 대기를 할 때 교차 대기를 하게 되면서 서로 영원히 기다리는 상태를 말한다.

### Q. Deadlock 을 해결하려면 어떻게 해야 하나요?

- 각 트랜잭션이 실행되기 전에  사용될 모든 데이터를 미리 Locking 해주는 `예방 기법`
- 자원 할당시 time stamp를 사용하여 데드락이 발생하지 않도록 하는 `회피하는 기법`
- 데드락이 발생하면 이를 감지하고 회복시키는 `탐지/회복 기법`

모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?
만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.
그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?



</details> 

<details>
    <summary><b>ACID</b></summary> 

## 트랜잭션의 성질 - ACID 원칙

트랜잭션은 데이터베이스의 무결성을 유지하기 위해 원자성, 일관성, 고립성, 지속성의 성질을 갖는다.

### Atomicity(원자성)

- 트랜잭션에 포함된 작업은 _**전부 수행되거나, 아니면 전부 수행되지 않아야 한다**_(`all or nothing`)라는 원칙
- 트랜잭션 중간에 장애가 발생하면 롤백을 통해 원자성을 보장한다.

### Consistency(일관성)

- 트랜잭션을 수행하기 전이나 수행한 후나 데이터베이스는 항상 일관된 상태를 유지해야한다.
- 테이블이 생성될 때 CREATE 문과 ALTER 테이블 문의 무결성 제약조건을 통해 명시된다.
- 일관된 상태란?
  - 일관성 조건은 데이터베이스를 사용하는 상황에 따라 다르다.
  - 계좌이체 상황에서 A계좌에서 돈을 인출에서 B계좌에 입금한다고 해보자. 각 계좌에는 10만원씩 들어있다고 했을 때, 두 계좌의 금액 총합은 20만언이어야 한다. 이 때 `계좌의 합이 20만원이어야 한다`라는 것이 일관성 조건이 된다.
  - 트랜잭션 도중에 A계좌에서 만 원을 인출하고 B계좌에 입금하지 않은 시점에서는 두 계좌의 합이 20만원이 아니라 19만원이 된다. 즉 일관성을 일시적으로 지키지 못한 상태가 된다.
  - 트랜잭션을 마치고 나면 다시 두 계좌의 합은 20만원이 된다. 즉 일관성 조건을 만족시킨다.
- 송금 전후 모두 잔액의 Data Type이 Integer이어야 한다는 것이 일관성의 한 예가 될 수 있다.

### Isolation(격리성)

- 여러 트랜잭션은 동시에 수행되는데, 이 때 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하는 일이 없어야함을 의미.
- 여러 트랜잭션이 같은 데이터를 동시에 읽고 쓸 경우, 변경 중인 데이터를 다른 트랜잭션이 사용하면 데이터의 일관성이 훼손될 수 있다.
- DBMS는 `동시성 제어` 또는 `트랜잭션 고립 수준에 따라 트랜잭션의 상호 간섭을 완화`시키는 방법을 통해 고립성을 보장한다.
  - 동시성 제어: 동시에 수행되는 트랜잭션이 동일한 데이터를 가지고 충돌하지 않도록 제어
- `고립성 현상`: 여러 트랜잭션이 동시에 수행될 때 상호 간섭이나 데이터 충돌이 일어나지 않는 현상

### Durability(지속성)

- 트랜잭션이 정상적으로 완료된 데이터는 반드시 데이터베이스에 저장되어야함을 의미.
- 트랜잭션이 완료되어 저장된 데이터베이스는 저장 후에 생기는 정전, 장애, 오류에 영향을 받지 말아야한다.
- DBMS는 `회복 기능`을 통해 DB를 원래 상태로 복구하여 `지속성`을 보장한다.

### 트랜잭션의 특성을 지원하는 DBMS의 기능

- DBMS의 회복 기능과 병행 제어 기능을 통해 ACID를 보장한다.
- 회복 기능 👉 원자성, 지속성
- 병행 제어 기능 👉 일관성, 격리성


</details> 

<details>
    <summary><b>동시성 제어, 갱신손실 문제</b></summary>

### 동시성 제어란?

- 동시에 수행되는 트랜잭션은 다른 트랜잭션이 같은 데이터를 공유하고 있다는 사실을 모르기 때문에 데이터 일관성이 훼손될 수 있다. **_트랜잭션이 동시에 수행될 때 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는 DBMS의 기능을 `동시성 제어(concurrency control)`라고한다._**


### 갱신손실 문제란?

- **_여러 개의 트랜잭션이 한 개의 데이터를 동시에 갱신(update)할 때 어느 한 트랜잭션의 갱신이 무효화_** 될 수 있는데 이를 `갱신손실 문제`라고 한다.
- 갱신손실 문제는 데이터베이스에서 절대 발생하면 안 되는 문제이다.
- 갱신작업이 무효화 되는 경우 예시
  ![](https://velog.velcdn.com/images/balparang/post/15a8e59e-9283-45ae-840c-e32c292a2be8/image.png)
  - `트랜잭션2`는 100을 더하는 연산이고, `트랜잭션3`은 100을 빼는 연산이다. 따라서 두 트랜잭션 이후에 데이터는 그대로 일 것을 예상.
  - `트랜잭션3`에서 A값(=1000)을 읽고 `A = A - 100`연산을 수행. 이 때 A는 900
  - `트랜잭션2`에서 A값(=1000)을 읽고 `A = A + 100`연산을 수행. 이 때 A는 1100
  - `트랜잭션3`에서 A값(=900) write. A값이 900으로 변경된다.
  - `트랜잭션2`에서 A값(=1100) write. A값이 1100으로 변경된다.
  - `갱신손실 문제`가 발생하여, 데이터값이 그대로 유지될 것이라는 예상과는 다르게 결과가 나온다.

</details>

<details>
    <summary><b>Lock, DeadLock</b></summary> 

### 락의 개념

- 락이란, 트랜잭션이 데이터를 읽거나 수정할 때 데이터에 표시하는 잠금장치
- 락을 건 트랜잭션만 해당 데이터에 접근 가능
- 락을 사용하여 데이터에 대한 갱신을 순차적으로 진행할 수 있기 때문에, `갱신손실` 문제를 해결할 수 있다.

### Lock을 통한 동시성 제어

![](https://velog.velcdn.com/images/balparang/post/3a357798-275c-4359-a68a-eff48ecfce48/image.png)

- `트랜잭션3` 이 시작할 때 락을 건다.
  - `트랜잭션3` A(=1000)를 읽고, `A = A - 100` 연산을 수행한다. (A = 900)
  - `트랜잭션2`가 A에 접근하려고 하나 락이 걸려있어 wait를 한다.(언락이 될 때까지).
  - `트랜잭션3`이 쓰기작업을 마치고 언락. (A = 900)
- `트랜잭션2`가 실행되고 락을 건다.
  - A(=900)를 읽고, `A = A + 100` 연산을 수행. (A = 1000)
  - `트랜잭션2`가 쓰기작업을 마치고 언락. (A = 1000)

### 락의 유형

### 2단계 락킹

## 데드락

### 데드락이란?

- 두 트랜잭션이 각각 Lock을 설정하고, Unlock을 하지 않은 상태에서 서로의 Lock이 걸린 데이터에 접근하려고 할대, 서로 대기를 계속하여 영원히 처리되지 않는 상황이 발생하는데 이를 `데드락`이라한다.

- 데드락 예시

  ![](https://velog.velcdn.com/images/balparang/post/860f8b27-4298-42c7-9a8f-10c89cd2ba9a/image.png)

  - 두 개 이상의 트랜잭션이 실행되는 **병행적인 상황**
  - `트랜잭션2`는 테이블 A의 데이터가 필요하여 Lock A를 걸었다.
  - `트랜잭션1`은 테이블 B의 데이터가 필요하여 Lock B를 걸었다.
  - `트랜잭션2`가 테이블 B의 데이터가 필요하여 접근하여 락을 걸려 했으나, `트랜잭션1`이 이미 걸어둔 Lock 때문에 접근하지 못하고 Unlock되기를 기다린다.
  - `트랜잭션1`은 테이블 A의 데이터가 필요하여 접근하려 락을 했으나, `트랜잭션2`가 이미 걸어둔 Lock 때문에 접근하지 못하고 Unlock되기를 기다린다.
  - 두 트랜잭션이 상대의 락이 언락되기만을 기다리면서 무제한 대기하는 상태가 발생한다 👉 `DeadLock`

### 데드락 해결법

1. 예방 기법
  - 각 트랜잭션이 실행되기 전에 필요한 데이터를 모두 Locking 한다.
  - 단, Locking 해줘야 하는 데이터가 하는 데이터가 많다면 사실상 모든 데이터를 전부 Locking하는 것과 동일하여 트랜잭션의 병행성을 보장하지 못 할 수 있다.
2. 회피 기법
  - 자원을 할당할 때 `time stamp`를 사용하여 데드락이 일어나지 않도록 회피하는 방법
3. 탐지/회복 기법
  - 트랜잭션이 실행되기 전에는 아무런 검사를 하지 않고, 데드락이 발생하면 이를 감지하고 회복시키는 방법

</details>

<details>
    <summary><b>트랜잭션 고립(격리) 수준</b></summary> 

## 한 트랜잭션은 읽고, 다른 트랜잭션을 쓸 때 생기는 문제

### 오손 읽기(dirty read)

- 오손 읽기는 읽기 작업을 하는 트랜잭션 1이 쓰기 작업을 하는 트랜잭션 2가 작업한 중간 데이터를 읽기 때문에 생기는 문제다.
- 작업 중인 트랜잭션 2에서 어떠한 이유로 작업을 롤백하게 된다면, 트랜잭션 1은 무효가 된 데이터를 읽게되고 잘못된 결과를 도출한다.

### 반복 불가능 읽기(non-repeatable read)

- 트랜잭션 1이 데이터를 읽고, 트랜잭션 2가 데이터를 갱신하고, 트랜잭션 1이 다시 한 번 데이터를 읽을 때 문제가 발생한다.
- 트랜잭션 1이 처음 데이터를 읽었을 때와 다시 데이터를 읽었을 때의 결과가 다른 문제가 발생한다.

### 유령 데이터 읽기(phantom read)

- 트랜잭션 1이 데이터를 읽고, `트랜잭션 2가 데이터를 삽입`하고, 트랜잭션 1이 다시 한 번 데이터를 읽을 때 문제가 발생한다.
- 트랜잭션 1 입장에서 처음 데이터를 읽었을 때는 없던 데이터가 다시 데이터를 읽었을 때 등장하는 문제가 발생한다.

## 트랜잭션 고립 수준 명령어

- 읽기만 하는 트랜잭션이 쓰기 트랜잭션에서 작업한 중간 데이터를 읽음으로써 생기는 문제들은 락을 이용하면 해결할 수 있다.
- 단, 이런 상황을 락으로 막게되면 트랜잭션의 동시 진행 정도를 과도하게 막으므로 DBMS는 락보다 완화된 방식으로 이를 해결하는 방법을 제공하는데 이것이 `트랜잭션 고립 수준 명령어` 이다.
- 트랜잭션 고립 수준 명령어를 사용하여 트랜잭션 간의 고립 수준을 결정할 수 있다.


### Level 0: READ UNCOMMITTED

- 자신의 데이터에 아무런 공유락을 걸지 않는다.
  - 배타락은 갱신손실 문제 때문에 걸어야한다.
- **다른 트랜잭션에 공유락과 배타락이 걸린 데이터를 읽을 수 있다.**
- 발생가능 문제점: 오손 읽기, 반복불가능 읽기, 유령데이터 읽기 발생 가능

### Level 1: READ COMMITTED

- 오손 읽기를 방지하기 위해 자신의 데이터를 읽는 동안 공유락을 걸지만 트랜잭션이 끝나기 전에 해지 가능.
- 발생가능 문제점: 반복불가능 읽기, 유령 데이터 읽기

### Level 2: REPEATABLE READ

- 자신의 데이터에 설정된 공유락과 배타락을 트랜잭션이 끝날 때까지 유지
- 발생가능 문제점: 유령 데이터 읽기
- 동시성이 낮아 특별한 상황이 아니라면 사용하지 않는 것이 좋다.

### Level 3: SERIALIZABLE

- 실행 중인 트랜잭션을 다른 트랜잭션으로부터 완벽하게 분리
- 데이터 집합에 범위를 지어 잠금을 설정
- 발생가능 문제점: 없음


</details> 

<details>
    <summary><b>트랜잭션 회복</b></summary> 

# 트랜잭션 - 회복

### 회복이란?

- `회복`은 장애가 발생했을 때 데이터베이스를 장애가 발생하기 전의 일관된 상태로 복구시키는 것이다.
- DBMS의 회복 관리자(recover manager)가 회복을 담당한다.

### 장애

- 트랜잭션의 논리적 오류, 잘못된 데이터 입력 등으로 `트랜잭션 장애`가 발생할 수 있다.

# 회복 기법

### 회복 연산

DB는 데이터를 별도의 장소에 미리 복사해두고, 장애로 문제가 발생했을 때 복사본을 이용해 원래의 상태로 복원한다. DB에 변경연산이 실행될 때마다 데이터를 변경하기 이전값과 변경한 이후 값을 별도 파일에 기록하는데, 이것을 `로그`라고 한다.

- `redo(재실행)`:
  - 로그에 기록된 변경 후의 값을 이용하여 변경 연산을 재실행
  - 데이터베이스의 복사본을 가져온 후 로그를 이용해 복사본이 만들어진 이후에 실행된 모든 변경 연산을 재실행
- `undo(취소)`
  -  로그에 기록된 변경 연산 이전의 값을 이용하여 변경 연산을 취소

## 로그 회복 기법

데이터를 변경한 연산 결과를 데이터베이스에 반영하는 시점에 따라 즉시 갱신 회복 기법과 지연 갱신 회복 기법으로 나눈다.

### 즉시 갱신 회복 기법

트랜잭션 수행 중에 데이터를 변경한 연산의 결과를 데이터베이스에 즉시 반영한다. 장애 발생에 대비하기 위해 데이터 변경에 대한 내용(=로그 레코드)를 로그 파일에도 기록한다.

- 트랜잭션 완료 전 장애 발생
  - `undo` 연산을 통해 데이터를 변경 이전의 값으로 원상복구한다.
- 트랜잭션 완료 후 장애 발생
  - `redo` 연산을 통해 트랜잭션 중 변경 연산을 다시 적용한다.

### 지연 갱신 회복 기법

트랜잭션이 수행되는 동안에는 데이터 변경 연산 결과를 데이터베이스에 즉시 반영하지 않고 로그 파일에만 기록하고, 트랜잭션이 `부분 완료`된 후에 로그에 기록된 내용을 데이터베이스에 한 번에 반영하는 방식.

- 트랜잭션 완료 전 장애 발생
  - 해당 트랜잭션에 대한 로그 레코드를 무시한다. 즉, 별도의 회복조치가 필요없다.
- 트랜잭션 완료 후 장애 발생
  - `redo` 연산을 통해 변경 연산 내용을 다시 적용한다.

## 검사 시점 회복 기법(체크포인트 회복기법)

- `로그 회복 기법`은 로그 전체를 분석하여 모든 트랜잭션을 대상으로 redo나 undo 중 적용할 회복 연산을 정해야하므로 **_회복에 많은 시간이 필요_**
- 체크포인트 회복 기법은 로그 회복 기법과 같은 방식으로 로그를 기록하되, 일정 시간 간격으로 체크포인트를 만들어둔다.
  - 장애가 발생 시 체크포인트 이전의 트랜잭션에 대해서는 회복 작업을 수행하지 않고, 체크포인트 이후의 트랜잭션에 대해서만 회복 작업을 수행
- **_불필요한 회복 작업을 수행하지 않아 회복 시간 단축_**

## 미디어 회복 기법

- 디스크 고장 등으로 장애가 발생하면 데이터베이스 사용 불가능
- `미디어 회복 기법`은 일정 주기로 전체 데이터베이스의 내용을 다른 안전한 저장 장치에 복사해두는 `덤프`를 사용

</details> 

--- 

<details>
    <summary><b>NoSQL</b></summary> 

## NoSQL(Not Only SQL)

- 웹에서 대량의 비정형 데이터를 처리하기 위해 등장한 데이터베이스
  - 비정형 데이터: 정해진 구조가 없이 저장된 데이터. 텍스트, 영상, 이미지 등
- 장점
  - 유연하고 자유로운 데이터 구조를 사용하여 새로운 필드추가 자유로움
  - 대용량 데이터 처리 지원
- 단점
  - 트랜잭션을 지원하지 않아 일관성을 유지하기 어려움
  - 데이터 중복 발생가능하여 업데이트시 모든 컬렉션을 수정해야함
- NoSQL의 종류
  - key-value 데이터베이스
  - document-based 데이터베이스
  - column-base 데이터베이스
- NoSQL이라고 불리는 이유?
  - 보통 SQL을 지원하지 않고,
  - 트랜잭션을 지원하지 않는 등 SQL을 사용하는 기존 RDB와 다르기 때문.

</details>

<details>
    <summary><b>NoSQL Vs. RDB</b></summary> 

### RDB Vs. NoSQL

|               | RDB(SQL)                                                                                             | NoSQL                                                                                                       |
|---------------|------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------|
| **데이터 저장 모델** | table                                                                                                | json document, key-value, 그래프 등                                                                             |
| **개발 목적**     | 데이터 중복 감소                                                                                            | 애자일 / 확장 가능성 / 수정가능성                                                                                        |
| **예시**        | Oracle, MySQL, PostgreSQL 등                                                                          | MongoDB, DynamicDB                                                                                          |
| **Schema**    | 엄격한 데이터 구조                                                                                           | 유연한 데이터 구조                                                                                                  |
| **⭐️장점**      | - 명확환 데이터 구조 보장 <br> - 데이터 중복 없이 한 번만 저장(무결성) <br> - 데이터 중복이 없어서 데이터 update 용이                       | - 유연하고 자유로운 데이터 구조 <br> - 새로운 필드 추가 자유로움 <br> - 수평적 확장(scale out) 용이                                        |
| **⭐️단점**      | - 시스템이 커지면 JOIN문이 많은 복잡한 쿼리가 필요 <br> - 성능 향상을 위해 수직적 확장(scale up)만 가능하여 비용이 큼 <br> - 데이터 구조가 유연하지 못함 | - 데이터 중복 발생 가능 <br> - **_중복 데이터가 많기 때문에 데이터 변경 시 모든 컬렉션에서 수정이 필요함_** <br> - 명확한 데이터 구조 보장 X                 |
| **⭐️사용**      | - ***데이터 구조가 변경될 여지가 없이 명확***한 경우 <br> - _**데이터 update 가 잦은**_  시스템 (중복 데이터가 없으므로 변경에 유리)            | - 정확한 데이터 구조가 정해지지 않은 경우 <br> - 데이터 Update가 자주 이루어지지 않는 경우(조회가 많은 경우) <br> - 데이터 양이 매우 많은 경우 (scale out 가능) |

---


※ Reference



---

## 🗣️ 면접 대비

### Q. RDB와 NoSQL을 비교 설명

- 관계형 데이터베이스는 사전에 엄격하게 정의된 DB 스키마를 요구하는 테이블 기반 데이터 구조를 갖는다.
- NoSQL은 테이블 형식이 아닌 비정형 데이터를 저장할 수 있도록 지원한다.
- RDB는 엄격한 스키마로 인해 데이터 중복이 없기 때문에 데이터 업데이트가 많을 때 유리하다.
- NoSQL의 경우 데이터 중복으로 인해 데이터 업데이트 시 모든 컬렉션에서 수정이 필요하기 때문에 업데이트가 적고 조회가 많을 때 유리

### Q. NoSQL은 언제 사용하면 좋을까?

- 정확한 데이터 구조가 정해지지 않은 경우
- **_데이터 update가 자주 이루어지지 않고,_** **_조회가 많은 경우_**
- **_Scale Out 이 가능하므로 데이터 양이 매우 많은 경우_**

### Q. RDB는 언제 사용하면 좋을까?

- 데이터 구조가 명확하여 변경될 여지가 없는 경우
- 데이터 중복이 없으므로 데이터 update가 잦은 시스템에서 사용하면 좋다.

</details>