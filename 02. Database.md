<details>
    <summary><b>관계형 데이터베이스</b></summary> 

## 관계형 데이터베이스

- 가장 널리 사용되는 데이터베이스로 관계형 데이터 모델을 기반으로 한다.

### 관계형 데이터 모델

- 테이블을 이용하여 데이터 상호 관계를 정의하는 DB 모델

### 관계형 데이터베이스 구성 요소

- 테이블
    - 행과 열로 이루어진 데이터의 집합이다.
    - 관계형 데이터베이스에서는 특별한 제약들을 추가하여 이를 **릴레이션**이라고 한다.
        - 릴레이션 : 중복되는 튜플을 가질 수 없으며, 튜플 간에 순서가 존재하지 않는다.
- 튜플
    - 릴레이션을 구성하는 각각의 행
    - 튜플의 수를 카디널리티라고 한다.
- 속성
    - 데이터베이스를 구성하는 가장 작은 논리적 단위
    - 속성은 개체의 특성을 기술한다.
- 도메인
    - 필드에 채워질 수 있는 값의 집합이다.
    - 값이 나타날 때 그 값의 합법 여부를 검사하는데에도 이용된다.
    - EX) `성별` 이라는 속성의 도메인은 남과 여로, 그 외에는 없다.
- 스키마
    - 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 것이다.
    - 데이터베이스를 구성하는 데이터 레코드 크기, 키의 정의, 레코드간의 관계 등을 정의한다.
    - 사용자 관점에 따라 내부, 외부, 개념 스키마로 나뉜다.
    - 내부 스키마 = `저장` 스키마
        - 물리적 저장장치의 입장에서 본 데이터베이스 구조
        - 실제로 데이터베이스에 저장될 레코드의 형식을 지정하고, 저장하는 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타낸다.
    - 외부 스키마 = `사용자` 뷰
        - 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것.
        - 어떤 형식, 구조, 화면을 통해 사용자에게 보여줄 것인지에 대한 명세를 나타낸다.
        - 여러 개의 외부 스키마가 있을 수 있다.
        - 일반 사용자에게 질의어를 통해 DB를 쉽게 사용할 수 있도록 하고, 응용 프로그래머는 언어를 사용해서 DB에 접근할 수 있도록 한다.
    - 개념 스키마 = `전체`적인 뷰
        - 데이터베이스의 전체적인 논리적 구조를 나타낸다.
        - 접근 권한, 보안 및 무결성 규칙에 관한 명세를 정의한다.
        - 모든 응용프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스 스키마로 하나만 존재한다.

## 데이터베이스를 사용하는 이유

- 기본의 파일 시스템이 갖는 데이터의 종속성과 중복성의 문제를 해결하기 위해 제안된 시스템

### 데이터의 독립성

- 데이터베이스의 사이즈를 늘리거나 데이터 파일을 늘리거나 새롭게 추가해도 관련된 응용프로그램을 수정할 필요가 없는 물리적인 독립성을 가진다.
- 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시킬 수 있다.

### 데이터의 무결성

- 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능을 제공하여 데이터의 무결성을 구현한다.
- 데이터의 유효성 검사를 진행하여 데이터의 정확성과 유효성을 보장한다.

### 데이터의 보안성

- 인가된 사용자만 데이터베이스에 접근할 수 있도록 하여 모든 데이터에 대한 보안을 구현할 수 있다.

### 데이터의 일관성

- 연관된 정보를 논리적으로 구현하여 하나의 데이터만 변했을 경우 발생하는 데이터의 불일치성을 방지한다.

### 데이터의 중복 최소화

- 데이터를 통합 관리해서 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.

## 관계형 데이터베이스의 특징

- 데이터의 분류, 정렬, 탐색 속도가 빠르다.
- 데이터의 무결성을 보장한다.
- 기존에 작성한 스키마를 수정하기 어렵다.
- 조인으로 인해 복잡한 쿼리가 발생하거나 성능저하가 발생할 수 있다.

## 관계형 데이터베이스의 무결성

- 정의: 데이터의 정확성 또는 유효성을 의미한다.
- 목적
    - 데이터베이스 내의 데이터의 정확성을 보장하기 위함.
    - 부정확한 자료가 데이터베이스 내에 저장되는 것을 방지하기 위함.

## 무결성 제약조건 종류

### 도메인 무결성

- 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다.
- 도메인으로 값에 대한 범위를 지정할 수 있다.

### 개체 무결성

- 기본 테이블의 기본키를 구성하는 어떤 속성도 null 값이나 중복값을 가질 수 없다.

### 참조 무결성

- 외래키 값은 Null이거나 참조 릴레이션의 기본키의 값과 동일해야 한다.
- 두 릴레이션의 연관된 튜플들 사이의 일관성을 유지하는 데에 사용된다.

## 무결성을 만족시키기 위해 DBMS가 제공하는 옵션

### 제한 (restricted)

- 위배를 야기한 연산을 거절한다.
- ex) 외래키 참조가 존재하는데 부모 테이블의 튜플을 삭제하려는 경우 연산을 거부

### 연쇄 (cascade)

- 참조되는 릴레이션에서 튜플을 삭제하고, 참조하는 릴레이션에서 이 튜플을 참조하는 튜플들도 함께 삭제한다.

### 널값 (nullify)

- 참조되는 릴레이션에서 튜플을 삭제하고, 참조하는 릴레이션에서 이 튜플을 참조하는 튜플들의 외래키에 Null 값을 삽입한다.

### 디폴트 (default)

- Null 값 대신에 디폴트 값을 설정하여 이를 삽입하는 옵션이다.
</details> 

<details>
    <summary><b>Key의 종류</b></summary> 

### 관계형 데이터베이스의 키 종류

### 후보키

- 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합
- **기본키로 사용할 수 있는 속성들을 말한다.**
- 릴레이션에 있는 모든 튜플에 대해 유일성과 최소성을 만족시켜야 한다.
    - 유일성 : 하나의 키 값으로 하나의 튜플만을 식별해야 한다.
    - 최소성 : 모든 레코드들을 유일하게 식별하는데 꼭 필요한 속성으로만 구성되어야 한다.

### 기본키

- 후보키 중에서 특별히 선정된 하나의 키로, 유일성과 최소성을 만족시켜야 한다.
- 튜플을 식별하기 위해 반드시 필요한 키이다.
- **NULL 값을 가질 수 없다.**

### 대체키

- 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미한다.

### 슈퍼키

- 한 릴레이션 내에서 속성들의 묶음으로 구성된 키로, 모든 튜플에 대해 `유일성`만 만족한다.
- 최소성은 만족하지 않아도 괜찮고, 튜플을 구분할 수만 있으면 된다.

### 외래키

- 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합이다.
- 외래키는 참조되는 테이블의 기본키와 동일한 속성을 갖는다.
- 부모 테이블이 먼저 생성되어야 하고, 부모 테이블이 먼저 삭제될 수 없다.
- 외래키에는 참조하는 테이블의 기본키에 없는 값은 들어갈 수 없다.
</details> 

---

<details>
    <summary><b>인덱스 개념, 필요성</b></summary> 

## DB의 인덱스

### 정의 및 목적

- 데이터베이스 테이블의 검색속도를 향상시키기 위한 **자료구조**이다.
- 데이터와 데이터의 위치를 포함하는 자료구조를 통해 빠르게 데이터를 조회할 수 있도록, 그리고 빠르게 검색할 수 있도록 하기 위함이다.

### 인덱스를 사용하면?

- 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
- 원하는 데이터를 찾기 위해 데이터의 위치를 특정함으로써 성능을 끌어올려 전반적인 시스템의 부하를 줄일 수 있다.

### 인덱스를 무조건 사용하면 좋은것인가?

- 인덱스를 관리하기 위해 DB의 약 10% 정도의 저장공간을 필요로 한다.
- 인덱스를 관리하기 위한 별도의 작업이 반드시 필요하다.
- 인덱스를 잘못 사용하는 경우에는 오히려 성능을 떨어트릴 수 있어 주의해야 한다.

### 인덱스의 관리 방법

인덱스는 빠른 탐색을 위해 **항상 최신의 정렬된 상태를 유지**해야 한다는 특징을 가지고 있다. 따라서 테이블이 변경되는 `INSERT`, `UPDATE`, `DELETE`의 경우 각각의 추가 연산을 수행해야 한다.

- `INSERT` : 새로운 데이터에 대한 인덱스를 추가한다.
- `UPDATE` : 기존의 인덱스를 ‘**사용하지 않음’**으로 처리하고 갱신된 데이터에 대해 새로운 인덱스를 추가한다.
- `DELETE` : 삭제하는 데이터의 인덱스를 ‘**사용하지 않음**’으로 처리한다.

‼️ 따라서, INSERT, UPDATE, DELETE 가 인덱스가 적용된 속성에 빈번하게 일어날 경우 인덱스의 크기가 비대해 질 수 있다 !

### 왜 DB 튜닝에서 인덱싱이 가장 많이 이루어질까? 🤔

애플리케이션을 변경하지 않아도 데이터베이스의 조작만으로 손쉽게 성능을 개선시킬 수 있기 때문에 가장 많이, 그리고 가장 먼저 이루어진다고 한다.

### 참고
- [[Database] 인덱스(index)란?](https://mangkyu.tistory.com/96)
- [Database Index, 제대로 알아보기](https://gngsn.tistory.com/88)
- [[MYSQL] 📚 인덱스(index) 핵심 설계 & 사용 문법 💯 총정리](https://inpa.tistory.com/entry/MYSQL-📚-인덱스index-핵심-설계-사용-문법-💯-총정리#)
</details> 

<details>
    <summary><b>인덱스를 어느 column에 사용할까</b></summary> 

### 인덱스를 더욱 효율적으로 사용하기 위한 고려사항

***부제; 어느 것에 인덱스를 적용해야 할까? 💁🏻‍♀️***

인덱스를 더욱 효율적으로 잘 사용하기 위해 고려하는 것에는 4가지가 있다.

**카디널리티**

> 카디널리티가 높을수록 인덱스 설정에 좋은 속성이다.
>
- 정의: 컬럼에 사용되는 값의 다양성 정도, 즉 **UNIQUE한 정도**를 나타낸 것이다.
    - 값이 중복되지 않을수록 카디널리티는 높아진다.
- 주의해야 하는 것이, 카디널리티는 **상대적인 값**이다.

  *예를 들어, 학생 테이블에 학번과 이름의 속성이 있다고 할 때, 학번은 절대로 겹치지 않는 값을 가지는 속성이고, 이름은 동명이인이 있을 수 있어 겹치는 값이 있는 속성이다. 그러면 이때, 학번의 카디널리티가 이름에 비해 높다고 말할 수 있는 것이다.*


**선택도**

> 선택도가 낮을수록 인덱스 설정에 좋은 속성이다.

- 정의: 전체 레코드 중에서 조건절(WHERE)에 의해 선택될 것으로 예상되는 레코드의 비율을 나타낸 것이다.
    - 선텍도는 다음과 같이 구할 수 있다.

>  선택되는 튜플의 수 / 총 레코드 수 = 카디널리티 / 총 레코드 수

- 선택되는 튜플의 수가 적을수록 선택도가 적어지기 때문에 한 번의 선택으로 조금만 선택되는 속성이 좋은 것이 되는 거다.

😳 ***카디널리티가 높을수록 좋은데, 어떻게 선택도는 낮을수록 좋은 것이죠? 수식상으로 안맞지 않나요?***

→ 바로 총 레코드 수에 의해 성립되는 것이다.

예를 들어, 개발자에 대한 정보를 담고 있는 테이블이 있고 총 레코드 수는 50개이며, 속성 중에 `주력 언어`라는 속성이 있다고 하자. 현재 여기에 들어있는 데이터에는 Java, Python, C 가 있다고 하자. 그러면 이때의 카디널리티는? **3**이 된다. (유니크한 정도이기 때문에 유니크한 값의 갯수를 말하면 된다.)

이때의 선택도를 계산하면 3 / 50 이기 때문에 **0.6**이 된다.

> *카디널리티 3, 선택도 0.6*
>

그리고 이후, 데이터가 더 삽입되어 총 레코드 수는 100개가 되었다고 하자. 그러면 이 경우에는 전체 데이터 종류에는 변함이 없으므로 카디널리티는 그대로 **3**이 되고, 선택도는 3 / 100 이므로 **0.3**이 된다.

> *카디널리티 3, 선택도 0.3*
>

또 이후, 데이터가 추가되면서 주력 언어에 JavaScript, Kotiln이 추가되고, 총 레코드 수가 500개가 되었다고 하자. 그러면 카디널리티는 유니한 정도이고, 주력 언어는 총 5개의 유니크한 값이 되므로 **5**가 된다. 선택도는 5 / 500 이므로 **0.1**이 된다.

> *카디널리티 5, 선택도 0.1*
>

이제 정리해보면, 선택도는 카디널리티뿐만 아니라 총 레코드 수에 대해서도 영향을 많이 받고 있었고, 카디널리티가 증가하였을 때 선택도는 동시에 낮아지는 것을 볼 수 있었다. **따라서 카디널리티가 높아지면 선택도가 낮아지는 비례관계가 성립될 수 있게 된다.**

**활용도**

> 활용도가 높을수록 인덱스 설정에 좋은 속성이다.
>
- 정의: 해당 속성이 실제 작업에서 얼마나 활용되는지에 대한 값이다.
    - 이는 WHERE 절에서 얼마나 많이 활용되는지를 보면 나온다.

**중복도**

> 중복도가 낮을수록 인덱스 설정에 좋은 속성이다.
>
- 정의: 중복 인덱스 여부에 대한 값이다.
    - 속성을 통해 인덱스를 생성하는 과정에서, 속성을 조합해서도 인덱스 설정이 가능하다. 이때, 적용하는 속성이 다르면 인덱스를 새롭게 생성하기 때문에 같은 속성에 대해 인덱스를 중복하여 설정할 수 있다.
- 인덱스가 메모리를 사용하기 때문에 같은 속성에 중복으로 설정하지 않는 것이 웬만하면 좋다.

즉 위의 4가지를 종합하여 보면 이러한 속성이 인덱스에 적절하다.

- **조회 시 자주 사용되는 속성**
- **고유한 값으로 이루어진 속성**
- **INSERT, UPDATE, DELETE가 자주 발생하지 않는 속성**

### 참고
- [인덱스 카디널리티 부분 질문이있습니다.](https://www.inflearn.com/questions/720337/인덱스-카디널리티-부분-질문이있습니다)
- [DB 인덱스를 효과적으로 설정하는 방법 - 고려해야 할 4가지](https://yurimkoo.github.io/db/2020/03/14/db-index.html)
- [DB Index 입문](https://tecoble.techcourse.co.kr/post/2021-09-18-db-index/)
</details> 

<details>
    <summary><b>인덱스의 자료구조</b></summary> 

### 페이지

- 정의: 디스크와 메모리(버퍼풀)에 데이터를 읽고 쓰는 최소 작업 단위
- 일반적인 인덱스와 PK(Clustered Index) 와 테이블 등은 모두 페이지 단위로 구성된다.\

  → 쿼리를 통해 하나의 데이터에 접근하고 집더라도 하나의 페이지를 읽어야 한다.

- 개별 데이터 크기에 따라 페이지 단위 작업 성능이 달라진다.

> 개별 데이터 크기를 최대한 작게하여 1개의 페이지에 많은 데이터를 저장할 수 있도록 하는 것이 상당히 중요하다.
>
- 만약 개별 데이터의 크기가 크다면?
    - 레코드를 찾기 위해 페이지에 대한 I/O 요청이 많아져 성능이 저하될 수 있다.
    - 데이터 크기가 증가하여, 페이지 크기도 증가하기 때문에 메모리에 캐싱할 수 있는 페이지의 수가 줄어든다.

## 인덱스에 사용되는 자료구조

### 해시 테이블

- 해시값을 사용하여 고유한 index 값을 생성하고, 그 index에 저장된 값을 꺼내오는 형태이다.
- 시간복잡도는 O(1)로 빠른 데이터 검색이 필요할 때 유용하다.
    - 하지만 해시 충돌이 자주 일어나는 경우에는 O(N)의 시간 복잡도가 발생할 수 있어 주의해야한다.
- 해시 테이블은 완전히 일치하는 등호 연산(=), 특정 데이터에 대한 조회에 최적화 되어 있으며, 부등호 연산(<, >) 과 같은 범위 연산에는 적합하지 않다.
    - 해시 값은 유사한 key 값을 가져도 완전히 다른 값으로 생성되고, 정렬을 지원하지 않기 때문이다.

### B-Tree

- B-Tree 자료구조는 한쪽으로 편향되는 트리의 단점을 보완하기 위한 자료구조로, 모든 리프 노드들이 같은 레벨을 가질 수 있도록 자동으로 밸런스를 맞춰주는 트리 구조이다.
- 2개의 자식 노드만 가질 수 있는 기존의 이진 트리를 확장하여 **N개의 자식 노드**를 가질 수 있도록 고안되었다.
- 각 노드는 여러 개의 key를 가질 수 있으며, 각 key에 대응하는 데이터도 가지고 있다.
    - 각 노드는 배열의 형태로 저장되고, 인접한 인덱스를 조회할 경우, 포인터를 통해 조회하는 것이 아닌 바로 옆의 인덱스를 살펴보면 되기 때문에 참조 포인터가 적어 매우 방대한 데이터에서도 빠르게 접근이 가능하다. (배열이 메모리에서 연속적으로 데이터를 저장하기 때문)
    - 각 key의 대소비교로 검색이 진행되고, 리프 노드까지도 해당하는 값이 없다면 실패로 종료된다.
    - key 들은 항상 정렬된 상태를 유지하며, 각 노드가 자식노드를 가리키는 포인터를 가진다.
- 데이터들은 데이터와 데이터 사이의 범위를 사용하여 자식노드를 구성한다.
- 루트에서 리프 노드까지의 거리가 일정하기 때문에 평균 시간 복잡도가 `O(logN)` 이다.
- B-Tree 자료구조가 인덱스에 이용되는 이유
    - 항상 정렬된 상태를 유지하기 때문에 부등호 연산에 적합하다.
    - 배열의 형태로 key 가 저장되어 참조 포인트가 적어 방대한 데이터에서도 빠른 접근이 가능하다.
- B-Tree 인덱스 자료구조의 단점
    - 정렬된 상태를 유지해야 하기 때문에 인덱스가 적용된 테이블의 갱신이 자주 일어날 경우 성능저하가 일어날 수 있다.
    - 모든 노드가 데이터를 가지고 있어 중위 탐색으로 진행하기 때문에 효율이 좋지 않다.

### B+Tree

- B-Tree를 확장 및 개선한 자료구조로, **리프 노드에만 데이터의 위치 즉, 값(value)을 저장**한다.
    - 중간 노드에는 값을 저장하지 않아 B-Tree 보다 메모리를 덜 차지하며, 루트에서 리프노드까지 한 개의 경로만 탐색하면 되기 때문에 매우 효율적이다.
    - 루트, 중간노드에 값이 저장되지 않아 키를 더욱 많이 저장할 수 있어 트리의 높이가 비교적 낮은 편이다.
- 리프노드들끼리 LinkedList 구조로 서로를 참조하고 있다.
    - 부등호 연산시 순차 탐색을 하는 B-Tree에 비해 한번만 탐색을 진행할 수 있어 성능상 이점이 있다.
- O(𝑙𝑜𝑔2𝑛)의 시간복잡도를 가지지만 인덱스에 더욱 최적화된 자료구조이다.
</details> 

<details>
    <summary><b>인덱스는 왜 hash table이 아니라 b+tre로 구현되었을까</b></summary> 

- 해시 테이블은 완전히 일치하는 등호 연산(=), 특정 데이터에 대한 조회에 최적화 되어 있으며, 부등호 연산(<, >) 과 같은 범위 연산에는 적합하지 않다.
    - 해시 값은 유사한 key 값을 가져도 완전히 다른 값으로 생성되고, 정렬을 지원하지 않기 때문이다.
</details> 

---
<details> 
    <summary><b>Join</b></summary>

## 조인이란

관계형 데이터베이스에서 분리되어 저장되어 있는 테이블을 조합하는 연산을 말한다.

조인을 통해 하나의 새로운 테이블을 형성할 수 있고, 그 자체로 이용할 수 있는 결과 셋을 내기도 한다.

### 조인이 왜 필요할까?

관계형 데이터베이스는 정규화를 수행하게 되면 관계를 통해 테이블들이 분리된다. 이를 통해 효율성과 확정성이 향상되지만, 분리되어 있는 테이블에서 값을 검색하기에는 쉽지 않다.

이를 위해 테이블 간의 조인 연산을 통해 효과적인 검색을 이룰 수 있다.

## 조인의 종류

### 내부 조인 (inner join)

- 가장 흔하게 사용되는 결합 방식으로 기본 조인 형식으로 간주된다.
- 내부 조인은 2개의 테이블의 컬럼 값을 결합함으로써 새로운 결과 테이블을 생성한다.
- 명시적 조인과 암시적 조인, 두 가지로 표현 방식이 나뉜다.
    - 명시적 조인 : `JOIN`, `ON` 키워드로 조인에 대한 구문을 지정한다.

    ```sql
    SELECT * FROM employee INNER JOIN department ON employee.DepartmentID = department.DepartmentID;
    ```

    - 암시적 조인 : 컴마를 사용하여 단순히 조인을 위한 여러 테이블을 나열한다.

    ```sql
    SELECT * FROM employee, department WHERE employee.DepartmentID = department.DepartmentID;
    ```


### **동등 조인**

- 비교자 기반의 조인이며, 조인 구문에서 동등비교만을 사용한다.
- 다른 비교 연산자를 사용하는 것은 동등 조인으로서의 조인의 자격을 박탈하는 것이다.

### 자연 조인

- 동등 조인의 한 유형으로 조인 구문이 조인된 테이블에서 동일한 컬럼명을 가진 2개의 테이블에서 모든 컬럼들을 비교함으로써 암시적으로 일어나는 구문이다.
- 결과적으로 나온 조인된 테이블은 동일한 이름을 가진 컬럼의 각 쌍에 대한 단 하나의 컬럼만 포함하고 있다.

### 교차 조인

- 조인되는 두 테이블에서 곱집합을 반환한다.
- 두 번째 테이블로부터 각 행과 첫 번째 테이블에서 각 행이 한번씩 결합된 열을 만든다.

![교차조인](image/images-ragnarok_code-post-78cba48f-ce90-4b0d-8764-3672bc242e72-스크린샷%202021-11-27%20오후%201.17.36.png)

### 외부 조인

- 조인 대상 테이블에서 특정 테이블의 데이터가 모두 필요한 상황에서 외부 조인을 활용하여 효과적으로 결과 집합을 생성할 수 있다.
- **왼쪽 외부 조인 (left outer join)**
    - 우측 테이블에 조인할 컬럼의 값이 없는 경우 사용한다.
    - 좌측 테이블의 모든 데이터를 포함하는 결과 집합을 생성한다.
    - 즉, **좌측 테이블과 우측 테이블**의 교집합과 **좌측 테이블의 모든 데이터**로 결과 집합이 생성된다.
- **오른쪽 외부 조인 (right outer join)**
    - 좌측 테이블에 조인할 컬럼의 값이 없는 경우 사용한다.
    - 우측 테이블의 모든 데이터를 포함하는 결과 집합을 생성한다.
    - 즉, **좌측 테이블과 우측 테이블의 교집합**과 **우측 테이블의 모든 데이터**로 결과 집합이 생성된다.
</details>

<details> 
    <summary><b>left outer join vs inner join</b></summary>

## left outer join vs inner join

inner join의 경우 양 쪽 모두 테이블에 데이터가 존재하는 경우에만 데이터가 반환된다. 즉, inner join 의 경우 한 쪽 테이블의 join 에 사용되는 속성 값이 null 일 경우에는 데이터가 반환되지 않는다.

반면에 left outer join 의 경우 공통된 속성에 Null 값이 포함되어 있어도 좌측 테이블의 모든 데이터 값을 읽어오기 때문에 해당 속성을 Null로 채운 후에 가져온다는 차이가 있다.

성능으로 비교하는 경우 inner join이 대체적으로 우세하다는 이야기가 있다.

아무래도 left outer join은 동일한 값 외에 좌측 테이블의 값을 모두 찾아와야 하기 때문에 inner join이 성능적으로 더욱 이점이 있다고 할 수 있다.
</details>

<details> 
    <summary><b>정규화</b></summary>

## 정규화란?

- 정의: 관계형 데이터베이스의 설계에서 중복을 최소화하고 이상현상을 해결하기 위해 데이터를 구조화하는 프로세스
- 목적
  - 데이터의 일관성, 최소한의 중복, 최대한의 데이터 유연성을 위함.
  - 데이터 삽입, 삭제, 수정 시에 발생하는 영향을 최소화하기 위함.
- 정규화를 하면?
  - 데이터 중복 최소화
  - 데이터 구조의 안전성 최대화
  - 데이터 무결성 제약 조건 만족
    - 무결성 : 데이터의 `일관성`, `유효성`, `정확성`
- 정규화 원칙
  - **정보의 무손실**: 분해된 릴레이션이 표현하는 정보는 분해되기 전의 정보를 모두 포함해야 한다.
  - **최소 데이터 중복** : 이상 현상을 제거, 데이터 중복을 최소화 한다.
  - **분리의 원칙** : 하나의 독립된 관계성은 하나의 독립된 릴레이션으로 표현한다.
- 정규화의 단점
  - 데이터를 처리할 때 속도가 느려질 수 있는 성능상 단점이 있다.
</details>

<details> 
    <summary><b>정규화 종류</b></summary>

## 정규화 과정

### 1. 제 1 정규형

- 릴레션에 속하는 모든 속성의 값이 **원자값**으로 구성되어야 한다.
- 제 1 정규형을 진행하면 모든 튜플들이 원자값으로 구성되게 된다.
- 제1 정규형을 만족하면 이상 현상이 해결될까?
  - 원자값이 아닌 튜플을 삭제할 경우, 원하지 않는 정보까지 삭제되는 삭제 이상 현상이 발생한다. 제 1 정규형을 만족하면 삭제 이상의 일부 현상은 해결할 수 있지만 여전히 삭제 이상이 남아있다.
  - 불필요한 정보까지 넣어야 하는 삽입 이상이 남아있다.
  - 일부의 튜플을 수정하면 데이터의 일관성이 깨지는 갱신 이상이 남아있다.
- 아직도 이런 문제가 발생하는 이유는?
  - 기본키가 아닌 속성들이 기본키에 완전 함수 종속이 아닌 **부분 함수 종속**이기 때문이다.

  → 부분 함수 종속들을 없애주어야 한다. (릴레이션을 분리해야한다.)


### 함수적 종속

- 어떤 테이블의 속성 A와 B에 대해서 **A 값에 의해 B 값이 유일하게 정해지는 관계.**
- A → B 의 기호로 나타내며, A를 **결정자**, B를 종속자라고 한다.
- 함수적 종속 종류
  - 완전 함수 종속 : 기본키를 구성하는 모든 속성에 종속되는 경우
    - EX) 성적 속성은 기본키인 학생번호, 과목명에 모두 종속적이다. → 학생번호와 과목명에 의해 유일한 값이 정해지기 때문에
  - 부분 함수 종속 : 기본키를 구성하는 속성의 일부에 종속되거나, 기본키가 아닌 다른 속성에 종속되는 경우
    - EX) 학생의 이름은 기본키인 학생 번호, 과목명에 모두 종속하지 않고, 학생 번호에만 종속적이다. (학생 번호만으로 학생의 이름을 특정할 수 있기 때문에)
  - 이행적 함수 종속 : A, B, C 속성이 있고, A → B, B → C 인 관계에서 A → C의 관계가 성립하는 경우
    - EX) 학과 → 학과 사무실, 학과 사무실 → 학과 전화번호 인 관계에서 학과 → 학과 전화번호 관계가 성립한다.

### 2. 제 2 정규형

- 제 1 정규형을 만족하면서 **완전 함수적 종속**을 만족하는 경우
- 제 2 정규형을 진행하면 기본키가 아닌 속성이 완전 함수적 종속을 만족하지 않으면 릴레이션이 분리되어 완전 함수적 종속을 모두 만족할 수 있게 된다.
- 제 2 정규형을 만족하면 이상 현상이 해결될까?
  - 여전히 튜플을 삭제하면 필요한 정보까지 삭제되는 삭제 이상이 남아있다.
  - 여전히 필요하지 않은 정보까지 입력해야 한다는 삽입 이상이 남아있다.
  - 여전히 일관성을 깨트리는 갱신 이상이 남아있다.
- 아직도 이런 문제가 발생하는 이유는?
  - 이행적 함수 종속 관계가 남아있기 때문이다.

### 3. 제 3 정규형

- 제 2 정규형이면서, 이행적 함수 종속성을 제거한 정규형이다.
- 기본키에 속하지 않은 모든 속성이 기본키에 이행적 함수 종속을 만족하지 않는 것을 말한다.
  - == 기본키 이외의 속성이 그 외 다른 속성의 값을 결정하지 않는다.
- 제 3 정규형을 진행하면 기본키만이 속성의 값을 결정할 수 있고, 즉 이행적 함수 종속 관계가 존재하지 않는 릴레이션으로 분리된다.
- 제 3 정규형을 만족하면 이상현상이 해결될까?
  - 여전히 튜플을 삭제하면 필요한 정보까지 삭제되는 삭제 이상이 남아있다.
  - 여전히 필요하지 않은 정보까지 입력해야 한다는 삽입 이상이 남아있다.
  - 여전히 일관성을 깨트리는 갱신 이상이 남아있다.
- 아직도 이런 문제가 발생하는 이유는?
  - 결정자가 `후보키`로 취급되고 있지 않기 때문이다.
    - 후보키 : 기본키로 선정된 것 이외의 기본키가 될 수 있는 키인데, 최소성과 유일성을 만족하는 속성이나 속성들의 집합을 얘기한다.

### 4. BNCF(Boyce and Codd Normal Form)

- 제 3 정규형을 더욱 강화한 개념이다.
- 제 3 정규형에서 결정자가 후보키가 될 수 있도록 릴레이션을 분리한 형태이다.
</details>

<details> 
    <summary><b>이상 현상</b></summary>

### 이상현상

데이터 중복 문제로 관계 연산을 처리할 때 발생하는 곤란한 현상들을 말한다.

- **삭제 이상** : 튜플 삭제 시 필요한 정보까지 연쇄적으로 삭제가 발생하는 것.
- **삽입 이상** : 튜플 삽입 시 지정하지 않은 값은 null 로 저장되거나 삽입을 위해 불필요한 데이터가 함께 넣는 것.
- **갱신 이상** : 데이터 수정 시 일부 값만 수정되어 데이터가 불일치되어 일관성이 깨지는 것.
</details>

---

<details>
    <summary><b>View</b></summary> 

## View란?

👩🏻‍🏫 정의 : 데이터베이스에 존재하는 일종의 **가상테이블**.

- 실제 데이터를 가지고 있지 않으며, SQL을 저장하고 있다.

### 데이터가 없고 SQL을 저장?

사용자는 해당 뷰를 통해 데이터를 조회할 경우 저장된 SQL문이 수행되어 데이터가 조회되기 때문에 마치 테이블이 저장되어 있는 것처럼 느낀다.

그래서 실제로 물리적으로 저장되어 있지 않은 테이블이기 때문에 가상 테이블이라고 하며, 뷰를 조회하게 되면 뷰가 바라보고 있는 테이블에 저장되어 있는 SQL 문이 실행되어 나온 결과를 반환한다.

### View의 목적

SQL문을 저장함으로써 얻으려는 것이 무엇일까?

관계형 데이터베이스에서는 테이블이 많이 분리되어 있기도 하고, 데이터를 가져오기 위해 굉장히 복잡한 쿼리를 작성하게 되는 경우가 있다. View는 이렇게 복잡한 쿼리 자체를 저장하여 사용자가 편리하게 데이터 조회를 할 수 있도록 도와주기 위한 것에 목적이 있다.

복잡한 쿼리를 단순하게 해주는 것 외에 보안적인 측면에서의 목적도 있다.

뷰가 바라보는 테이블을 함부로 접근하지 못하게 하고, 데이터를 조회하고 활용하는 것으로 뷰를 제공하여 보여지면 안되는 민감 정보를 숨길 수 있고, 굳이 불필요한 정보까지 모두 조회되지 않도록 할 수 있다. 이를 통해 꼭 필요한 정보만 보여주며 데이터에 대한 보안성도 챙길 수 있게 된다.

### 정리 💁🏻‍♀️

> View는 복잡한 쿼리를 단순하게 만듦으로써 쿼리를 관리할 수 있도록 하고, 보여지는 컬럼을 제한하여 보안성을 높이기 위해 사용된다.
>

### View의 특징

- 물리적으로 존재하지 않지만 데이터의 논리적 독립성을 제공한다.
- 기본 테이블이 변경되면 뷰도 자동적으로 변경되고, 뷰를 변경해도 변경 사항이 기본 테이블에 적용된다.
- 뷰의 수정, 삽입, 삭제에는 제한 사항이 따른다.
- View는 자신만의 인덱스를 가지지 않고, 바라보고 있는 테이블의 인덱스를 따른다.

### View의 장점

- 복잡한 쿼리를 단순화하여 사용성을 높인다.
- 테이블의 일부 속성만 볼 수 있도록 제한함으로써 보안성이 높아진다.

### View의 단점

- 뷰의 정의를 변경할 수 없다.
- 삽입, 삭제, 갱신에 제한이 있다.

## View의 종류

### 단순 뷰

- 하나의 테이블로 생성된 뷰이다.
- 그룹 함수의 사용이 불가능하다. → 별칭을 붙이면 사용 가능하다는 곳도 있음.
- DISTINCT 사용이 불가능하다.
- 생성된 뷰에서 DML 사용이 가능하다.
    - 집계함수, 그룹 함수, DISTINCT를 사용한 경우 DML 사용이 불가능하다.

### 복합 뷰

- 여러 개의 테이블로 생성된 뷰이다.
- 그룹 함수의 사용이 가능하다.
- DISTINCT 사용이 가능하다.
- 생성된 뷰에서 DML이 가능할 수도 있다.
</details>

---

<details>
    <summary><b>트랜잭션</b></summary> 

## 트랜잭션이란?

👩🏻‍🏫  **정의** : 하나의 논리적 기능을 수행하기 위한 **작업의 단위**를 의미한다.

> *데이터베이스에서는 쿼리를 통해 작업하기 때문에 수행되어야 할 **일련의 연산 모음**이라고도 할 수 있다.*
>
- 작업의 단위는 정해져 있는 것이 아닌 사용자가 직접 정할 수 있다.
</details> 

<details>
    <summary><b>ACID</b></summary> 

### 트랜잭션의 가장 큰 4가지 특징 `ACID`

### 1. 원자성

👩🏻‍🏫 **정의** : 트랜잭션과 관련된 일이 모두 수행되었거나 모두 수행되지 않아야 함을 보장하는 것이다.

- 트랜잭션은 커밋을 통해 작업된 내용이 데이터베이스에 영구적으로 반영된다. ( 트랜잭션이 성공했다면 ! )

  만약 트랜잭션이 수행 중 문제가 발생하면 **해당 트랜잭션을 수행하기 전 상태**로 돌아가는 `롤백`을 수행한다.

  → `커밋`과 `롤백`을 통해 데이터베이스의 **무결성**을 제공한다.

- 트랜잭션의 커밋과 롤백 덕분에 데이터베이스의 변경 사항을 더욱 쉽게 확인할 수 있고, 해당 **작업을 그룹화** 할 수 있다.

⚡️ **트랜잭션 전파**

트랜잭션은 하나의 커넥션 단위 내에서 수행한다.

> *커넥션 : DB와 연결을 위해 사용하는 객체로, 커넥션 풀에 만들어진 커넥션 객체를 가져다가 사용 후 반납하는 방식으로 작동하는 것이 일반적이다.*
>

즉, 하나의 Connection 객체에 의해 시작과 종료가 이루어진다.

→ **하나의 Connection 내에서 여러 트랜잭션을 진행하고 싶은 경우, `트랜잭션 전파`를 통해 추가적으로 트랜잭션을 수행할 수  있다.**

스프링에서는 다양한 트랜잭션 전파 옵션을 제공하고 있다. `@Transactional`이 대표적인 예시이다.

### 2. 일관성

👩🏻‍🏫 **정의** : 트랜잭션의 작업 결과가 항상 일관성 있어야 한다는 것이다.

- 데이터베이스에 기록된 모든 데이터는 여러가지 조건, 규칙에 따라 유효함을 가져야 한다.

  이것이 무슨 의미이냐면,

    - 트랜잭션이 커밋되면 **데이터베이스에 적용한 제약조건을 위반하지 않음**을 보장한다.
    - 트랜잭션 작업이 **애플리케이션이 의도한대로 정상적으로 작동함**을 보장한다.

  이렇게 만족해야 한다는 것이다!

- 예를 들어, 전화번호라는 속성에 `UNIQUE` 제약 조건이 걸려 있다면 중복된 전화번호는 저장되지 않는 동작을 보장해야 한다는 것이다.

### 3. 격리성

👩🏻‍🏫 **정의** : 트랜잭션 수행 시 다른 트랜잭션이 끼어들지 못하도록 보장한다.

- 여러 개의 트랜잭션은 서로 격리되어 **마치 순차적으로 실행**되는 것처럼 작동되어야 하고, 데이터베이스는 여러 사용자가 **동시에 사용**될 수 있음을 의미한다.
- 하지만 완전히 트랜잭션을 분리해내면서 동시성을 부여하는 것은 어려운 일이기 때문에 데이터베이스는 다양한 옵션을 부여한다. → 이것은 트랜잭션 격리 수준에서 다시 살펴볼 예정이다.
- 트랜잭션의 동시성을 위해 다양한 Lock 기능을 제공한다.

### 4. 지속성

👩🏻‍🏫 **정의** : 성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다.

- 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능을 가져야 함을 의미한다.

  → `롤백`도 회복 기능 중 하나에 해당한다.
</details> 

<details>
    <summary><b>동시성 제어, 갱신손실 문제</b></summary> 

## 트랜잭션 동시성 제어

- 다중 사용자 환경에서 둘 이상의 트랜잭션이 동시에 수행될 때, 일관성을 해치지 않도록 트랜잭션의 데이터에 대해 접근을 제어해야 한다.
- 동시에 실행되는 여러 개의 트랜잭션이 성공적으로 작업을 마칠 수 있도록 **트랜잭션의 실행 순서를 제어**한다.

### 동시성 제어의 목적

- 트랜잭션의 직렬성 보장
- 공유도를 최대로, 응답 시간을 최소로, 시스템 활동을 최대로 보장하기 위함
- 데이터의 무결성 및 일관성 보장

## 동시성 제어를 하지 않으면?

### 갱신 손실

👩🏻‍🏫 **정의** : 하나의 트랜잭션이 갱신한 내용을 **다른 트랜잭션이 덮어씀**으로써 갱신이 무효화가 되는 것을 의미한다.

- 두개의 트랜잭션이 동시에 값에 접근하여 수정한 경우에 발생하는 일이며, 절대 데이터베이스 내에서 발생하면 안되는 현상이다.

### 모순성

👩🏻‍🏫 **정의** : 서로 다른 트랜잭션들이 하나의 데이터를 갱신하는 동안 다른 트랜잭션이 해당 값을 읽으면서 조회되는 **데이터가 불일치하는 현상**을 의미한다.

### 연쇄 복귀

👩🏻‍🏫 **정의** : 하나의 트랜잭션이 작업에 실패하여 **RollBack을 수행하는 동안 다른 트랜잭션이 해당 데이터를 읽어서** 발생하는 문제를 의미한다.
</details>

<details>
    <summary><b>Lock, DeadLock</b></summary> 

🔐 **Lock**

InnoDB에서는 Row-level의 Lock에서 Shared Lock, Exclusive Lock 두가지를 제공한다.

**Shared Lock**

- 특정 Row를 **읽을 때** 사용되는 lock이다.
- Shared Lock 끼리는 동시에 접근이 가능하기 때문에 Shared Lock 을 사용하는 쿼리는 같은 Row에 접근할 수 있다. → 즉, **하나의 Row를 여러 트랜잭션이 읽을 수 있다는 것!**
- Shared Lock 이 걸린 속성에 데이터 쓰기 작업을 위한 Exclusive Lock을 걸 수는 없다.

**Exclusive Lock**

- 특정 Row를 변경하고자 할 때 사용되는 lock이다.
- `SELECT … FOR UPDATE`, `UPDATE`, `DELETE`와 같은 수정 쿼리의 각 ROW에 Lock이 걸린다.
- Exclusive Lock이 걸린 Row에는 다른 트랜잭션이 Shared Lock을 걸 수 없고, 해당 Row에 읽기, 수정, 삭제를 수행할 수 없다.
- 해당 Row가 Exclusive Lock이 걸려 있으면 Lock이 해제될 때까지 대기 해야 한다.

**Record Lock**

- 이것은 mysql에서 제공하는 lock으로 DB의 인덱스 레코드에 사용되는 lock이다.
- 만약 어떤 index에 Record Lock이 걸려 있다면 해당 index에 `INSERT`, `UPDATE`, `DELETE` 구문 사용이 제한된다.
- Record lock에도 Shared Lock, Exclusive Lock이 있다.
    - 읽기 작업이라면 Shared Lock, 쓰기 작업이라면 Exclusive Lock이 사용된다.
- 그러면 인덱스가 존재하지 않으면 Record Lock은 발생하지 않을까?

  → mysql은 테이블을 생성할 때 인덱스를 생성하지 않으면 내부적으로 Clustered Index를 생성하기 때문에 정상적으로 Record Lock이 수행되는 것을 확인할 수 있다.


**Gap Lock**

- DB 인덱스 레코드의 `gap`에 사용되는 lock이다.

> gap : index 중 DB에 실제 record가 없는 부분을 말한다.
>

| id | row addr |
| --- | --- |
| 3 | addr to 3 |
| 7 | addr to 7 |
index 테이블

| id |
| --- |
| 3 |
| 7 |
실제 데이터 테이블

`id ≤ 2`

`4 ≤ id ≤ 6`

`id ≥ 8`

위의 범위가 실제 레코드가 없는 인덱스 gap을 의미한다.

- 해당 gap에 접근하려는 다른 쿼리의 접근을 막는다.
- **조건에 해당하는 새로운 row가 추가되는 것을 방지하기 위해 사용된다.**

**Next-Key Lock**

```sql
SELECT * WHERE pk > 99 FOR UPDATE;
```

- 위의 구문이 실행될 때 어떤 Lock이 걸릴지 예상해보자.
    - `FOR UPDATE` 키워드가 사용되었으니 우선 `Exclusive Lock`이 걸릴 것이고, `pk`가 인덱스이므로 `Record Lock`이 걸릴 것이다.
    - 그러면 Gap Lock은 어떻게 사용할 수 있는지 궁금할 것이다. 사실은 **범위를 지정한 쿼리**를 실행하면 Record Lock, Gap Lock이 **복합적으로 적용**된다.
        - Record Lock : 찾아진 인덱스 레코드에 대해 Lock 수행
        - Gap Lock : 찾아진 인덱스 사이사이의 레코드에 대해 Lock 수행
    - 그러면 결과를 살펴보자면,

      PK가 99보다 큰 실존하는 인덱스에 대해 현재 Exclusive Lock인 Record Lock이 걸릴 것이다.

      그리고, 99보다 작은 실존하는 인덱스 중에 가장 가까운 인덱스부터 99보다 큰 실존하는 인덱스에 Gap Lock이 걸릴 것이다.

      마지막으로 99보다 큰 실존하는 인덱스의 사이사이 레코드에 대해 Gap Lock이 걸릴 것이다.


↔️ **Lock 설정 범위**

- **데이터베이스** : 전체 데이터베이스를 기준으로 lock을 수행하는 것으로 1개의 세션만이 DB의 데이터에 접근할 수 있도록 하는 것인데, 잘 사용되지 않는다.
- **파일** : 데이터베이스의 파일을 기준으로 lock을 수행하는 것으로, 잘 사용되지 않는다.
- **테이블** : 테이블을 기준으로 lock을 수행하는 것으로, 테이블의 모든 행을 업데이트 하는 등의 전체 테이블에 대한 변경을 수행하는 경우에 사용하면 유용하다.
- **페이지와 블럭** : 파일의 일부인 페이지와 블록을 기준으로 lock을 수행하는 것으로, 잘 사용되지 않는다.
- **컬럼** : 컬럼을 기준으로 lock을 수행하는 것으로, Lock 설정 및 해제의 리소스가 많이 들어 잘 사용되지 않는다.
- **행(Row)** : 1개의 행을 기준으로 lock을 수행하는 것으로, 가장 일반적으로 사용하는 범위이다.
</details>

<details>
    <summary><b>트랜잭션 고립(격리) 수준</b></summary> 
</details> 

<details>
    <summary><b>트랜잭션 회복</b></summary> 
</details> 

--- 

<details>
    <summary><b>NoSQL</b></summary> 
</details>

<details>
    <summary><b>NoSQL Vs. RDB</b></summary> 
</details>