
<details>
    <summary><b>관계형 데이터베이스</b></summary> 

## 관계형 데이터베이스

- 가장 널리 사용되는 데이터베이스로 관계형 데이터 모델을 기반으로 한다.

### 관계형 데이터 모델

- 테이블을 이용하여 데이터 상호 관계를 정의하는 DB 모델

### 관계형 데이터베이스 구성 요소

- 테이블
    - 행과 열로 이루어진 데이터의 집합이다.
    - 관계형 데이터베이스에서는 특별한 제약들을 추가하여 이를 **릴레이션**이라고 한다.
        - 릴레이션 : 중복되는 튜플을 가질 수 없으며, 튜플 간에 순서가 존재하지 않는다.
- 튜플
    - 릴레이션을 구성하는 각각의 행
    - 튜플의 수를 카디널리티라고 한다.
- 속성
    - 데이터베이스를 구성하는 가장 작은 논리적 단위
    - 속성은 개체의 특성을 기술한다.
- 도메인
    - 필드에 채워질 수 있는 값의 집합이다.
    - 값이 나타날 때 그 값의 합법 여부를 검사하는데에도 이용된다.
    - EX) `성별` 이라는 속성의 도메인은 남과 여로, 그 외에는 없다.
- 스키마
    - 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 것이다.
    - 데이터베이스를 구성하는 데이터 레코드 크기, 키의 정의, 레코드간의 관계 등을 정의한다.
    - 사용자 관점에 따라 내부, 외부, 개념 스키마로 나뉜다.
    - 내부 스키마 = `저장` 스키마
        - 물리적 저장장치의 입장에서 본 데이터베이스 구조
        - 실제로 데이터베이스에 저장될 레코드의 형식을 지정하고, 저장하는 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타낸다.
    - 외부 스키마 = `사용자` 뷰
        - 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것.
        - 어떤 형식, 구조, 화면을 통해 사용자에게 보여줄 것인지에 대한 명세를 나타낸다.
        - 여러 개의 외부 스키마가 있을 수 있다.
        - 일반 사용자에게 질의어를 통해 DB를 쉽게 사용할 수 있도록 하고, 응용 프로그래머는 언어를 사용해서 DB에 접근할 수 있도록 한다.
    - 개념 스키마 = `전체`적인 뷰
        - 데이터베이스의 전체적인 논리적 구조를 나타낸다.
        - 접근 권한, 보안 및 무결성 규칙에 관한 명세를 정의한다.
        - 모든 응용프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스 스키마로 하나만 존재한다.

## 데이터베이스를 사용하는 이유

- 기본의 파일 시스템이 갖는 데이터의 종속성과 중복성의 문제를 해결하기 위해 제안된 시스템

### 데이터의 독립성

- 데이터베이스의 사이즈를 늘리거나 데이터 파일을 늘리거나 새롭게 추가해도 관련된 응용프로그램을 수정할 필요가 없는 물리적인 독립성을 가진다.
- 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시킬 수 있다.

### 데이터의 무결성

- 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능을 제공하여 데이터의 무결성을 구현한다.
- 데이터의 유효성 검사를 진행하여 데이터의 정확성과 유효성을 보장한다.

### 데이터의 보안성

- 인가된 사용자만 데이터베이스에 접근할 수 있도록 하여 모든 데이터에 대한 보안을 구현할 수 있다.

### 데이터의 일관성

- 연관된 정보를 논리적으로 구현하여 하나의 데이터만 변했을 경우 발생하는 데이터의 불일치성을 방지한다.

### 데이터의 중복 최소화

- 데이터를 통합 관리해서 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.

## 관계형 데이터베이스의 특징

- 데이터의 분류, 정렬, 탐색 속도가 빠르다.
- 데이터의 무결성을 보장한다.
- 기존에 작성한 스키마를 수정하기 어렵다.
- 조인으로 인해 복잡한 쿼리가 발생하거나 성능저하가 발생할 수 있다.

## 관계형 데이터베이스의 무결성

- 정의: 데이터의 정확성 또는 유효성을 의미한다.
- 목적
    - 데이터베이스 내의 데이터의 정확성을 보장하기 위함.
    - 부정확한 자료가 데이터베이스 내에 저장되는 것을 방지하기 위함.

## 무결성 제약조건 종류

### 도메인 무결성

- 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다.
- 도메인으로 값에 대한 범위를 지정할 수 있다.

### 개체 무결성

- 기본 테이블의 기본키를 구성하는 어떤 속성도 null 값이나 중복값을 가질 수 없다.

### 참조 무결성

- 외래키 값은 Null이거나 참조 릴레이션의 기본키의 값과 동일해야 한다.
- 두 릴레이션의 연관된 튜플들 사이의 일관성을 유지하는 데에 사용된다.

## 무결성을 만족시키기 위해 DBMS가 제공하는 옵션

### 제한 (restricted)

- 위배를 야기한 연산을 거절한다.
- ex) 외래키 참조가 존재하는데 부모 테이블의 튜플을 삭제하려는 경우 연산을 거부

### 연쇄 (cascade)

- 참조되는 릴레이션에서 튜플을 삭제하고, 참조하는 릴레이션에서 이 튜플을 참조하는 튜플들도 함께 삭제한다.

### 널값 (nullify)

- 참조되는 릴레이션에서 튜플을 삭제하고, 참조하는 릴레이션에서 이 튜플을 참조하는 튜플들의 외래키에 Null 값을 삽입한다.

### 디폴트 (default)

- Null 값 대신에 디폴트 값을 설정하여 이를 삽입하는 옵션이다.
</details> 

<details>
    <summary><b>Key의 종류</b></summary> 

### 관계형 데이터베이스의 키 종류

### 후보키

- 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합
- **기본키로 사용할 수 있는 속성들을 말한다.**
- 릴레이션에 있는 모든 튜플에 대해 유일성과 최소성을 만족시켜야 한다.
    - 유일성 : 하나의 키 값으로 하나의 튜플만을 식별해야 한다.
    - 최소성 : 모든 레코드들을 유일하게 식별하는데 꼭 필요한 속성으로만 구성되어야 한다.

### 기본키

- 후보키 중에서 특별히 선정된 하나의 키로, 유일성과 최소성을 만족시켜야 한다.
- 튜플을 식별하기 위해 반드시 필요한 키이다.
- **NULL 값을 가질 수 없다.**

### 대체키

- 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미한다.

### 슈퍼키

- 한 릴레이션 내에서 속성들의 묶음으로 구성된 키로, 모든 튜플에 대해 `유일성`만 만족한다.
- 최소성은 만족하지 않아도 괜찮고, 튜플을 구분할 수만 있으면 된다.

### 외래키

- 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합이다.
- 외래키는 참조되는 테이블의 기본키와 동일한 속성을 갖는다.
- 부모 테이블이 먼저 생성되어야 하고, 부모 테이블이 먼저 삭제될 수 없다.
- 외래키에는 참조하는 테이블의 기본키에 없는 값은 들어갈 수 없다.
</details> 

---

<details>
    <summary><b>인덱스 개념, 필요성</b></summary> 

## DB의 인덱스

### 정의 및 목적

- 데이터베이스 테이블의 검색속도를 향상시키기 위한 **자료구조**이다.
- 데이터와 데이터의 위치를 포함하는 자료구조를 통해 빠르게 데이터를 조회할 수 있도록, 그리고 빠르게 검색할 수 있도록 하기 위함이다.

### 인덱스를 사용하면?

- 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
- 원하는 데이터를 찾기 위해 데이터의 위치를 특정함으로써 성능을 끌어올려 전반적인 시스템의 부하를 줄일 수 있다.

### 인덱스를 무조건 사용하면 좋은것인가?

- 인덱스를 관리하기 위해 DB의 약 10% 정도의 저장공간을 필요로 한다.
- 인덱스를 관리하기 위한 별도의 작업이 반드시 필요하다.
- 인덱스를 잘못 사용하는 경우에는 오히려 성능을 떨어트릴 수 있어 주의해야 한다.

### 인덱스의 관리 방법

인덱스는 빠른 탐색을 위해 **항상 최신의 정렬된 상태를 유지**해야 한다는 특징을 가지고 있다. 따라서 테이블이 변경되는 `INSERT`, `UPDATE`, `DELETE`의 경우 각각의 추가 연산을 수행해야 한다.

- `INSERT` : 새로운 데이터에 대한 인덱스를 추가한다.
- `UPDATE` : 기존의 인덱스를 ‘**사용하지 않음’**으로 처리하고 갱신된 데이터에 대해 새로운 인덱스를 추가한다.
- `DELETE` : 삭제하는 데이터의 인덱스를 ‘**사용하지 않음**’으로 처리한다.

‼️ 따라서, INSERT, UPDATE, DELETE 가 인덱스가 적용된 속성에 빈번하게 일어날 경우 인덱스의 크기가 비대해 질 수 있다 !

### 왜 DB 튜닝에서 인덱싱이 가장 많이 이루어질까? 🤔

애플리케이션을 변경하지 않아도 데이터베이스의 조작만으로 손쉽게 성능을 개선시킬 수 있기 때문에 가장 많이, 그리고 가장 먼저 이루어진다고 한다.

### 참고
- [[Database] 인덱스(index)란?](https://mangkyu.tistory.com/96)
- [Database Index, 제대로 알아보기](https://gngsn.tistory.com/88)
- [[MYSQL] 📚 인덱스(index) 핵심 설계 & 사용 문법 💯 총정리](https://inpa.tistory.com/entry/MYSQL-📚-인덱스index-핵심-설계-사용-문법-💯-총정리#)
</details> 

<details>
    <summary><b>인덱스를 어느 column에 사용할까</b></summary> 

### 인덱스를 더욱 효율적으로 사용하기 위한 고려사항

***부제; 어느 것에 인덱스를 적용해야 할까? 💁🏻‍♀️***

인덱스를 더욱 효율적으로 잘 사용하기 위해 고려하는 것에는 4가지가 있다.

**카디널리티**

> 카디널리티가 높을수록 인덱스 설정에 좋은 속성이다.
>
- 정의: 컬럼에 사용되는 값의 다양성 정도, 즉 **UNIQUE한 정도**를 나타낸 것이다.
    - 값이 중복되지 않을수록 카디널리티는 높아진다.
- 주의해야 하는 것이, 카디널리티는 **상대적인 값**이다.

  *예를 들어, 학생 테이블에 학번과 이름의 속성이 있다고 할 때, 학번은 절대로 겹치지 않는 값을 가지는 속성이고, 이름은 동명이인이 있을 수 있어 겹치는 값이 있는 속성이다. 그러면 이때, 학번의 카디널리티가 이름에 비해 높다고 말할 수 있는 것이다.*


**선택도**

> 선택도가 낮을수록 인덱스 설정에 좋은 속성이다.

- 정의: 전체 레코드 중에서 조건절(WHERE)에 의해 선택될 것으로 예상되는 레코드의 비율을 나타낸 것이다.
    - 선텍도는 다음과 같이 구할 수 있다.

>  선택되는 튜플의 수 / 총 레코드 수 = 카디널리티 / 총 레코드 수

- 선택되는 튜플의 수가 적을수록 선택도가 적어지기 때문에 한 번의 선택으로 조금만 선택되는 속성이 좋은 것이 되는 거다.

😳 ***카디널리티가 높을수록 좋은데, 어떻게 선택도는 낮을수록 좋은 것이죠? 수식상으로 안맞지 않나요?***

→ 바로 총 레코드 수에 의해 성립되는 것이다.

예를 들어, 개발자에 대한 정보를 담고 있는 테이블이 있고 총 레코드 수는 50개이며, 속성 중에 `주력 언어`라는 속성이 있다고 하자. 현재 여기에 들어있는 데이터에는 Java, Python, C 가 있다고 하자. 그러면 이때의 카디널리티는? **3**이 된다. (유니크한 정도이기 때문에 유니크한 값의 갯수를 말하면 된다.)

이때의 선택도를 계산하면 3 / 50 이기 때문에 **0.6**이 된다.

> *카디널리티 3, 선택도 0.6*
>

그리고 이후, 데이터가 더 삽입되어 총 레코드 수는 100개가 되었다고 하자. 그러면 이 경우에는 전체 데이터 종류에는 변함이 없으므로 카디널리티는 그대로 **3**이 되고, 선택도는 3 / 100 이므로 **0.3**이 된다.

> *카디널리티 3, 선택도 0.3*
>

또 이후, 데이터가 추가되면서 주력 언어에 JavaScript, Kotiln이 추가되고, 총 레코드 수가 500개가 되었다고 하자. 그러면 카디널리티는 유니한 정도이고, 주력 언어는 총 5개의 유니크한 값이 되므로 **5**가 된다. 선택도는 5 / 500 이므로 **0.1**이 된다.

> *카디널리티 5, 선택도 0.1*
>

이제 정리해보면, 선택도는 카디널리티뿐만 아니라 총 레코드 수에 대해서도 영향을 많이 받고 있었고, 카디널리티가 증가하였을 때 선택도는 동시에 낮아지는 것을 볼 수 있었다. **따라서 카디널리티가 높아지면 선택도가 낮아지는 비례관계가 성립될 수 있게 된다.**

**활용도**

> 활용도가 높을수록 인덱스 설정에 좋은 속성이다.
>
- 정의: 해당 속성이 실제 작업에서 얼마나 활용되는지에 대한 값이다.
    - 이는 WHERE 절에서 얼마나 많이 활용되는지를 보면 나온다.

**중복도**

> 중복도가 낮을수록 인덱스 설정에 좋은 속성이다.
>
- 정의: 중복 인덱스 여부에 대한 값이다.
    - 속성을 통해 인덱스를 생성하는 과정에서, 속성을 조합해서도 인덱스 설정이 가능하다. 이때, 적용하는 속성이 다르면 인덱스를 새롭게 생성하기 때문에 같은 속성에 대해 인덱스를 중복하여 설정할 수 있다.
- 인덱스가 메모리를 사용하기 때문에 같은 속성에 중복으로 설정하지 않는 것이 웬만하면 좋다.

즉 위의 4가지를 종합하여 보면 이러한 속성이 인덱스에 적절하다.

- **조회 시 자주 사용되는 속성**
- **고유한 값으로 이루어진 속성**
- **INSERT, UPDATE, DELETE가 자주 발생하지 않는 속성**

### 참고
- [인덱스 카디널리티 부분 질문이있습니다.](https://www.inflearn.com/questions/720337/인덱스-카디널리티-부분-질문이있습니다)
- [DB 인덱스를 효과적으로 설정하는 방법 - 고려해야 할 4가지](https://yurimkoo.github.io/db/2020/03/14/db-index.html)
- [DB Index 입문](https://tecoble.techcourse.co.kr/post/2021-09-18-db-index/)
</details> 

<details>
    <summary><b>인덱스의 자료구조</b></summary> 
</details> 

<details>
    <summary><b>인덱스는 왜 hash table이 아니라 b+tre로 구현되었을까</b></summary> 
</details> 

---
