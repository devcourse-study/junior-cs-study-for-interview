## NETWORK


<details>
    <summary><b>OSI 7계층과 TCP/IP 4계층</b></summary>

# OSI 7 계층

컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어서 설명한 것.

= 네트워크에서 통신일 일어나는 과정을 7가지 과정으로 나눈 것이다.

![Untitled](image/OSI.png)

## 왜 7 계층으로 나누었을까?

계층을 나눈 이유는 각 계층이 다른 계층에 대해 몰라도 되며, 그로 인해 각 계층의 캡슐화와 은닉이 가능하게 된다. 따라서 어떤 문제가 발생할 경우, 그 문제와 관련된 계층만 살펴보면 되며, 다른 계층을 신경 쓰지 않아도 된다.

사용자 관점에서 보면 통신이 일어나는 흐름을 한눈에 알아보기 쉽고, 이해하기가 쉬워지는 것도 있다.

<aside>
☁️ `TCP/IP` : 범용적으로 사용하는 TCP 프로토콜과 IP 프로토콜을 OSI 7계층에 맞추어 추상화 시킨 모델이다.

</aside>

## 각 7 계층 특징

### Physical Layer

`데이터 전달`

- 이 계층은 주로 전기적, 기계적, 기능적인 특성을 이용해서 **물리적인 통신 케이블**로 데이터를 전송하는 계층이다.
- 이 계층에서 사용되는 통신 단위는 비트(0과 1로 이루어진)로, 데이터를 전달하는 것에만 집중한다.
    - 즉, 데이터가 무엇인지, 내가 받아야 하는 데이터가 무엇인지, 어떤 에러가 있는지에 대해서는 전혀 신경쓰지 않는다.
- 데이터를 전기적인 신호로 변환해서 주고 받는 기능을 하며, 이 계층에는 대표적으로 통신 케이블, 리피터, 허브 등이 있다.

### Data Link Layer

`에러검출`, `흐름제어`

- **물리 계층을 통해 송수신 되는 정보의 오류과 흐름을 관리하여 안전한 정보의 전달을 수행할 수 있도록 도와주는 역할을 한다.**
    - 즉, 통신에서의 오류를 찾고 재전송하는 기능을 수행하는 계층이다.
    - 포인트 투 포인트 간 신뢰성 있는 전송을 보장하기 위한 계층이다.
- 데이터링크 계층에서는 **맥 주소(물리주소)**를 가지고 통신한다.
    - 또, 이 계층에서 주고 받는 것을 **프레임**이라고 하고, 대표적인 장비로는 브릿지, 스위치 등이 있다.
    - 물리주소 : 해당 네트워크에 연결된 접속 장치의 주소

### Network Layer

`라우팅`, `흐름제어`, `오류제어`

- 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능을 가진다.
    - 이 계층의 주요 역할은 **라우팅**으로, 경로를 선택하고 주소를 정하고, 경로에 따라 패킷을 전달해준다.
        - 데이터를 연결하는 다른 네트워크를 통해 전달함으로써 인터넷이 가능하게 만드는 계층이다.
    - 이때에는 **IP 주소(논리주소)**를 사용한다.
        - 네트워크 관리자가 직접 주소를 할당하며, 계층적 구조를 가진다.
    - 라우팅, 흐름제어, 세그멘테이션, 오류 제어 등을 수행한다.

### Transport Layer

`흐름제어`, `오류제어`, `오류제어`, `혼잡제어`

- 통신을 활성화하기 위한 계층이다.
    - 보통 TCP 프로토콜을 이용하며, 포트를 열어서 응용 프로그램들이 전송을 할 수 있게 한다.
- 데이터가 왔다면 4계층에서 해당 데이터를 하나로 합쳐서 5계층으로 던져준다.
    - 메시지를 전송 가능한 세그먼트 단위로 캡슐화 하거나, 세그먼트를 다시 메시지로 재조립 하는 역할을 수행
    - 각 세그먼트도 순서번호를 가진다.
- 양 끝단의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록 해주어, 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다.
- 특정 연결의 유효성을 제어한다.
    - **패킷들의 전송이 유효한지 확인하고 전송 실패한 패킷들을 다시 전송한다는 것을 뜻한다.**

### Session Layer

`세션관리`

- 데이터가 통신하기 위한 논리적인 연결을 한다.
    - 목적지 주소를 붙인다.
    - 세션 계층은 네트워크 계층과 다르게 **응용 프로그램 관점에서 봐야 한다.**
        - 세션 설정, 유지, 종료, 전송 중단 시 복구 등의 기능을 가진다.
- 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다.
    - TCP/IP 세션을 만들고 없애는 책임을 진다.

### Presentation Layer

`데이터표현관리`

- 데이터 표현이 상이한 응용 프로세스의 독립성을 제공하고, 암호화 한다.
- 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 계층으로부터 덜어준다.
    - 인코딩, 암호화 등의 동작이 이 계층에서 이루어진다.

### Application Layer

`응용서비스`

- 최종 목적지로서, HTTP, FTP, Telnet 등과 같은 프로토콜이 있다.
- 통신 패킷들은 위의 프로토콜에 의해 모두 처리되며 우리가 사용하는 브라우저나 메일 프로그램 등은 보다 쉽게 프로토콜을 사용하게 해주는 응용 프로그램이다.
    - 즉, 모든 통신의 양 끝단은 HTTP 와 같은 프로토콜이지, 응용 프로그램이 아니다.
- 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.
</details>

---

<details>
    <summary><b>TCP/UDP</b></summary>

### TCP vs UDP

> TCP : 인터넷 상에서 데이터를 메시지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜
>
- TCP는 **연결형 서비스를 지원**하는 프로토콜로 인터넷 환경에서 기본으로 제공한다.
    - **패킷을 전송하기 위해 논리적 경로를 배정한다.**
    - **가상회선 패킷 교환 방식**을 사용한다.


- 높은 신뢰성을 보장하며, 흐름 제어 및 혼잡 제어를 담당한다.
    - 3-handshaking, 연결 지향형 서비스로 높은 신뢰성을 가지는 것이다.
    - 전송 순서를 보장한다.
        - 패킷에 부여한 번호를 통해 순서를 파악한다.
- 연결 지향형이기 때문에 UDP보다 속도가 느리다.
    - 데이터의 흐름 제어나 혼잡 제어와 같은 기능을 하는데, 이 기능들은 CPU를 사용하기 때문에 속도에 영향을 준다.
- 전이중, 점대점 방식이다.

즉, TCP는 연속성 보다는 신뢰성 있는 전송이 중요할 때에 사용하는 프로토콜이라고 할 수 있다.

> UDP : 데이터를 데이터그램 단위로 처리하는 프로토콜
>
- **데이터그램**이란 독립적인 관계를 지니는 패킷이라는 뜻으로, UDP의 빠른 속도가 가능하도록 한다.
- **비연결형 프로토콜**로, 연결을 위해 할당하는 논리적인 경로가 없다.
    - 각각의 패킷은 다른 경로로 전송되고, 전송된 패킷은 다른 경로로 독립적으로 처리하게 된다.
    - 각 패킷은 최적의 경로를 선택하여 간다.
    - 즉, 패킷의 순서가 다를 수 있다는 것!
- 정보를 주고 받을 때 정보를 보내거나 받는 신호 절차를 거치지 않는다.
- UDP 헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
- 신뢰성이 낮지만, TCP보다 속도가 빠르다.
    - 패킷을 순서에 맡게 재조립하거나, 패킷에 순서를 부여하는 과정이 없고, 흐름 제어 또는 혼잡 제어와 같은 기능도 없기 때문에 속도가 빠르다.
    - 네트워크 부하가 적다는 장점이 있지만 신뢰성이 낮은 것이 단점이다.

즉, UDP는 신뢰성보다는 연속성이 중요한 서비스, 예를 들면 실시간 서비스에 자주 사용된다.
</details>

<details>
    <summary><b>3way-handshake, 4way-handshake</b></summary>

- 3-way handshaking 과정을 통해 연결을 설정하고, 4-way handshaking 을 통해 해제한다.
    - `3-handshaking` : 목적지와 수신지를 확실히 하여 정확한 전송을 보장하기 위해 세션을 수립하는 과정


    ☁️ 3-handshaking
    1. SYN : 클라이언트는 ISN을 담아 SYN을 보낸다.
    *(ISN : 새로운 TCP연결의 첫번째 패킷에 할당된 임의의 시퀀스 번호, 초기 네트워크 할당을 위한 고유 시퀀스 번호)*

    2. SYN + ACK : 서버는 클라이언트의 SYN을 수신하고, 서버의 ISN을 보내며 승인번호로 클라이언트의 ISN + 1을 보낸다.

    3. ACK : 클라이언트는 서버의 ISN + 1 한 값인 승인번호를 담아 ACK를 서버에 보낸다.

  이 과정을 통해 신뢰성이 구축된다.


    ☁️ 4-handshaking
    1. 클라이언트가 연결을 닫으려고 할 때 FIN으로 설정된 세그먼트를 보낸다.
    그리고 클라이언트는 FIN_WAIT_1 상태로 들어가고 서버의 응답을 기다린다.

    2. 서버는 클라이언트로 ACK라는 승인 세그먼트를 보낸다. 그리고 해당 서버는 CLOSE_WAIT 상태에 들어간다. 그리고 클라이언트는 FIN_WAIT_2 상태에 들어간다.

    3. 서버는 ACK를 보내고 일정 시간 후에 클라이언트에 FIN이라는 세그먼트를 보낸다.

    4.  클라이언트는 TIME_WAIT 상태가 되고 다시 서버로 ACK를 보내서 서버는 CLOSED 상태가 된다.
        이후 클라이언트는 **어느 정도의 시간을 대기한 후** 연결이 닫히고 클라이언트와 서버의 모든 자원의 연결이 해제된다.

        ———————————————————————————————————————————-

        **왜 일정 시간을 기다리고 끝낼까?** 🤔
        
        → 첫번째는 `지연 패킷`이 발생할 경우를 대비하기 위함이다. 패킷이 뒤늦게 도달하고 이를 처리하지 못한다면 데이터 무결성 문제가 발생한다.

  두번째는 `두 장치가 연결이 닫혔는지 확인`하기 위함이다. 만약 서버가 끝내도 된다라고 보내는 상태에서 닫히게 되면 다시 새로운 연결을 하려고 할 때 서버의 상태가 줄곧 끝내도 된다는 상태이기 때문에 접속 오류가 나타나게 된다.

</details>

<details>
    <summary><b>흐름제어, 혼잡제어, 오류제어</b></summary>

`흐름제어`

- 데이터를 송신하는 곳과 수신하는 곳의 **데이터 처리 속도를 조절**하여 수신자의 버퍼 오버플로우를 방지하는 것.

`혼잡제어`

- 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것.

`오류제어`

- 전송시 오류나 분실한 프레임을 찾아 재전송
- 프레임 중복을 막기 위한 메커니즘도 사용한다.

`접근제어`

- 같은 링크에 다수 장치가 연결되어 있을 때, 주어진 순간에 링크를 사용하는 장치 결정
</details>

---

<details>
    <summary><b>HTTP</b></summary>
</details>

<details>
    <summary><b>HTTP status code</b></summary>
</details>

<details>
    <summary><b>HTTP METHOD</b></summary>
</details>

<details>
    <summary><b>HTTP 1.1 VS HTTP 2.0</b></summary>
</details>

<details>
    <summary><b>HTTPS</b></summary>
</details>

---

<details>
    <summary><b>REST API</b></summary>
</details>

---

<details>
    <summary><b>COOKIE & SESSION</b></summary>
</details>

---

<details>
    <summary><b>JWT</b></summary>
</details>

---

<details>
    <summary><b>CORS</b></summary>
</details>

---

<details>
    <summary><b>DNS</b></summary>
</details>

---

<details>
    <summary><b>Blocking/Nonblocking&Synchronous/Asynchronous</b></summary>
</details>

---

<details>
    <summary><b>웹 통신의 흐름(www.example.com을 입력했을 때)</b></summary>
</details>

---
