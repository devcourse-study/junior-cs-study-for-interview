## NETWORK


<details>
    <summary><b>OSI 7계층과 TCP/IP 4계층</b></summary>

## 정리
### OSI 7 계층
- 계층별로 나눔으로써 단계를 통해 통신을 파악하고 오류가 생길 경우 해당 계층만 수정하면 되는 장점이 존재한다.
#### 애플리케이션 계층
- 사용자와 직접 상호작용하는 응용 프로그램들이 포함된 계층
#### 프레젠테이션 계층
- 데이터의 형식을 정의하는 계층
#### 세션 계층
- 컴퓨터끼리 통신을 하기 위해 세션을 만드는 계층
#### 트랜스포트 계층
- 최종 수신 프로세스로 데이터의 전송을 담당하는 계층
#### 네트워크 계층
- 패킷의 전송을 담당하는 계층
#### 링크 계층
- 데이터의 물리적인 전송과 에러 검충, 흐름 제어를 담당하는 계층
#### 물리 계층
- 데이터를 전기 신호로 바꿔주는 계층
### TCP/IP
- 실제 인터넷 통신에 사용되는 실용적인 모델
## 참조
- https://mangkyu.tistory.com/91
</details>

---

<details>
    <summary><b>TCP/UDP</b></summary>

## 정리
| 특징       | TCP                        | UDP                  |
|----------|----------------------------|----------------------|
| 연결 방식    | 연결형 서비스(3-way handshaking) | 비연결형 서비스             |
| 패킷 교환 방식 | 가상 회선 방식                   | 데이터그램 방식             |
| 전송 순서    | 전송 순서 보장                   | 전송 순서 보장 X           |
| 수신 여부 확인 | 수신 여부 확인                   | 수신 여부 확인 X           |
| 통신 방식    | 1:1 통신                     | 1:1 OR 1:N OR N:N 통신 |
| 신뢰성      | 높다                         | 낮다                   |
| 속도       | 느리다                        | 빠르다                  |
## 참조
</details>

<details>
    <summary><b>3way-handshake, 4way-handshake</b></summary>

## 정리
### 3way-handshake
- TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정하는 과정
- 양쪽 데이터 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작하기 전에 한쪽이 다른 쪽이 준비됐다는 것을 알수 있다록 한다.
#### 연결 과정 (Client A, Server B)
1. A -> B: SYN
2. B -> A: SYN + ACK
3. A -> B: SYN
- TCP 헤더에 Control Bit 이 존재한다.
  - 각각의 bit 은 `URG`, `ACK`, `PSH`, `RST`, `SYN`, `FIN` 의미를 가진다.
- 2-way 로 부족한 이유는?
  - TCP 는 양방향성이기 때문에 서버에서도 클라이언트에게 존재를 알리고 패킷을 보낼 수 있다는 신호를 보내야 한다.
- 초기 Sequence Number 를 난수로 하는 이유는?
  - 커넥션을 맺을 때 사용하는 포트는 유한하기 때문에 재사용될 수 있다.
  - 서버 측에서 패킷의 SYN 을 보고 패킷을 구분하는데 순차적인 숫자라면 이전의 커넥션으로부터 오는 패킷으로 인식할 수 있다.
### 4way-handshake
- TCP 의 연결을 해제하는 과정
#### 연결 해제 과정(Client A, Server B)
1. A -> B: Fin
2. B -> A: ACK
3. B -> A: Fin
4. A -> B: ACK
  - 바로 연결 해제를 하지 않고 잠시 기다린다.
  - 서버 측에서 오류 때문에 ACK 를 받지 못할 경우 재전송을 위해서
- 왜 4단계일까?
  - 클라이언트가 데이터 전송을 마쳤다고 해도 서버에서는 아직 보낼 데이터가 남아있을 수도 있기 때문에 일단 Fin 에 대한 Ack 만 보내고, 데이터를 모두 전송한 후에 자신도 Fin 메시지를 보내기 때문이다.
## 참조
</details>

<details>
    <summary><b>흐름제어, 혼잡제어, 오류제어</b></summary>

## 정리
### 흐름 제어
- 송신 측과 수신 측 사이의 데이터 처리 속도 차이를 제어하기 위한 기법
- 송신 측의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지한다.
- 슬라이딩 윈도우 사용
### 혼잡 제어
- 네트워크 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 제어하는 것
### 오류 제어
- 프레임이 손상되었거나 손실되었을 경우, 재전송을 통해 오류 복수
- 방법
  1. Stop-and-Wait
     - 수신 측에서 ACK 또는 NAK 을 보낸다.
     - 수신 측에서 받지 못한 경우 NAK 을 보내고 송신 측은 해당 데이터를 재전송한다.
     - 만약 분실된 경우 타임아웃을 체크하여 데이터를 재전송한다.
  2. Go-Back-N
     - 손상되거나 분실된 경우 확인된 마지막 프레임 이후로 모든 프레임 재전송
  3. Selective-Repeat
     - 손실된 프레임만 재전송
     - 별도의 재정렬을 수행
## 참조

</details>

---

<details>
    <summary><b>HTTP</b></summary>
</details>

<details>
    <summary><b>HTTP status code</b></summary>
</details>

<details>
    <summary><b>HTTP METHOD</b></summary>
</details>

<details>
    <summary><b>HTTP 1.1 VS HTTP 2.0</b></summary>
</details>

<details>
    <summary><b>HTTPS</b></summary>
</details>

---

<details>
    <summary><b>REST API</b></summary>
</details>

---

<details>
    <summary><b>COOKIE & SESSION</b></summary>
</details>

---

<details>
    <summary><b>JWT</b></summary>
</details>

---

<details>
    <summary><b>CORS</b></summary>
</details>

---

<details>
    <summary><b>DNS</b></summary>
</details>

---

<details>
    <summary><b>Blocking/Nonblocking&Synchronous/Asynchronous</b></summary>
</details>

---

<details>
    <summary><b>웹 통신의 흐름(www.example.com을 입력했을 때)</b></summary>
</details>

---
