## NETWORK


<details>
    <summary><b>OSI 7계층과 TCP/IP 4계층</b></summary>

# OSI 7 계층

컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어서 설명한 것.

= 네트워크에서 통신일 일어나는 과정을 7가지 과정으로 나눈 것이다.

![Untitled](image/OSI.png)

## 왜 7 계층으로 나누었을까?

계층을 나눈 이유는 각 계층이 다른 계층에 대해 몰라도 되며, 그로 인해 각 계층의 캡슐화와 은닉이 가능하게 된다. 따라서 어떤 문제가 발생할 경우, 그 문제와 관련된 계층만 살펴보면 되며, 다른 계층을 신경 쓰지 않아도 된다.

사용자 관점에서 보면 통신이 일어나는 흐름을 한눈에 알아보기 쉽고, 이해하기가 쉬워지는 것도 있다.

<aside>
☁️ `TCP/IP` : 범용적으로 사용하는 TCP 프로토콜과 IP 프로토콜을 OSI 7계층에 맞추어 추상화 시킨 모델이다.

</aside>

## 각 7 계층 특징

### Physical Layer

`데이터 전달`

- 이 계층은 주로 전기적, 기계적, 기능적인 특성을 이용해서 **물리적인 통신 케이블**로 데이터를 전송하는 계층이다.
- 이 계층에서 사용되는 통신 단위는 비트(0과 1로 이루어진)로, 데이터를 전달하는 것에만 집중한다.
    - 즉, 데이터가 무엇인지, 내가 받아야 하는 데이터가 무엇인지, 어떤 에러가 있는지에 대해서는 전혀 신경쓰지 않는다.
- 데이터를 전기적인 신호로 변환해서 주고 받는 기능을 하며, 이 계층에는 대표적으로 통신 케이블, 리피터, 허브 등이 있다.

### Data Link Layer

`에러검출`, `흐름제어`

- **물리 계층을 통해 송수신 되는 정보의 오류과 흐름을 관리하여 안전한 정보의 전달을 수행할 수 있도록 도와주는 역할을 한다.**
    - 즉, 통신에서의 오류를 찾고 재전송하는 기능을 수행하는 계층이다.
    - 포인트 투 포인트 간 신뢰성 있는 전송을 보장하기 위한 계층이다.
- 데이터링크 계층에서는 **맥 주소(물리주소)**를 가지고 통신한다.
    - 또, 이 계층에서 주고 받는 것을 **프레임**이라고 하고, 대표적인 장비로는 브릿지, 스위치 등이 있다.
    - 물리주소 : 해당 네트워크에 연결된 접속 장치의 주소

### Network Layer

`라우팅`, `흐름제어`, `오류제어`

- 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능을 가진다.
    - 이 계층의 주요 역할은 **라우팅**으로, 경로를 선택하고 주소를 정하고, 경로에 따라 패킷을 전달해준다.
        - 데이터를 연결하는 다른 네트워크를 통해 전달함으로써 인터넷이 가능하게 만드는 계층이다.
    - 이때에는 **IP 주소(논리주소)**를 사용한다.
        - 네트워크 관리자가 직접 주소를 할당하며, 계층적 구조를 가진다.
    - 라우팅, 흐름제어, 세그멘테이션, 오류 제어 등을 수행한다.

### Transport Layer

`흐름제어`, `오류제어`, `오류제어`, `혼잡제어`

- 통신을 활성화하기 위한 계층이다.
    - 보통 TCP 프로토콜을 이용하며, 포트를 열어서 응용 프로그램들이 전송을 할 수 있게 한다.
- 데이터가 왔다면 4계층에서 해당 데이터를 하나로 합쳐서 5계층으로 던져준다.
    - 메시지를 전송 가능한 세그먼트 단위로 캡슐화 하거나, 세그먼트를 다시 메시지로 재조립 하는 역할을 수행
    - 각 세그먼트도 순서번호를 가진다.
- 양 끝단의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록 해주어, 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다.
- 특정 연결의 유효성을 제어한다.
    - **패킷들의 전송이 유효한지 확인하고 전송 실패한 패킷들을 다시 전송한다는 것을 뜻한다.**

### Session Layer

`세션관리`

- 데이터가 통신하기 위한 논리적인 연결을 한다.
    - 목적지 주소를 붙인다.
    - 세션 계층은 네트워크 계층과 다르게 **응용 프로그램 관점에서 봐야 한다.**
        - 세션 설정, 유지, 종료, 전송 중단 시 복구 등의 기능을 가진다.
- 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다.
    - TCP/IP 세션을 만들고 없애는 책임을 진다.

### Presentation Layer

`데이터표현관리`

- 데이터 표현이 상이한 응용 프로세스의 독립성을 제공하고, 암호화 한다.
- 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 계층으로부터 덜어준다.
    - 인코딩, 암호화 등의 동작이 이 계층에서 이루어진다.

### Application Layer

`응용서비스`

- 최종 목적지로서, HTTP, FTP, Telnet 등과 같은 프로토콜이 있다.
- 통신 패킷들은 위의 프로토콜에 의해 모두 처리되며 우리가 사용하는 브라우저나 메일 프로그램 등은 보다 쉽게 프로토콜을 사용하게 해주는 응용 프로그램이다.
    - 즉, 모든 통신의 양 끝단은 HTTP 와 같은 프로토콜이지, 응용 프로그램이 아니다.
- 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.
</details>

---

<details>
    <summary><b>TCP/UDP</b></summary>

### TCP vs UDP

> TCP : 인터넷 상에서 데이터를 메시지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜
>
- TCP는 **연결형 서비스를 지원**하는 프로토콜로 인터넷 환경에서 기본으로 제공한다.
    - **패킷을 전송하기 위해 논리적 경로를 배정한다.**
    - **가상회선 패킷 교환 방식**을 사용한다.


- 높은 신뢰성을 보장하며, 흐름 제어 및 혼잡 제어를 담당한다.
    - 3-handshaking, 연결 지향형 서비스로 높은 신뢰성을 가지는 것이다.
    - 전송 순서를 보장한다.
        - 패킷에 부여한 번호를 통해 순서를 파악한다.
- 연결 지향형이기 때문에 UDP보다 속도가 느리다.
    - 데이터의 흐름 제어나 혼잡 제어와 같은 기능을 하는데, 이 기능들은 CPU를 사용하기 때문에 속도에 영향을 준다.
- 전이중, 점대점 방식이다.

즉, TCP는 연속성 보다는 신뢰성 있는 전송이 중요할 때에 사용하는 프로토콜이라고 할 수 있다.

> UDP : 데이터를 데이터그램 단위로 처리하는 프로토콜
>
- **데이터그램**이란 독립적인 관계를 지니는 패킷이라는 뜻으로, UDP의 빠른 속도가 가능하도록 한다.
- **비연결형 프로토콜**로, 연결을 위해 할당하는 논리적인 경로가 없다.
    - 각각의 패킷은 다른 경로로 전송되고, 전송된 패킷은 다른 경로로 독립적으로 처리하게 된다.
    - 각 패킷은 최적의 경로를 선택하여 간다.
    - 즉, 패킷의 순서가 다를 수 있다는 것!
- 정보를 주고 받을 때 정보를 보내거나 받는 신호 절차를 거치지 않는다.
- UDP 헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
- 신뢰성이 낮지만, TCP보다 속도가 빠르다.
    - 패킷을 순서에 맡게 재조립하거나, 패킷에 순서를 부여하는 과정이 없고, 흐름 제어 또는 혼잡 제어와 같은 기능도 없기 때문에 속도가 빠르다.
    - 네트워크 부하가 적다는 장점이 있지만 신뢰성이 낮은 것이 단점이다.

즉, UDP는 신뢰성보다는 연속성이 중요한 서비스, 예를 들면 실시간 서비스에 자주 사용된다.
</details>

<details>
    <summary><b>3way-handshake, 4way-handshake</b></summary>

- 3-way handshaking 과정을 통해 연결을 설정하고, 4-way handshaking 을 통해 해제한다.
    - `3-handshaking` : 목적지와 수신지를 확실히 하여 정확한 전송을 보장하기 위해 세션을 수립하는 과정


    ☁️ 3-handshaking
    1. SYN : 클라이언트는 ISN을 담아 SYN을 보낸다.
    *(ISN : 새로운 TCP연결의 첫번째 패킷에 할당된 임의의 시퀀스 번호, 초기 네트워크 할당을 위한 고유 시퀀스 번호)*

    2. SYN + ACK : 서버는 클라이언트의 SYN을 수신하고, 서버의 ISN을 보내며 승인번호로 클라이언트의 ISN + 1을 보낸다.

    3. ACK : 클라이언트는 서버의 ISN + 1 한 값인 승인번호를 담아 ACK를 서버에 보낸다.

  이 과정을 통해 신뢰성이 구축된다.


    ☁️ 4-handshaking
    1. 클라이언트가 연결을 닫으려고 할 때 FIN으로 설정된 세그먼트를 보낸다.
    그리고 클라이언트는 FIN_WAIT_1 상태로 들어가고 서버의 응답을 기다린다.

    2. 서버는 클라이언트로 ACK라는 승인 세그먼트를 보낸다. 그리고 해당 서버는 CLOSE_WAIT 상태에 들어간다. 그리고 클라이언트는 FIN_WAIT_2 상태에 들어간다.

    3. 서버는 ACK를 보내고 일정 시간 후에 클라이언트에 FIN이라는 세그먼트를 보낸다.

    4.  클라이언트는 TIME_WAIT 상태가 되고 다시 서버로 ACK를 보내서 서버는 CLOSED 상태가 된다.
        이후 클라이언트는 **어느 정도의 시간을 대기한 후** 연결이 닫히고 클라이언트와 서버의 모든 자원의 연결이 해제된다.

        ———————————————————————————————————————————-

        **왜 일정 시간을 기다리고 끝낼까?** 🤔
        
        → 첫번째는 `지연 패킷`이 발생할 경우를 대비하기 위함이다. 패킷이 뒤늦게 도달하고 이를 처리하지 못한다면 데이터 무결성 문제가 발생한다.

  두번째는 `두 장치가 연결이 닫혔는지 확인`하기 위함이다. 만약 서버가 끝내도 된다라고 보내는 상태에서 닫히게 되면 다시 새로운 연결을 하려고 할 때 서버의 상태가 줄곧 끝내도 된다는 상태이기 때문에 접속 오류가 나타나게 된다.

</details>

<details>
    <summary><b>흐름제어, 혼잡제어, 오류제어</b></summary>

`흐름제어`

- 데이터를 송신하는 곳과 수신하는 곳의 **데이터 처리 속도를 조절**하여 수신자의 버퍼 오버플로우를 방지하는 것.

`혼잡제어`

- 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것.

`오류제어`

- 전송시 오류나 분실한 프레임을 찾아 재전송
- 프레임 중복을 막기 위한 메커니즘도 사용한다.

`접근제어`

- 같은 링크에 다수 장치가 연결되어 있을 때, 주어진 순간에 링크를 사용하는 장치 결정
</details>

---

<details>
    <summary><b>HTTP</b></summary>

# HTTP

- HTTP란 서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜이다.

  → 수신자 측에 의해 요청이 초기화되는 프로토콜이다.

- 인터넷에서 하이퍼텍스트를 교환하기 위한 통신 규약으로 80번 포트를 기본 포트로 사용하고 있다.
  - 서버가 80번 포트에서 요청을 기다리고 있고, 클라이언트는 80번 포트로 요청을 보내게 된다.
- HTTP는 World-Wide-Web 기반에서 세계적인 정보를 공유하는데 큰 역할을 하였다.

## HTTP 구조

- HTTP는 애플리케이션 레벨의 프로토콜로, TCP/IP 위에서 작동한다.
- 상태를 가지지 않는 무상태(Stateless) 프로토콜이고, Method, Path, Version, Headers, Body 등으로 구성된다.
- 클라이언트가 요청(request)하면 서버가 응답(reponse) 하는 형태이다.
- HTTP는 평문 그대로를 담아 전달하기 때문에 보안 측면에서는 우수하지 않다.

### 클라언트와 서버를 분리한 이유?

- 클라이언트는 UI에 집중할 수 있고, 서버는 데이터를 다루는 데에만 집중할 수 있다.
  - 즉, 각 역할을 나누고 해당 역할에만 책임을 부여하여 독립적으로 고도화할 수 있게 하였다.

## HTTP 특징

### 무상태성(stateless)

- `무상태` : 클라이언트와 서버 사이에 **상태를 유지하지 않는다.**
  - 통신에 필요한 모든 상태 정보를 클라이언트가 가지고 있고, 서버와 통신하는 경우 데이터를 실어보낸다.
    - 서버의 관점에서는 단순히 데이터를 받아 응답만 해주면 되기 때문에 **상태 유지에 대한 부하가 감소한다.**
    - 상태 정보를 서버가 저장하지 않으므로 특정 서버에서 문제가 있을 경우 **다른 서버를 사용해서 다시 요청을 처리할 수 있다.**

      → 만약 상태가 있는 서버라면 해당 상태 값을 다른 서버는 모르기 때문에 대신 사용할 수 없음.

- 따라서 서버 확장(스케일아웃)이 용이하다는 장점이 따라오지만, 항상 클라이언트가 요청에 필요한 데이터를 담아 전달하기 때문에 메모리를 더 많이 사용하게 된다는 단점이 있다.
- 따라서 HTTP 통신은 데이터를 전송할 때마다 연결하고 바로 끊어버린다.


    🤔 HTTP 통신에서 상태를 유지할 수 있는 방법은 없을까?
    - 쿠키 : 브라우저에 저장하는 것을 말한다.
    - 세션 : 서버에 사용자 정보를 저장하는 것을 말한다.
    - 토큰 : 보호할 데이터를 토큰화하여 원본 데이터 대신 인증용으로 사용하는 것을 말한다.


### 비연결성(Connectionless)

- HTTP는 연결을 유지하지 않는다.
  - 이 특징 덕분에 서버 자원을 매우 효율적으로 사용할 수 있다.
- 연결이 유지되지 않기 때문에 연결을 위한 리소스가 줄게 되어 더 많은 요청을 처리할 수 있게 된다.
- 하지만 매번 요청마다 다시 연결을 새롭게 해야한다는 것이므로, 연결/해제에 대한 오버헤드가 발생한다는 단점도 있다.
- HTTP는 해당 문제를 해결하기 위해 `HTTP 지속 연결(KeepAlive)`이라는 것을 통해 해결하고자 한다.
  - 소켓 연결을 일정 시간 동안 더 유지함으로써, 필요한 자원들을 모두 다운받을때까지 연결이 종료되지 않고, 요청/응답이 반복된 뒤 종료된다.
</details>

<details>
    <summary><b>HTTP status code</b></summary>

## HTTP 상태코드

- 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능을 한다.
- 100 ~ 500번대 숫자로 이루어져 있다.
- `1XX` (정보) : 서버가 요청을 수신했으며, 계속 처리 중임을 나타내는 **중간 응답**이다.
- `2XX` (성공) : 클라이언트의 요청이 성공했음을 나타낸다.
- `3XX`(리디렉션) : 클라이언트가 요청을 완료하기 위해 **리디렉션과 같은 추가 작업을 수행해야 함**을 나타낸다.
- `4XX` (클라이언트 오류) : 누락되거나 잘못된 매개변수와 같은 클라이언트 요청으로 오류가 있음을 나타낸다.
- `5XX` (서버 오류) : 요청을 처리하는 동안 서버 측에서 오류가 발생했음을 나타낸다.
</details>

<details>
    <summary><b>HTTP METHOD</b></summary>

## HTTP 메서드

- 서버에 주어진 리소스에 수행하길 원하는 행동, 서버가 수행해야 할 동작을 지정하는 요청을 보내는 방법에 해당한다.
- 주요 메소드
  - `GET` : 리소스 조회
    - 정적 자원을 조회할 수 있고, 동적 자원도 조회할 수 있다.
      - 동적 자원은 쿼리 파라미터, Path 파라미터 등을 활용하며 조회할 수 있다.
  - `POST` : 요청 데이터 처리, 주로 등록에 사용한다.
    - 메시지 바디에 요청에 필요한 데이터를 전달하면 서버가 해당 바디의 데이터를 처리하여 업데이트한다.
    - 주로 전달된 데이터로 신규 리소스를 등록하거나 프로세스를 처리하는데에 사용한다.
  - `PUT` : 리소스를 대체(덮어쓰기), 해당 리소스가 없으면 생성한다.
    - 리소스를 대체(수정)하는 메소드
    - 있으면 수정하고, 없으면 새로 생성한다.
  - `PATCH` : 리소스 부분 변경
    - 리소스 일부 부분을 변경하는 메소드
  - `DELETE` : 리소스 삭제
- 기타 메소드
  - HEAD : GET과 동일하지만 메시지 부분(Body)을 제외하고, 상태 줄과 헤더만 반환
    - 리소스를 받지 않고 찾는 것만 원하는 경우, 즉 상태 코드만 확인하고 싶은 경우 사용할 수 있다.
  - OPTIONS : 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명(주로 CORS에서 사용)
    - 본 요청을 하기 전에 안전한지 미리 검사하는 것으로, 서버의 지원 가능한 HTTP 메서드와 출처를 응답 받아 CORS 정책을 검사하기 위해 사용한다.
  - CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정
  - TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행
    - 일종의 검사용으로 서버에 도달 했을 때 최종 패킷의 요청 패킷 내용을 받을 수 있어, 요청했던 패킷 내용과 응답 받은 패킷 내용을 비교하여 변조 유무를 확인할 수 있다.



    ☁️ HTML Form은 GET과 POST만 가능하다.
    HTML Form을 통해 전송된 데이터는 쿼리 파라미터로 전달된다.

--

    ☁️ PUT vs PATCH
    PUT 메소드는 요청한 URI에 담긴 페이로드의 자원으로 대체하는 메서드라고 설명한다. 여기서 대체한다는 의미는 자원을 변경하기도 하는 것이고, 새로운 자원으로 교체한다는 뜻도 있다.

    1. 만약 요청한 URI 아래에 자원이 존재하지 않는다면
    자원이 존재하지 않으면 앞서 말한 것처럼 새로운 자원으로 저장한다.

    2. 요청한 URI 아래에 자원이 존재한다면
    페이로드에 담긴 정보를 이용하여 새로운 자원을 만들어 기존에 존재하던 자원을 대체한다.
    —————————————————————————————————————————————-
     PATCH 메소드는 요청한 자원에 대한 부분적인 수정을 적용하기 위한 메서드로, **PUT 메서드를 사용하는 클라이언트는 해당 자원의 상태를 모두 알고 있다고 가정되어야 한다**는 주의점이 있다.

    즉, PUT 메서드를 통해 전달된 페이로드만으로도 자원의 전체 상태를 나타낼 수 있어야 한다는 것이다.
    PUT 메서드를 통해 전달되는 페이로드는 새로운 자원으로 대체될 수 있기 때문에 반드시 완전한 상태를 가져야 하고, 만약 그렇지 않으면 null 값을 가진 빈 필드가 존재할 수 있게 된다.

    하지만 PATCH 메소드는 그렇지 않기 때문에 부분적인 수정으로 사용할 수 있는 것이다.
    이 부분은 `멱등성`에서 더욱 드러난다.


### 멱등성

- **여러 번 동일한 요청을 보냈을 때 서버에 미치는 의도된 영향이 동일한 경우**, 멱등성이 있다고 말한다.
- SAFE 요청들(GET, HEAD 등)에 더해 PUT, DELETE 가 멱등한 메소드이다.
- 멱등성은 왜 필요할까? 🤔
  - `요청의 재시도` 때문이다.
  - HTTP 요청이 멱등하다면 요청이 실패한 경우 재요청을 보내도 의도한 결과가 동일하기 때문에 안전하다. 하지만 멱등하지 않다면 의도한 결과가 아닌 예상치 못한 결과를 초래할 수 있다.
  - 따라서, 클라이언트는 멱등성을 고려하여 재시도 요청을 시도해야 한다.
- **POST와 PATCH 메서드는 멱등하지 않은 메서드이다.**
  - POST는 새로운 리소스를 계속해서 생성하기 때문에 동일한 요청을 여러번 보내면 동일한 리소스가 여러 개 생길 수 있기 때문이다.
  - PATCH는 메서드 자체가 멱등이면서 멱등이지 않게 설계할 수 있기 때문이다.
    - 예를 들어, 단순히 리소스를 수정하도록 구현되어 있다면 멱등성을 가질 수 있지만, 해당 요청에 의해 값이 일정하게 증가하도록 하거나, 요청에 의존하여 값이 변경된다면 해당 요청은 멱등성을 가지지 않는다.
- **DELETE 메서드가 멱등한 메서드인 이유는?**
  - DELETE 요청을 처음에 보내면 해당 리소스는 성공적으로 삭제될 것이다. 그 이후 동일한 요청을 보냈을 때 리소스가 존재하지 않기 때문에 DELETE 요청은 처리되지 않고 404 NOT FOUND를 반환할 것이다. 따라서, 의도한 결과가 그대로 유지되기 때문에 멱등하다고 한다.
</details>

<details>
    <summary><b>HTTP 1.1 VS HTTP 2.0</b></summary>

## HTTP 1.1 vs HTTP 2.0

### HTTP 1.1

- 현재 가장 많이 사용하는 버전이며, **기본적으로 커넥션 하나당 하나의 요청을 처리하도록 설계되어 있다.**
  - 그렇기 때문에 동시 전송 문제와 다수의 리소스를 처리하기에 속도와 성능 이슈를 가지고 있다.
  - 이로 인해 HTTP 1.1이 가진 문제는 다음과 같다.
    - `Head Of Line Blocking`(특정 응답 지연) : 우선 처리 요청의 응답이 지연되어 다음 요청이 무한 대기 상태가 된다.
    - `Round Trip Time` 증가 : 하나의 커넥션에 하나의 요청을 처리하기 때문에 요청별로 커넥션이 생성되며, 이로 인해 3-way handshake가 반복적으로 일어나게 되어 불필요한 Round Trip Time이 증가하게 되어 네트워크 지연을 초래하는 것.
    - `헤비한 헤더 구조` : 매 요청마다 중복된 헤더값을 전송하게 되어 헤더 값이 크다.
- HTTP 1.1에 추가된 기능은 다음과 같다.
  - `Persistent connection` (지속 연결)
  - `Pipelining` : 하나의 커넥션에서 응답을 기다리지 않고 순차적인 여러 요청을 연속적으로 보내 그 순서에 맞춰 응답을 받는 방식으로 지연 시간을 줄인다.
    - 하지만 Head Of Line Blocking과 같이 문제점이 많아 없어졌다.
- 우리가 대부분 이용하는 기능은 HTTP 1.1에 만들어진 것이며 2는 성능 개선에 초점을 맞추었다.

### HTTP 2.0

- HTTP 1.1을 해결하고자 등장하였으며, HTTP 2.0은 성능 뿐만 아니라 속도 면에서도 1.1 보다 월등했다.
- `Multiplexed Streams`
  - 한 커넥션에 여러 개의 메시지를 동시에 주고 받을 수 있다.
- `Stream Prioritization`
  - 요청 리소스간의 의존관계(우선순위)를 설정할 수 있다.
  - 리소스 간의 우선순위를 정해 더 빠르게 처리할 수 있는 요청을 먼저 처리하도록 할 수 있어 지연을 방지할 수 있다.
- `Server Push`
  - HTML 문서 상에 필요한 리소스를 클라이언트 요청 없이 보낼 수 있다.
- `Header Compression`
  - Header 정보를 HPACK 압축방식을 이용하여 압축 후 전송한다.
</details>

<details>
    <summary><b>HTTPS</b></summary>

# HTTPS

<aside>
☁️ HyperText Transfer Protocol over Secure Socket Layer

</aside>

- **HTTP의 보안적 약점을 보완한 프로토콜이다.**
- TCP 연결이 이루어진 후 TLS를 통해 암호화 설정이 되고 통신을 하는 방식으로 이루어진다.
- HTTPS는 기본 TCP/IP 포트로 443번 포트를 사용한다.
- 소켓 통신에서 일반 텍스트를 이용하는 대신에, 웹 상에서 정보를 암호화하는 **`SSL`이나 `TLS 프로토콜`을 통해 세션 데이터를 암호화한다.**
  - SSL, TLS 모두 기밀성, 데이터 무결성, ID 및 디지털 인증서를 사용한 인증을 제공하는 것이다.
  - 이를 통해 데이터의 적절한 보호를 보장한다.
  - 보호의 수준은 웹 브라우저에서의 구현 정확도와 서버 소프트웨어, 지원하는 암호화 알고리즘에 달려있다.

## SSL과 TLS

- SSL 인증서는 사용자가 사이트에서 제공하는 정보를 암호화한다.
- TLS 안에 SSL이 속한다.

### 인증서의 장점

- 암호화되어 전송되는 데이터는 중간에 누가 훔치거나 조작하려해도 암호화되어 있어 해독할 수 없다.
- 클라이언트가 접속하려는 서버가 신뢰할 수 있는 서버인지 확인할 수 있다.
  - 자신이 가진 공개키로 해독이 가능하다면 자신이 요청한 서버가 연결되는 비밀키로 암호화했다는 것이 보장되기 때문에
- SSL 통신에 사용할 공개키를 클라이언트에게 제공한다.

## HTTPS 의 원리

- 공개키 알고리즘 방식을 사용한다.
  - 암호화, 복호화할 수 있는 서로 다른 키를 이용한 암호화 방식을 사용하는 것.
  - **공개키로 암호화 하면 개인키로만 복호화 할 수 있다.** = 개인키는 소유한 사람만 가지므로 소유한 사람만 볼 수 있다.
  - **개인키로 암호화 하면 공개키로만 복호화할 수 있다.** = 공개키는 모두 공개되어 있으므로 인증된 정보임을 알려 신뢰성을 보장할 수 있다.
- 공개키 알고리즘 방식은 대칭키에 비해 느리다.
  - 그래서 **실제 전송되는 데이터의 암호화에는 대칭키 암호화 방식**을 사용하고 **키 교환에 공개키 암호화를 사용**하여 속도를 해결하고 있다.
  - HTTPS 연결 과정에서 서버와 클라이언트는 세션키를 교환한다.
    - 세션키 : 데이터를 암호화하기 위해 사용되는 대칭키
    - 세션키를 주고받기 위해 공개키(비대칭키) 방식을 사용한다.

## HTTPS의 동작 과정

1. 클라이언트가 서버로 최초 연결을 시도한다.
2. 서버는 공개키(인증서)를 클라이언트에게 넘겨준다.
3. 클라이언트는 인증서의 유효성을 검사하고 세션키를 발급한다.
4. 클라이언트는 세션키를 보관하고 추가로 서버의 공개키로 세션키를 암호화하여 서버로 전송한다.
5. 서버는 개인키로 세션키를 복호화하여 세션키를 얻고, 클라이언트와 동일한 세션키를 가지게 되어 데이터 전달이 가능해진다.
</details>

---

<details>
    <summary><b>REST API</b></summary>

# REST

    ✏️ Representational State Transfer


- 자원을 이름(자원의 표현)으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것.
- REST는 기본적으로 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 웹의 장점을 최대한 활용할 수 있는 아키텍쳐 스타일이다.
  - 네트워크 상에서 Client와 Server 사이의 통신 방식 중 하나이다.
- 자원의 표현으로 자원의 상태를 전달한다.
  - 자원 : 해당 소프트웨어가 관리하는 모든 것
  - 자원의 표현 : 그 자원을 표현하기 위한 이름
  - 데이터가 요청되어지는 시점에서 자원의 상태(정보)를 전달한다.
- 즉, HTTP URI를 통해 자원을 명시하고 HTTP 메소드를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다.

> *REST는 자원 기반의 구조 설계의 중심에 Resource가 있고 HTTP 메소드를 통해 리소스를 처리하도록 설계된 아키텍쳐를 의미한다. 이미지, 텍스트, DB 내용 등의 모든 자원에 대해 고유한 ID를 부여하고 그것을 HTTP URI에 부여한다.*
>

## REST 아키텍쳐가 필요한 이유는?

- 애플리케이션 분리 및 통합이 가능해진다.
- 다양한 클라이언트를 도입할 수 있다.
  - 최근 서버 프로그램은 다양한 브라우저와 안드로이드, IOS와 같은 모바일에도 통신이 가능해야 한다.
  - 멀티 플랫폼에 대한 지원을 위해 서비스 자원에 대한 아키텍쳐를 세우고 이용한 방법을 모색한 결과가 REST이다.


### REST 아키텍쳐의 장점

- HTTP 프로토콜의 인프라를 그대로 사용하므로 REST API 사용을 위한 별도의 인프라를 구축할 필요가 없다.
  - HTTP 프로토콜의 사용으로 HTTP를 사용하는 모든 플랫폼에서 사용이 가능하다.
- REST API 메시지가 의도하는 바를 명확하게 나타내므로 의도하는 바를 쉽게 파악할 수 있다.
- 서버와 클라이언트의 역할을 명확하게 분리한다.

### REST 아키텍쳐의 단점

- HTTP 메소드 형태가 제한적이다.
- 구형 브라우저가 아직 제대로 지원해주지 못하는 부분이 존재한다.

## REST 구성 요소

- 자원(Resource)
  - 모든 자원에 고유한 ID가 존재하고 이 자원은 서버에 존재한다.
  - 자원을 구별하는 고유한 ID가 있으며, 그 ID는 HTTP URI이다.
  - 클라이언트는 URI를 이용하여 특정 자원을 지정하고 해당 자원의 상태(정보)에 대한 조작을 서버에 요청한다.
- 행위(Verb)
  - HTTP 프로토콜의 메소드를 사용한다.
  - HTTP 프로토콜은 GET, POST, PUT, DELETE와 같은 메서드를 제공한다.
- 표현(Representation of Resource)
  - 클라이언트가 자원의 상태(정보)에 대한 조작을 요청하면 서버는 이에 적절한 응답을 보낸다.
  - REST에서 하나의 자원은 JSON, XML, TEXT, RSS 등 여러 형태의 표현으로 나타내어질 수 있다.
  - JSON 혹은 XML을 통해 데이터를 주고 받는 것이 일반적이다.


## REST 특징

### 서버-클라이언트 구조

- 자원이 있는 쪽이 서버, 자원을 요청하는 쪽이 클라이언트이다.
  - REST 서버 : API를 제공하고 비즈니스 로직 처리 및 저장을 책임진다.
  - 클라이언트 : 사용자 인증이나 context(세션, 로그인 정보) 등을 직접 관리하고 책임진다.
- 서로 간 의존성이 줄어든다.

### 무상태

- HTTP 프로토콜은 무상태 프로토콜이므로 REST 역시 무상태성을 갖는다.
- 클라이언트의 context를 서버에 저장하지 않난다.
  - 세션과 크키와 같은 context 정보를 신경쓰지 않아도 되므로 구현이 단순해진다.
- 서버는 각각의 요청을 완전히 별개의 것으로 인식하고 처리한다.
  - 각 API 서버는 클라이언트의 요청만을 단순 처리한다.
  - 이전의 요청이 다음의 요청에 연관되지 않고 독립적이다.
  - 서버 처리 방식에 일관성을 부여하고 부담이 줄어들며, 서비스의 자유도가 높아진다.

### 캐시 처리 가능

- 웹 표준 HTTP 프로토콜을 그대로 사용하므로 웹에서 사용하는 기존의 인프라를 그대로 활용할 수 있다.
  - HTTP 가 가진 기능 중 캐싱 기능을 적용할 수 있다.
- 대량의 요청을 효율적으로 처리할 수 있다.
- 캐시 사용을 통해 응답 시간이 빨라지고, REST 서버 트랜잭션이 발생하지 않기 때문에 전체 응답시간, 성능, 서버의 자원 이용룰을 향상시킬 수 있다.

### 계층화

- 클라이언트는 REST API 서버만 호출한다.
- REST 서버는 다중 계층으로 구성될 수 있다.
  - 순수 비즈니스 로직을 수행하고 그 앞단에 보안, 로드밸런싱, 암호화, 사용자 인증 등을 추가하여 구조 상의 유연성을 줄 수 있다.
- 프록시 게이트웨이 같은 네트워크 기반의 중간 매체를 사용할 수 있다.

### 인터페이스 일관성

- URI로 지정한 리소스에 대한 조작이 통일되고 한정적인 인터페이스로 수행한다.
- HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하며, 특정 언어나 기술에 종속되지 않는다.

# REST API

## API란

- 정의 및 프로토콜 집합을 사용하여 두 소프트웨어 구성 요소가 서로 통신할 수 있게 하는 메커니즘이다.
- 요청과 응답을 사용하여 두 애플리케이션이 서로 통신하는 방법을 정의한 것이라고 할 수 있다.
  - 개발자가 요청과 응답을 구성하는 방법에 대한 정보가 담겨있다.

## REST API란

- REST 기반으로 서비스 API를 구현한 것을 말한다.
- 최근 OPEN API, 마이크로 서비스 등을 제공하는 업체 대부분은 REST API를 제공한다.
- 시스템을 분산해 확장성과 재사용성을 높여 유지보수 및 운용을 편리하게 할 수 있다.

## REST API 설계 기본 규칙

### ⚖️ URI는 정보의 자원을 표현해야 한다.

- 자원은 동사보다는 `명사`를, 대문자보다는 `소문자`를 사용해야한다.
- 자원의 하나에 대한 이름으로는 단수 명사를 사용해야 한다.
- 자원의 모음에 대한 이름으로는 복수 명사를 사용해야 한다.
- 클라이언트에서 사용하는 자원 저장소 이름으로는 복수 명사를 사용해야 한다.

### ⚖️ 자원에 대한 행위는 HTTP Method로 표현한다.

- HTTP URI에 HTTP Method가 들어가면 안된다.
- URI에 행위에 대한 동사 표현이 들어가면 안된다.
- 경로 부분 중 변하는 부분은 `유일한 값`으로 대체한다.

### ⚖️ 슬래시 구분자는 계층 관계를 나타내는데 사용한다.

- URI 마지막 문자로 슬래스(/)를 포함하지 않는다.
  - 혼동을 주지 않기 위해 URI 경로의 마지막에는 슬래시(/)를 사용하지 않는다.
- URI에 포함되는 모든 글자는 리소스의 유일한 식별자로 사용되어야 하며, URI가 다르다는 것은 리소스가 다르다는 것이다.

### ⚖️ 하이픈은 가독성을 위해 사용하며, 밑줄은 사용하지 않는다.

- 하이픈(-)은 불가피하게 긴 URI 경로를 사용하게 된 경우에 가독성을 위해 사용한다.
- 밑줄은 보기 어렵거나 밑줄 때문에 문자가 가려지기도 하기 때문에 가독성을 위해 사용하지 않는다.

### ⚖️ 파일 확장자는 URI에 포함하지 않는다.

- REST API에서는 메시지 바디 내용의 포맷을 나타내기 위한 파일 확장자를 URI안에 포함시키지 않는다.
  - Accept Header를 사용하여 파일 확장자를 나타낸다.

## RESTful

- 일반적으로 REST라는 아키텍쳐를 구현하는 웹 서비스를 나타내기 위해 사용되는 용어이다.
- REST API를 제공하는 웹 서비스를 RESTful 하다고 할 수 있다.
- 이해하기 쉽고 사용하기 쉬운 REST API를 만드는 것이 목적이며, 성능 향상에 궁극적인 목표가 있는 것은 아니다.
</details>

---

<details>
    <summary><b>COOKIE & SESSION</b></summary>
</details>

---

<details>
    <summary><b>JWT</b></summary>

## 왜 토큰 기반의 인증을 더 사용할까?

### 쿠키

- 보안에 취약하다.
  - 요청시 쿠키의 값을 그대로 보내기 때문에 유출 및 조작 당할 위험이 존재한다.
- 쿠키에는 용량 제한이 있어 많은 정보를 담을 수 없다.
- 웹 브라우저마다 쿠키에 대한 지원 형태가 다르기 때문에 브라우저 간 공유가 불가능하다.
- 쿠키의 사이즈가 커질수록 네트워크에 부하가 심해진다.

### 세션

- 세션 ID 자체에는 유의미한 개인정보를 담고 있지 않아 노출되어도 상관없지만, 해커가 ID 자체를 탈취하여 클라이언트인척 위장할 수 있다는 한계가 존재한다.
  - 세션 ID를 서버에 저장해놔야 하기 때문에 Stateless를 위배한다. 즉, 클라이언트의 인증 상태를 저장해두는 것이기 때문에 stateful 하다.
- 서버에서 세션 저장소를 사용하기 때문에 요청이 많아지면 서버에 부하가 심해진다.
  - 데이터베이스에 세션 정보를 가지고 있어 이를 조회하는 과정이 필요하기 때문에 많은 오버헤드가 발생한다.

### 토큰 기반

- 클라이언트에 토큰이 저장되기 때문에 서버의 부담을 덜 수 있다.
- 토큰 자체에 데이터가 들어있기 때문에 클라이언트에게 받은 후에 위조되었는지 판별이 가능하다.
- 웹 뿐만 아니라 앱 환경에서도 사용가능하다.

**토큰 사용 방식의 단점**

- 쿠키/세션과 다르게 토큰 자체의 데이터 길이가 길어, 인증 요청이 많아질수록 네트워크 부하가 심해질 수 있다.
- Payload 자체는 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 없다.
- 토큰을 탈취당하면 대처하기가 어렵다.
  - 따라서 사용 기간을 제한하는 식으로 극복하고 있다.

# JWT

<aside>
☁️ JSON Web Token

</aside>

- 인증에 필요한 정보들을 암호화시킨 JSON 토큰
- HTTP 헤더에 토큰을 실어 서버가 클라이언트를 식별하는 방식이다.
- JSON 데이터를 Base64 URL-safe Encode를 통해 인코딩하여 직렬화한 것이며, 토큰 내부에 위변조 방지를 위해 개인키를 통한 전자서명도 들어있다.
- 사용자가 JWT를 헤더에 담은 요청을 보내면 서버는 해당 토큰의 서명을 검증하는 과정을 통해 인증이 완료된다.
- 어찌됐든 JWT는 흔히 사용할 수 있는 인코딩 알고리즘을 사용하고 있기 때문에 해당 서버가 아니더라도 그 값들을 확인할 수 있다.
  - 따라서, payload에는 단순히 식별을 하기 위한 정보만을 담아두어야 한다.

> *payload의 내용이 디코드되어 확인될 수 있어도 상관 없도록 비민감정보이면서 식별할 수 있는 값이여야 하고, 해당 토큰이 유효한지 서버에서 반드시 확인하여, 이것이 믿을만한 정보인지 확인해야 한다. 토큰이 노출되어도 전자 서명은 비밀키가 유출되지 않았다면 복호화가 불가능하기 때문이다. 즉, 토큰의 진짜 목적은 정보보호가 아닌 위조 방지이다.*
>

## JWT 구조

![jwt.jpeg](image/jwt.jpeg)

- JWT는 `.`을 구분자로 세가지 구성으로 되어있다.
- `Header` : JWT에서 사용할 타입과 해시 알고리즘의 종류가 담겨있다.
- `Payload` : 서버에서 첨부한 사용자 권한 정보와 데이터가 담겨있다.
- `Signature` : Header, Payload를 Base64 URL-safe Encode를 한 후 Header에 명시된 해시 함수를 적용하고, 개인키로 서명한 전자 서명이 담겨있다.

## JWT를 이용한 인증과정

1. 사용자가 ID, PW를 입력하여 서버에 로그인 인증을 요청한다.
2. 서버에서 클라이언트로부터 인증 요청을 받으면 Header, PayLoad, Signature를 정의한다. Header, PayLoad, Signature 를 각각 Base64로 한번 더 암호화하여 JWT를 생성하고 이를 쿠키에 담아 클라이언트에게 발급한다.
3. 클라이언트는 서버로부터 받은 JWT를 로컬 스토리지에 저장한다. (다른 곳에 저장할 수도 있음) 이제 API를 서버에 요청할 때 Authorization 헤더에 Access Token을 담아서 보낸다.
4. 서버는 클라이언트가 헤더에 담은 토큰을 꺼내 해당 서버가 발행한 토큰인지 일치 여부를 확인하고, 확실한 것이라면 인증을 통과시키고, 아니면 인증되지 않은 사용자라고 판단하여 통과시키지 않는다.
5. 클라이언트가 서버에 요청을 했는데, 해당 토큰의 유효시간이 만료되면 클라이언트는 **Refresh Token**을 이용하여 서버로부터 새로운 Access Token을 발급받는다.

## Refresh Token

- 토큰을 탈취당하면 아주 위험하며, 대처할 수 있는 방법이 없기 때문에 보통 토큰의 유효시간을 아주 짧게 두어 혹시라도 모를 탈취를 통한 위험을 방지한다.
- 하지만 유효시간이 짧으면 사용자가 서비스에 계속 머무르는 동안 아주 잦은 시간마다 인증을 새롭게 해야한다는 불편함이 존재하게 된다.
- 그래서 이것을 Refresh Token을 사용하여 이중으로 나누어 인증을 하는 방식으로 사용한다.
- 모두 똑같은 토큰이지만, Refresh Token은 새로운 Access Token을 발급하기 위한 토큰으로 짧은 수명을 가지는 Access Token에게 새로운 토큰을 발급해주기 위해 사용한다.
  - 해당 토큰은 보통 데이터베이스에 유저 정보와 같이 기록되어 있다.

> Access Token을 재발급에 관여하는 토큰의 역할을 한다.
>

- Refresh Token은 긴 유효시간을 가지면서, Access Token이 만료되었을 때 새로 재발급해주는 열쇠가 된다.
- 만료된 Access Token을 서버에 보내면 서버는 같이 보내진 Refresh Token을 DB에 있는 것과 비교해서 일치하면 다시 Access Token을 재발급하는 간단한 원리를 가진다.
- 사용자가 로그아웃 하면 저장소에서 Refresh Token을 삭제하여 사용이 불가능하도록 하고, 새로 로그인하면 서버에서 다시 재발급해서 DB에 저장한다.
</details>

---

<details>
    <summary><b>CORS</b></summary>


    ✏️ Cross-Origin Resource Sharing


- **교차 출처 리소스 공유 정책**이라고 한다.

## SOP, Same Origin Policy

동일한 출처에 대한 정책으로, 동일한 출처에서만 리소스를 공유할 수 있도록 하는 것이다. 동일 출처 서버에 있는 리소스는 자유롭게 가져올 수 있지만, 다른 출처 서버에 있는 이미지나 유튜브 영상 같은 리소스는 상호작용이 불가능하다.

### SOP 정책이 필요한 이유는?

출처가 다른 두 어플리케이션이 자유롭게 소통할 수 있는 환경은 사실 꽤 위험한 환경이다. CSRF(Cross-Site Request Forgery)나 XSS(Cross-Site Scripting) 등의 방법을 이용해서 자신의 어플리케이션에 해커가 심어놓은 코드가 실행되어 개인 정보를 가로 챌 수 있기 때문이다.

따라서, 이런 악의적인 경우를 방지하기 위해 동일 출처 정책으로 **다른 출처의 스크립트가 실행되지 않도록** 사전에 브라우저에서 방지하도록 하는 것이 목표이다.

# COSR란

Cross Origin Resource Sharing의 약자로 브라우저의 현재 웹 페이지가 이 페이지를 받은 서버가 아닌 다른 서버의 자원을 호출하는 것을 의미한다. 웹 브라우저에서 **외부 도메인 서버와 통신할 때 허락을 구하고 거절하기 위해 HTTP-header를 이용하는 메커니즘을 CORS라고 한다.**

CORS 정책은 서버에 저장되어 있고 서버가 클라이언트를 대상으로 리소스의 허용 여부를 결정하기 때문에 저장된 CORS 정책(허용하고자 하는 URL 정보)을 브라우저에서 보내주는 일을 서버가 담당하게 된다. 하지만 정작 CORS 정책을 받아서 **검증하는 것은 브라우저가 한다.**

정리하면, 브라우저는 HTTP 요청을 할 때 CORS 검증을 해야하는 상황인지 판단하고 서버에게 응답 받은 CORS 검증 요청 결과에 따라 해당 http 요청을 처리하거나, 취소시키고 에러를 반환한다.

## Origin, 출처란?

URL 구조에서의 `Protocol`, `Host`, `Port`를 합친 것을 말한다.

즉, cross origin → **다음 중에 하나라도 다른 경우**에 cross origin 오류가 발생하는 것이다.

- 프로토콜 : http에서 https로 요청하는 경우
- 도메인 : domain1.com 에서 domain2.com 으로 요청하는 경우
- 포트 번호 : 8080번 포트에서 3000번 포트로 요청하는 경우

### Cross Origin Policy를 사용하는 이유

- 클라이언트와 서버의 도메인을 따로 유지하는 경우 필요하다.
- 외부 API를 연동하여 사용하면 App과 외부 API의 origin이 달라 자원 공유가 불가능한 상황이 발생한다.
- origin을 cross 할 수 있게 하여 서로 다른 도메인, 포트 등을 공유할 수 있도록 하면서, 허용하는 origin을 설정하여 보안 문제들을 예방할 수 있게 된다.

## CORS 동작 방식

1. 브라우저에서 HTTP Header에 **Origin 속성에 요청을 보내는 Origin을 담아 서버에게 요청을 보낸다.**

    ```
    Origin: https://example.com
    ```

2. 서버가 이 요청에 대한 응답을 할 때, 응답 Header의 Accress-control-Allow-Origin에 `리소스를 접근하는 것이 허용된 Origin`을 담아 브라우저에게 응답을 보낸다.
3. 응답을 받은 브라우저는 자신이 보냈던 요청의 Origin과 버서가 보내준 응답의 Accress-Control-Allow-Origin을 비교한다.
4. 두 개가 동일하다면 유용한 응답이라 판단한다.

## CORS 작동 방식 3가지 경우

실제로 CORS가 동작하는 방식은 한가지가 아니라 세 가지의 경우에 따라 변경되기 때문에, 모두 알아놔야 한다.

### 예비 요청(Preflight Request)

브라우저는 요청을 보낼 때 한번에 바로 보내지 않고, 먼저 예비 요청을 보내 서버와 잘 통신되는지를 먼저 확인한 후 본 요청을 보낸다.

즉, 예비 요청은 본 요청을 보내기 전에 브라우저 스스로 안전한 요청인지 미리 확인하는 것이다. 이때 예비 요청을 보내는 것을 Preflight라고 부르며, 이 예비요청의 HTTP 메소드를 GET이나 POST가 아닌 **OPTIONS**라는 요청이 사용된다는 것이 특징이다.

### 단순 요청

예비 요청을 생략하고 바로 서버에 직행으로 본 요청을 보낸 후, 서버가 이에 대한 응답의 헤더에 Access-Control-Allow-Origin 헤더를 보내주면 브라우저가 CORS 정책 위반 여부를 검사하는 방식이다.

아래 **3가지 경우를 만족할 때**에만 예비 요청을 생략할 수 있다.

- 요청의 메소드는 GET, HEAD, POST 중 하나여야 한다.
- `Accep`, `Accep-Language`, `Content-Language`, `Content-Type`, `DPR`, `Downlink`, `Save-Data`, `Viewpost-Width`, `Width` 헤더일 경우에만 적용된다.
- Content-Type 헤더가 application/x-www-form-urlencoded, multipart/form-data, text/plain 중 하나여야 한다. 아닐 경우 예비 요청으로 동작된다.

다소 까다롭기 때문에 위 조건을 모두 만족하여 단순 요청이 일어나는 상황은 드물다. 그렇기 때문에 대부분의 API 요청은 그냥 예비 요청으로 이루어진다라고 이해하면 된다.

### 인증된 요청

클라이언트에서 서버에서 자격 인증 정보를 실어 요청할 때 인증된 요청이라고 하며, 여기서 자격 인증 정보란 세션 ID가 저장되어 있는 쿠키 혹은 Authorization 헤더에 설정하는 토큰 값 등을 일컫는다.

즉, 클라이언트에서 일반적인 JSON 데이터 이외에도 쿠키 같은 인증 정보를 포함하여 다른 출처의 서버로 전달할 때 CORS의 세가지 요청 중 하나인 인증된 요청으로 동작한다는 것이다. **기존의 단순 요청이나 예비 요청과는 살짝 다른 인증 형태를 가지고 통신한다.**

기본적으로 브라우저가 제공하는 요청 API들은 별도의 옵션 없이는 브라우저의 쿠키와 같은 인증과 관련된 데이터를 함부로 요청 데이터에 담지 않도록 되어있다. 이때 요청에 인증과 관련된 정보를 담을 수 있게 해주는 옵션이 바로 `credentials` 이다. 이렇게 별도로 설정해주지 않으면 쿠키 등의 인증 정보는 절대로 자동으로 서버에게 전송되지 않는다.

서버도 마찬가지로 이러한 인증된 요청에 대해 일반적인 CORS 요청과는 다르게 대응한다. 응답 헤더의 credentials 항목을 true로 설정하고 절대 헤더 값에 와일드카드를 사용할 수 없다. 즉, 분명한 URL 값으로 설정되어야 한다는 뜻이다.

만약 둘 중에 하나라도 어길 경우 CORS가 허용되지 않고 오류가 발생하게 된다.

## Default

CORS를 설정하면 다음과 같은 기본값으로 설정이 된다.

- Allow all origins
- Allow “simple” methods GET, HEAD and POST
- Allow all headers
- Set max age to 1800 seconds = 30 minutes

# Spring에서 해결하기

## Configuration으로 해결하기

이 방법을 사용하면 Global하게 적용할 수 있습니다. 바로 WebConfig를 설정해주는 방식입니다.

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
	
	@Override
	public void addCorsMappings(CorsRegistry registry) {
		registry.addMapping("/**")
						.allowedOrigins("*")
						.allowMethods("GET", "POST")
						.maxAge(3000);
	}
}
```

### addMapping

CORS를 적용할 URL 패턴을 지정하는 것이다.

`/*` 을 사용하여 와일드카드로 지정할 수도 있고, 자세한 URL을 매핑할 수도 있다.

### allowedOrigins

메소드를 이용해서 자원 공유를 허락할 Origin을 지정할 수 있다.


    💡 Origin = Protocol +Host + Port


cross origin은 위의 세가지 중 하나만 달라도 발생하며 위에서 처럼 `*` 로 지정하게 된 경우 모든 프로토콜, 모든 호스트, 모든 포트에 대해 허용하는 것이 된다.

### allowedMethods

허용할 HTTP method를 지정할 수 있다.

마찬가지로 `*` 을 이용하여 모든 method를 허용할 수 있다.

## Annotation으로 해결하기

두번째 방법은 Controller 또는 메소드단에서 annotation을 통해 적용하는 방식입니다.

### 클래스 단에서

```java
@RequestMapping("/somePath")
@CrossOrigin(origins = "*", allowedHeaders = "*")
pubic class SomeController {
}
```

### 메소드 단에서

```java
@RestController
@RequestMapping("/somePath")
public class SomeController {
	
	@CrossOrigin(origins="*")
	@RequestMapping(value="/{something}", method = RequestMethod.DELETE)
	public ResponseEntity<String> delete(@PathVariable Long id){
	}
}
```

위의 Configuration에서 지정해준 것처럼 origins, methods, maxAge, allowedHeaders를 지정할 수 있다.

## Filter를 등록하여 해결하기

[Filter에 대해](https://mangkyu.tistory.com/173)

filter는 웹 컨테이너에서 관리되며 모든 요청에 대한 행위를 지정할 수 있다. 스프링과 무관하게 전역적으로 처리하는 작업을 할 수 있으며 웹 애플리케이션에 전반적으로 사용되는 기능을 구현하기에 적당한다.

```java
@Component
public class CorsFilter implements Filter {

  private Logger log = LoggerFactory.getLogger(CorsFilter.class);

  @Override
  public void init(FilterConfig filterConfig) throws ServletException {

  }

  @Override
  public void doFilter(
      ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    HttpServletResponse res = (HttpServletResponse) response;

    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Credentials", "true");
    res.setHeader("Access-Control-Allow-Methods","*");
    res.setHeader("Access-Control-Max-Age", "3600");
    res.setHeader("Access-Control-Allow-Headers", "*");

    if("OPTIONS".equalsIgnoreCase(req.getMethod())) {
      log.info("host : " + req.getRemoteHost());
      log.info("addr : " + req.getRemoteAddr());
      log.info("port : " + req.getRemotePort());
      res.setStatus(HttpServletResponse.SC_OK);
    }else {
      chain.doFilter(req, res);
    }
  }

  @Override
  public void destroy() {

  }
}
```

# 참고
</details>

---

<details>
    <summary><b>DNS</b></summary>
</details>

---

<details>
    <summary><b>Blocking/Nonblocking&Synchronous/Asynchronous</b></summary>
</details>

---

<details>
    <summary><b>웹 통신의 흐름(www.example.com을 입력했을 때)</b></summary>
</details>

---
